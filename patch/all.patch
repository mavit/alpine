diff -rc alpine-2.11/alpine/adrbkcmd.c alpine-2.11.I.USE/alpine/adrbkcmd.c
*** alpine-2.11/alpine/adrbkcmd.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/adrbkcmd.c	2013-12-01 16:34:18.000000000 -0700
***************
*** 4128,4133 ****
--- 4128,4135 ----
  	 * won't do anything, but will cause compose_mail to think there's
  	 * already a role so that it won't try to confirm the default.
  	 */
+ 	if (ps_global->role)
+ 	   fs_give((void **)&ps_global->role);
  	if(role)
  	  role = copy_action(role);
  	else{
***************
*** 4135,4140 ****
--- 4137,4143 ----
  	    memset((void *)role, 0, sizeof(*role));
  	    role->nick = cpystr("Default Role");
  	}
+ 	ps_global->role = cpystr(role->nick);
      }
  
      compose_mail(addr, fcc, role, NULL, NULL);
diff -rc alpine-2.11/alpine/alpine.c alpine-2.11.I.USE/alpine/alpine.c
*** alpine-2.11/alpine/alpine.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/alpine.c	2013-12-01 16:39:27.000000000 -0700
***************
*** 308,313 ****
--- 308,314 ----
      mail_parameters(NULL, SET_SENDCOMMAND, (void *) pine_imap_cmd_happened);
      mail_parameters(NULL, SET_FREESTREAMSPAREP, (void *) sp_free_callback);
      mail_parameters(NULL, SET_FREEELTSPAREP,    (void *) free_pine_elt);
+     mail_parameters(NULL, SET_ERASEPASSWORD, (void *) pine_delete_pwd);
  #ifdef	SMIME
      mail_parameters(NULL, SET_FREEBODYSPAREP,   (void *) free_smime_body_sparep);
  #endif
***************
*** 459,464 ****
--- 460,470 ----
  
      convert_args_to_utf8(pine_state, &args);
  
+     if (args.action == aaFolder && !args.data.folder &&
+ 		ps_global->send_immediately){
+ 	printf(_("No value for To: field specified\n"));
+ 	exit(-1);
+     }
      if(args.action == aaFolder){
  	pine_state->beginning_of_month = first_run_of_month();
  	pine_state->beginning_of_year = first_run_of_year();
***************
*** 467,472 ****
--- 473,479 ----
      /* Set up optional for user-defined display filtering */
      pine_state->tools.display_filter	     = dfilter;
      pine_state->tools.display_filter_trigger = dfilter_trigger;
+     pine_state->tools.exec_rule		     = exec_function_rule;
  
  #ifdef _WINDOWS
      if(ps_global->install_flag){
***************
*** 558,563 ****
--- 565,575 ----
      if(F_ON(F_MAILDROPS_PRESERVE_STATE, ps_global))
        mail_parameters(NULL, SET_SNARFPRESERVE, (void *) TRUE);
  
+ #ifndef _WINDOWS
+     mail_parameters(NULL,SET_COURIERSTYLE,
+                (void *)(F_ON(F_COURIER_FOLDER_LIST, ps_global) ? 1 : 0));
+ #endif
+ 
      rvl = 0L;
      if(pine_state->VAR_NNTPRANGE){
  	if(!SVAR_NNTPRANGE(pine_state, rvl, tmp_20k_buf, SIZEOF_20KBUF))
***************
*** 677,682 ****
--- 689,695 ----
          
  
      /*--- output side ---*/
+     if (!ps_global->send_immediately){
      rv = config_screen(&(pine_state->ttyo));
  #ifndef _WINDOWS	/* always succeeds under _WINDOWS */
      if(rv){
***************
*** 717,728 ****
      /* initialize titlebar in case we use it */
      set_titlebar("", NULL, NULL, NULL, NULL, 0, FolderName, 0, 0, NULL);
  
-     /*
-      * Prep storage object driver for PicoText 
-      */
-     so_register_external_driver(pine_pico_get, pine_pico_give, pine_pico_writec, pine_pico_readc, 
- 				pine_pico_puts, pine_pico_seek, NULL, NULL);
- 
  #ifdef	DEBUG
      if(ps_global->debug_imap > 4 || debug > 9){
  	q_status_message(SM_ORDER | SM_DING, 5, 9,
--- 730,735 ----
***************
*** 730,735 ****
--- 737,755 ----
  	flush_status_messages(0);
      }
  #endif
+     }
+     else{
+      fake_config_screen(&(pine_state->ttyo));
+      init_folders(pine_state);		/* digest folder spec's */
+     }
+ 
+     /*
+      * Prep storage object driver for PicoText 
+      */
+     so_register_external_driver(pine_pico_get, pine_pico_give, 
+ 	(args.noutf8 == 0 ? pine_pico_writec : pine_pico_writec_noucs), 
+ 	(args.noutf8 == 0 ? pine_pico_readc : pine_pico_readc_noucs), 
+ 	(args.noutf8 == 0 ? pine_pico_puts : pine_pico_puts_noucs), pine_pico_seek, NULL, NULL);
  
      if(args.action == aaPrcCopy || args.action == aaAbookCopy){
  	int   exit_val = -1;
***************
*** 905,910 ****
--- 925,936 ----
          int	    len, good_addr = 1;
  	int	    exit_val = 0;
  	BUILDER_ARG fcc;
+         ACTION_S  *role = NULL;
+ 
+         if (pine_state->in_init_seq && pine_state->send_immediately
+ 		&&  (char) *pine_state->initial_cmds++ == '#'
+ 		&&  ++pine_state->initial_cmds_offset)
+             role_select_screen(pine_state, &role, 1);
  
  	if(pine_state->in_init_seq){
  	    pine_state->in_init_seq = pine_state->save_in_init_seq = 0;
***************
*** 943,949 ****
  	  memset(&fcc, 0, sizeof(fcc));
  
  	if(good_addr){
! 	    compose_mail(addr, fcc.tptr, NULL,
  			 args.data.mail.attachlist, stdin_getc);
  	}
  	else{
--- 969,975 ----
  	  memset(&fcc, 0, sizeof(fcc));
  
  	if(good_addr){
! 	    compose_mail(addr, fcc.tptr, role,
  			 args.data.mail.attachlist, stdin_getc);
  	}
  	else{
***************
*** 977,982 ****
--- 1003,1009 ----
              
          pine_state->mail_stream    = NULL;
          pine_state->mangled_screen = 1;
+         pine_state->subject        = NULL;
  
  	if(args.action == aaURL){
  	    url_tool_t f;
***************
*** 1092,1097 ****
--- 1119,1125 ----
  	    }
          }
  
+        if (!pine_state->send_immediately)
          fflush(stdout);
  
  #if !defined(_WINDOWS) && !defined(LEAVEOUTFIFO)
***************
*** 2980,2989 ****
      if(i > 0){
  	ps->initial_cmds = (int *)fs_get((i+1) * sizeof(int));
  	ps->free_initial_cmds = ps->initial_cmds;
  	for(j = 0; j < i; j++)
! 	  ps->initial_cmds[j] = i_cmds[j];
! 
! 	ps->initial_cmds[i] = 0;
  	ps->in_init_seq = ps->save_in_init_seq = 1;
      }
  }
--- 3008,3022 ----
      if(i > 0){
  	ps->initial_cmds = (int *)fs_get((i+1) * sizeof(int));
  	ps->free_initial_cmds = ps->initial_cmds;
+ 	ps->initial_cmds_backup = (int *)fs_get((i+1) * sizeof(int));
+ 	ps->free_initial_cmds_backup = ps->initial_cmds_backup;
  	for(j = 0; j < i; j++)
! 	  ps->initial_cmds[j] = ps->initial_cmds_backup[j] = i_cmds[j];
! #define ctrl_x 24
!       if (i > 1)
! 	ps->send_immediately = i_cmds[i - 2] == ctrl_x
! 			&& ((i_cmds[i - 1] == 'y') || (i_cmds[i-1] == 'Y'));
! 	ps->initial_cmds[i] = ps->initial_cmds_backup[i] = 0;
  	ps->in_init_seq = ps->save_in_init_seq = 1;
      }
  }
***************
*** 3139,3144 ****
--- 3172,3180 ----
      extern KBESC_T *kbesc;
  
      dprint((2, "goodnight_gracey:\n"));    
+     strncpy(pine_state->cur_folder, pine_state->inbox_name, 
+ 					sizeof(pine_state->cur_folder));
+     pine_state->cur_folder[sizeof(pine_state->cur_folder) - 1] = '\0';
  
      /* We want to do this here before we close up the streams */
      trim_remote_adrbks();
diff -rc alpine-2.11/alpine/arg.c alpine-2.11.I.USE/alpine/arg.c
*** alpine-2.11/alpine/arg.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/arg.c	2013-12-01 16:41:02.000000000 -0700
***************
*** 60,65 ****
--- 60,66 ----
  static char args_err_non_abs_passfile[] =	N_("argument to \"-passfile\" should be fully-qualified");
  #endif
  static char args_err_missing_sort[] =		N_("missing argument for option \"-sort\"");
+ static char args_err_missing_thread_sort[] =	N_("missing argument for option \"-threadsort\"");
  static char args_err_missing_flag_arg[] =	N_("missing argument for flag \"%c\"");
  static char args_err_missing_flag_num[] =	N_("Non numeric argument for flag \"%c\"");
  static char args_err_missing_debug_num[] =	N_("Non numeric argument for \"%s\"");
***************
*** 103,113 ****
--- 104,116 ----
  N_(" -z \t\tSuspend - allow use of ^Z suspension"),
  N_(" -r \t\tRestricted - can only send mail to oneself"),
  N_(" -sort <sort>\tSort - Specify sort order of folder:"),
+ N_(" -threadsort <sort>\tSort - Specify sort order of thread index screen:"),
  N_("\t\t\tarrival, subject, threaded, orderedsubject, date,"),
  N_("\t\t\tfrom, size, score, to, cc, /reverse"),
  N_(" -i\t\tIndex - Go directly to index, bypassing main menu"),
  N_(" -I <keystroke_list>   Initial keystrokes to be executed"),
  N_(" -n <number>\tEntry in index to begin on"),
+ N_(" -noutf8\t Warns Alpine that piped input is not encoded in utf-8"),
  N_(" -o \t\tReadOnly - Open first folder read-only"),
  N_(" -conf\t\tConfiguration - Print out fresh global configuration. The"),
  N_("\t\tvalues of your global configuration affect all Alpine users"),
***************
*** 192,197 ****
--- 195,201 ----
      char *cmd_list            = NULL;
      char *debug_str           = NULL;
      char *sort                = NULL;
+     char *threadsort          = NULL;
      char *pinerc_file         = NULL;
      char *lc		      = NULL;
      int   do_help             = 0;
***************
*** 363,368 ****
--- 367,383 ----
  
  		  goto Loop;
  	      }
+ 	      else if(strcmp(*av, "threadsort") == 0){
+ 	            if(--ac){
+ 	                threadsort = *++av;
+ 	                COM_THREAD_SORT_KEY = cpystr(threadsort);
+ 	            }
+ 	            else{
+ 	                display_args_err(_(args_err_missing_thread_sort), NULL, 1);
+ 	              ++usage;
+ 	          }
+ 	          goto Loop;
+ 	      }
  	      else if(strcmp(*av, "url") == 0){
  		  if(args->action == aaFolder && !args->data.folder){
  		      args->action = aaURL;
***************
*** 469,474 ****
--- 484,493 ----
  
  		  goto Loop;
  	      }
+ 	      else if(strcmp(*av, "noutf8") == 0){
+ 		  args->noutf8++;
+ 		  goto Loop;
+ 	      }
  	      else if(strcmp(*av, "bail") == 0){
  		  pine_state->exit_if_no_pinerc = 1;
  		  goto Loop;
***************
*** 477,482 ****
--- 496,507 ----
  		  do_version = 1;
  		  goto Loop;
  	      }
+               else if(strcmp(*av, "subject") == 0){
+                      if(--ac){
+                         pine_state->subject = cpystr(*++av);
+                         }
+                         goto Loop;
+               }
  #ifdef	_WINDOWS
  	      else if(strcmp(*av, "install") == 0){
  		  pine_state->install_flag = 1;
***************
*** 827,840 ****
        exit(-1);
  
      if(do_version){
! 	extern char datestamp[], hoststamp[];
  	char rev[128];
  
! 	snprintf(tmp_20k_buf, SIZEOF_20KBUF, "Alpine %s (%s %s) built %s on %s",
  		 ALPINE_VERSION,
  		 SYSTYPE ? SYSTYPE : "?",
  		 get_alpine_revision_string(rev, sizeof(rev)),
! 		 datestamp, hoststamp);
  	tmp_20k_buf[SIZEOF_20KBUF-1] = '\0';
  	display_args_err(tmp_20k_buf, NULL, 0);
  	exit(0);
--- 852,865 ----
        exit(-1);
  
      if(do_version){
! 	extern char datestamp[], hoststamp[], plevstamp[];
  	char rev[128];
  
! 	snprintf(tmp_20k_buf, SIZEOF_20KBUF, "Alpine %s (%s %s) built %s on %s, using patchlevel %s.",
  		 ALPINE_VERSION,
  		 SYSTYPE ? SYSTYPE : "?",
  		 get_alpine_revision_string(rev, sizeof(rev)),
! 		 datestamp, hoststamp, plevstamp);
  	tmp_20k_buf[SIZEOF_20KBUF-1] = '\0';
  	display_args_err(tmp_20k_buf, NULL, 0);
  	exit(0);
diff -rc alpine-2.11/alpine/arg.h alpine-2.11.I.USE/alpine/arg.h
*** alpine-2.11/alpine/arg.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/arg.h	2013-12-01 16:39:27.000000000 -0700
***************
*** 27,32 ****
--- 27,33 ----
  typedef struct argdata {
      enum	{aaFolder = 0, aaMore, aaURL, aaMail,
  		 aaPrcCopy, aaAbookCopy} action;
+     int	noutf8;
      union {
  	char	  *folder;
  	char	  *file;
diff -rc alpine-2.11/alpine/busy.c alpine-2.11.I.USE/alpine/busy.c
*** alpine-2.11/alpine/busy.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/busy.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 226,232 ****
  
  	    add_review_message(buf, -1);
  	}
! 	else{
  	    q_status_message(SM_ORDER, 0, 1, progress);
  
  	    /*
--- 226,232 ----
  
  	    add_review_message(buf, -1);
  	}
! 	else if (!ps_global->send_immediately){
  	    q_status_message(SM_ORDER, 0, 1, progress);
  
  	    /*
***************
*** 238,245 ****
  	     */
  	    display_message('x');
  	}
! 	
! 	fflush(stdout);
      }
  
      /*
--- 238,245 ----
  	     */
  	    display_message('x');
  	}
! 	if (!ps_global->send_immediately)   
! 	  fflush(stdout);
      }
  
      /*
***************
*** 287,293 ****
      (*ap)->cf	 = done_busy_cue;
      ap		 = &(*ap)->next;
  
!     start_after(a);		/* launch cue handler */
  
  #ifdef _WINDOWS
      mswin_setcursor(MSWIN_CURSOR_BUSY);
--- 287,294 ----
      (*ap)->cf	 = done_busy_cue;
      ap		 = &(*ap)->next;
  
!     if(!ps_global->send_immediately)
!        start_after(a);		/* launch cue handler */
  
  #ifdef _WINDOWS
      mswin_setcursor(MSWIN_CURSOR_BUSY);
***************
*** 436,441 ****
--- 437,447 ----
  {
      int space_left, slots_used;
  
+     if (ps_global->send_immediately){
+ 	mark_status_dirty();
+ 	return;
+     }
+ 
      if(final_message && final_message_pri >= 0){
  	char progress[MAX_SCREEN_COLS+1];
  
diff -rc alpine-2.11/alpine/confscroll.c alpine-2.11.I.USE/alpine/confscroll.c
*** alpine-2.11/alpine/confscroll.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/confscroll.c	2013-12-01 16:40:48.000000000 -0700
***************
*** 51,56 ****
--- 51,57 ----
  #include "../pith/tempfile.h"
  #include "../pith/pattern.h"
  #include "../pith/charconv/utf8.h"
+ #include "../pith/rules.h"
  
  
  #define	CONFIG_SCREEN_HELP_TITLE	_("HELP FOR SETUP CONFIGURATION")
***************
*** 139,145 ****
  char    *radio_pretty_value(struct pine *, CONF_S *);
  char    *sigfile_pretty_value(struct pine *, CONF_S *);
  char    *color_pretty_value(struct pine *, CONF_S *);
! char    *sort_pretty_value(struct pine *, CONF_S *);
  int      longest_feature_name(void);
  COLOR_PAIR *sample_color(struct pine *, struct variable *);
  COLOR_PAIR *sampleexc_color(struct pine *, struct variable *);
--- 140,146 ----
  char    *radio_pretty_value(struct pine *, CONF_S *);
  char    *sigfile_pretty_value(struct pine *, CONF_S *);
  char    *color_pretty_value(struct pine *, CONF_S *);
! char    *sort_pretty_value(struct pine *, CONF_S *, int);
  int      longest_feature_name(void);
  COLOR_PAIR *sample_color(struct pine *, struct variable *);
  COLOR_PAIR *sampleexc_color(struct pine *, struct variable *);
***************
*** 287,293 ****
      CONF_S *ctmp;
  
      if(!(cl && *cl &&
!        ((*cl)->var == &ps->vars[V_SORT_KEY] ||
          standard_radio_var(ps, (*cl)->var) ||
  	(*cl)->var == startup_ptr)))
        return;
--- 288,295 ----
      CONF_S *ctmp;
  
      if(!(cl && *cl &&
!         (((*cl)->var == &ps->vars[V_SORT_KEY]) || 
!         ((*cl)->var == &ps->vars[V_THREAD_SORT_KEY]) ||
          standard_radio_var(ps, (*cl)->var) ||
  	(*cl)->var == startup_ptr)))
        return;
***************
*** 463,469 ****
      char	  tmp[MAXPATH+1];
      char         *utf8str;
      UCS           ch = 'x';
!     int		  cmd, i, j, done = 0, changes = 0;
      int		  retval = 0;
      int		  km_popped = 0, stay_in_col = 0;
      struct	  key_menu  *km = NULL;
--- 465,471 ----
      char	  tmp[MAXPATH+1];
      char         *utf8str;
      UCS           ch = 'x';
!     int		  cmd, i, j, k = 1, done = 0, changes = 0;
      int		  retval = 0;
      int		  km_popped = 0, stay_in_col = 0;
      struct	  key_menu  *km = NULL;
***************
*** 512,517 ****
--- 514,520 ----
  	}
  
  	/*----------- Check for new mail -----------*/
+         if (!ps->send_immediately){
          if(new_mail(0, NM_TIMING(ch), NM_STATUS_MSG | NM_DEFER_SORT) >= 0)
            ps->mangled_header = 1;
  
***************
*** 541,546 ****
--- 544,550 ----
  	    mark_status_unknown();
  	}
  
+ 	} /* send_immediately */
  	if(ps->mangled_footer || km != screen->current->keymenu){
  	    bitmap_t	 bitmap;
  
***************
*** 612,617 ****
--- 616,622 ----
  	    }
  	}
  
+ 	if(!ps_global->send_immediately){
  	MoveCursor(cursor_pos.row, cursor_pos.col);
  #ifdef	MOUSE
  	mouse_in_content(KEY_MOUSE, -1, -1, 0, 0);	/* prime the handler */
***************
*** 630,635 ****
--- 635,648 ----
  #ifdef	_WINDOWS
  	mswin_setscrollcallback(NULL);
  #endif
+         } /* send_immediately */
+                        
+         if (ps->send_immediately){
+ 	      ps_global->dont_use_init_cmds = 0;
+               process_config_input(&ch);
+               if (ch == '\030')   /* ^X, bye */
+                 goto end;
+         }           
  
  	cmd = menu_command(ch, km);
  
***************
*** 1383,1389 ****
  	    break;
  	}
      }
! 
      screen->current = first_confline(screen->current);
      free_conflines(&screen->current);
      return(retval);
--- 1396,1402 ----
  	    break;
  	}
      }
! end:
      screen->current = first_confline(screen->current);
      free_conflines(&screen->current);
      return(retval);
***************
*** 1552,1557 ****
--- 1565,1574 ----
  	    lowrange = 1;
  	    hirange  = MAX_FILLCOL;
  	}
+ 	else if((*cl)->var == &ps->vars[V_SLEEP]){
+ 	    lowrange = 0;
+ 	    hirange  = 120;
+ 	}
  	else if((*cl)->var == &ps->vars[V_OVERLAP]
  		|| (*cl)->var == &ps->vars[V_MARGIN]){
  	    lowrange = 0;
***************
*** 2427,2432 ****
--- 2444,2452 ----
  	 * Now go and set the current_val based on user_val changes
  	 * above.  Turn off command line settings...
  	 */
+ 	set_current_val((*cl)->var,
+ 	    (strcmp((*cl)->var->name,"key-definition-rules") ? TRUE : FALSE),
+ 	    FALSE);
  	set_current_val((*cl)->var, TRUE, FALSE);
  	fix_side_effects(ps, (*cl)->var, 0);
  
***************
*** 2923,2929 ****
  	    }
  
  	    set_current_val((*cl)->var, TRUE, TRUE);
! 	    if(decode_sort(ps->VAR_SORT_KEY, &def_sort, &def_sort_rev) != -1){
  		ps->def_sort     = def_sort;
  		ps->def_sort_rev = def_sort_rev;
  	    }
--- 2943,2949 ----
  	    }
  
  	    set_current_val((*cl)->var, TRUE, TRUE);
! 	    if(decode_sort(ps->VAR_SORT_KEY, &def_sort, &def_sort_rev,0) != -1){
  		ps->def_sort     = def_sort;
  		ps->def_sort_rev = def_sort_rev;
  	    }
***************
*** 2932,2937 ****
--- 2952,2988 ----
  	    ps->mangled_body = 1;	/* BUG: redraw it all for now? */
  	    rv = 1;
  	}
+         else if((*cl)->var == &ps->vars[V_THREAD_SORT_KEY]){
+             SortOrder thread_def_sort;
+             int       thread_def_sort_rev;
+ 
+             thread_def_sort_rev  = (*cl)->varmem >= (short) EndofList;
+             thread_def_sort      = (SortOrder) ((*cl)->varmem - (thread_def_sort_rev
+                                                                  * EndofList));
+             sprintf(tmp_20k_buf, "%s%s", sort_name(thread_def_sort),
+                    (thread_def_sort_rev) ? "/Reverse" : "");
+ 
+             if((*cl)->var->cmdline_val.p)
+               fs_give((void **)&(*cl)->var->cmdline_val.p);
+ 
+             if(apval){
+                 if(*apval)
+                   fs_give((void **)apval);
+ 
+                 *apval = cpystr(tmp_20k_buf);
+             }
+ 
+             set_current_val((*cl)->var, TRUE, TRUE);
+             if(decode_sort(ps->VAR_THREAD_SORT_KEY, &thread_def_sort, 
+                                         &thread_def_sort_rev, 1) != -1){
+                 ps->thread_def_sort     = thread_def_sort;
+                 ps->thread_def_sort_rev = thread_def_sort_rev;
+             }
+ 
+             set_radio_pretty_vals(ps, cl);
+             ps->mangled_body = 1;       /* BUG: redraw it all for now? */
+             rv = 1;
+         }
  	else
  	  q_status_message(SM_ORDER | SM_DING, 3, 6,
  			   "Programmer botch!  Unknown radiobutton type.");
***************
*** 3794,3800 ****
      else if(standard_radio_var(ps, v) || v == startup_ptr)
        return(radio_pretty_value(ps, cl));
      else if(v == &ps->vars[V_SORT_KEY])
!       return(sort_pretty_value(ps, cl));
      else if(v == &ps->vars[V_SIGNATURE_FILE])
        return(sigfile_pretty_value(ps, cl));
      else if(v == &ps->vars[V_USE_ONLY_DOMAIN_NAME])
--- 3845,3853 ----
      else if(standard_radio_var(ps, v) || v == startup_ptr)
        return(radio_pretty_value(ps, cl));
      else if(v == &ps->vars[V_SORT_KEY])
!        return(sort_pretty_value(ps, cl, 0));
!      else if(v == &ps->vars[V_THREAD_SORT_KEY])
!        return(sort_pretty_value(ps, cl, 1));
      else if(v == &ps->vars[V_SIGNATURE_FILE])
        return(sigfile_pretty_value(ps, cl));
      else if(v == &ps->vars[V_USE_ONLY_DOMAIN_NAME])
***************
*** 4325,4338 ****
  
  
  char *
! sort_pretty_value(struct pine *ps, CONF_S *cl)
  {
!     return(generalized_sort_pretty_value(ps, cl, 1));
  }
  
  
  char *
! generalized_sort_pretty_value(struct pine *ps, CONF_S *cl, int default_ok)
  {
      char  tmp[6*MAXPATH];
      char *pvalnorm, *pvalexc, *pval;
--- 4378,4391 ----
  
  
  char *
! sort_pretty_value(struct pine *ps, CONF_S *cl, int thread)
  {
!     return(generalized_sort_pretty_value(ps, cl, 1, thread));
  }
  
  
  char *
! generalized_sort_pretty_value(struct pine *ps, CONF_S *cl, int default_ok, int thread)
  {
      char  tmp[6*MAXPATH];
      char *pvalnorm, *pvalexc, *pval;
***************
*** 4382,4388 ****
      }
      else if(fixed){
  	pval = v->fixed_val.p;
! 	decode_sort(pval, &var_sort, &var_sort_rev);
  	is_the_one = (var_sort_rev == line_sort_rev && var_sort == line_sort);
  
  	utf8_snprintf(tmp, sizeof(tmp), "(%c)  %s%-*w%*s%s",
--- 4435,4441 ----
      }
      else if(fixed){
  	pval = v->fixed_val.p;
! 	decode_sort(pval, &var_sort, &var_sort_rev, thread);
  	is_the_one = (var_sort_rev == line_sort_rev && var_sort == line_sort);
  
  	utf8_snprintf(tmp, sizeof(tmp), "(%c)  %s%-*w%*s%s",
***************
*** 4393,4401 ****
  		is_the_one ? "   (value is fixed)" : "");
      }
      else if(is_set_for_this_level){
! 	decode_sort(pval, &var_sort, &var_sort_rev);
  	is_the_one = (var_sort_rev == line_sort_rev && var_sort == line_sort);
! 	decode_sort(pvalexc, &exc_sort, &exc_sort_rev);
  	the_exc_one = (editing_normal_which_isnt_except && pvalexc &&
  		       exc_sort_rev == line_sort_rev && exc_sort == line_sort);
  	utf8_snprintf(tmp, sizeof(tmp), "(%c)  %s%-*w%*s%s",
--- 4446,4454 ----
  		is_the_one ? "   (value is fixed)" : "");
      }
      else if(is_set_for_this_level){
! 	decode_sort(pval, &var_sort, &var_sort_rev, thread);
  	is_the_one = (var_sort_rev == line_sort_rev && var_sort == line_sort);
! 	decode_sort(pvalexc, &exc_sort, &exc_sort_rev, thread);
  	the_exc_one = (editing_normal_which_isnt_except && pvalexc &&
  		       exc_sort_rev == line_sort_rev && exc_sort == line_sort);
  	utf8_snprintf(tmp, sizeof(tmp), "(%c)  %s%-*w%*s%s",
***************
*** 4413,4419 ****
      }
      else{
  	if(pvalexc){
! 	    decode_sort(pvalexc, &exc_sort, &exc_sort_rev);
  	    is_the_one = (exc_sort_rev == line_sort_rev &&
  			  exc_sort == line_sort);
  	    utf8_snprintf(tmp, sizeof(tmp), "( )  %s%-*w%*s%s",
--- 4466,4472 ----
      }
      else{
  	if(pvalexc){
! 	    decode_sort(pvalexc, &exc_sort, &exc_sort_rev, thread);
  	    is_the_one = (exc_sort_rev == line_sort_rev &&
  			  exc_sort == line_sort);
  	    utf8_snprintf(tmp, sizeof(tmp), "( )  %s%-*w%*s%s",
***************
*** 4424,4430 ****
  	}
  	else{
  	    pval = v->current_val.p;
! 	    decode_sort(pval, &var_sort, &var_sort_rev);
  	    is_the_one = ((pval || default_ok) &&
  			  var_sort_rev == line_sort_rev &&
  			  var_sort == line_sort);
--- 4477,4483 ----
  	}
  	else{
  	    pval = v->current_val.p;
! 	    decode_sort(pval, &var_sort, &var_sort_rev, thread);
  	    is_the_one = ((pval || default_ok) &&
  			  var_sort_rev == line_sort_rev &&
  			  var_sort == line_sort);
***************
*** 5161,5166 ****
--- 5214,5243 ----
  	    var == &ps->vars[V_ABOOK_FORMATS]){
  	addrbook_reset();
      }
+     else if(var == &ps->vars[V_INDEX_RULES]){
+ 	   if(ps_global->rule_list)
+ 	      free_parsed_rule_list(&ps_global->rule_list);
+ 	   create_rule_list(ps->vars);
+ 	   reset_index_format();
+ 	   clear_index_cache(ps->mail_stream, 0);
+     }
+     else if(var == &ps->vars[V_COMPOSE_RULES] ||
+ 	    var == &ps->vars[V_FORWARD_RULES] ||
+ 	    var == &ps->vars[V_KEY_RULES] ||
+ 	    var == &ps->vars[V_REPLACE_RULES] ||
+ 	    var == &ps->vars[V_REPLY_INDENT_RULES] ||
+ 	    var == &ps->vars[V_REPLY_LEADIN_RULES] ||
+ 	    var == &ps->vars[V_RESUB_RULES] ||
+ 	    var == &ps->vars[V_SAVE_RULES] ||
+ 	    var == &ps->vars[V_SMTP_RULES] ||
+ 	    var == &ps->vars[V_SORT_RULES] ||
+ 	    var == &ps->vars[V_STARTUP_RULES] ||
+ 	    var == &ps->vars[V_THREAD_DISP_STYLE_RULES] ||
+ 	    var == &ps->vars[V_THREAD_INDEX_STYLE_RULES]){
+ 	if(ps_global->rule_list)
+ 	   free_parsed_rule_list(&ps_global->rule_list);
+ 	create_rule_list(ps->vars);
+     }
      else if(var == &ps->vars[V_INDEX_FORMAT]){
  	reset_index_format();
  	clear_index_cache(ps->mail_stream, 0);
***************
*** 5183,5188 ****
--- 5260,5268 ----
  
  	clear_index_cache(ps->mail_stream, 0);
      }
+     else if(var == &ps->vars[V_SPECIAL_TEXT]){
+ 	regex_pattern(ps->VAR_SPECIAL_TEXT);
+     }
      else if(var == &ps->vars[V_INIT_CMD_LIST]){
  	if(!revert)
  	  q_status_message(SM_ASYNC, 0, 3,
***************
*** 5215,5220 ****
--- 5295,5310 ----
  	else
  	  ps->viewer_overlap = old_value;
      }
+     else if(var == &ps->vars[V_SLEEP]){
+ 	int old_value = ps->sleep;
+ 
+ 	if(SVAR_SLEEP(ps, old_value, tmp_20k_buf, SIZEOF_20KBUF)){
+ 	    if(!revert)
+ 	      q_status_message(SM_ORDER, 3, 5, tmp_20k_buf);
+ 	}
+ 	else
+ 	  ps->sleep = old_value;
+     }
  #ifdef	SMIME
      else if(smime_related_var(ps, var)){
  	smime_deinit();
***************
*** 5496,5501 ****
--- 5586,5597 ----
  			  (void *)var->current_val.p);
      }
  #endif
+ #ifndef _WINDOWS
+     else if(var == &ps->vars[V_MAILDIR_LOCATION]){
+       if(var->current_val.p && var->current_val.p[0])
+ 	mail_parameters(NULL, SET_MDINBOXPATH, (void *)var->current_val.p);
+     }
+ #endif
      else if(revert && standard_radio_var(ps, var)){
  
  	cur_rule_value(var, TRUE, FALSE);
***************
*** 5545,5553 ****
      else if(revert && var == &ps->vars[V_SORT_KEY]){
  	int def_sort_rev;
  
! 	decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev);
  	ps->def_sort_rev = def_sort_rev;
      }
      else if(var == &ps->vars[V_THREAD_MORE_CHAR] ||
              var == &ps->vars[V_THREAD_EXP_CHAR] ||
              var == &ps->vars[V_THREAD_LASTREPLY_CHAR]){
--- 5641,5655 ----
      else if(revert && var == &ps->vars[V_SORT_KEY]){
  	int def_sort_rev;
  
! 	decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev, 0);
  	ps->def_sort_rev = def_sort_rev;
      }
+     else if(revert && var == &ps->vars[V_THREAD_SORT_KEY]){
+       int thread_def_sort_rev;
+ 
+       decode_sort(VAR_THREAD_SORT_KEY, &ps->thread_def_sort, &thread_def_sort_rev, 1);
+       ps->thread_def_sort_rev = thread_def_sort_rev;
+     }
      else if(var == &ps->vars[V_THREAD_MORE_CHAR] ||
              var == &ps->vars[V_THREAD_EXP_CHAR] ||
              var == &ps->vars[V_THREAD_LASTREPLY_CHAR]){
diff -rc alpine-2.11/alpine/confscroll.h alpine-2.11.I.USE/alpine/confscroll.h
*** alpine-2.11/alpine/confscroll.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/confscroll.h	2013-12-01 16:33:57.000000000 -0700
***************
*** 95,101 ****
  int	 radiobutton_tool(struct pine *, int, CONF_S **, unsigned);
  int	 yesno_tool(struct pine *, int, CONF_S **, unsigned);
  int      text_toolit(struct pine *, int, CONF_S **, unsigned, int);
! char    *generalized_sort_pretty_value(struct pine *, CONF_S *, int);
  int	 exclude_config_var(struct pine *, struct variable *, int);
  int      config_exit_cmd(unsigned);
  int	 simple_exit_cmd(unsigned);
--- 95,101 ----
  int	 radiobutton_tool(struct pine *, int, CONF_S **, unsigned);
  int	 yesno_tool(struct pine *, int, CONF_S **, unsigned);
  int      text_toolit(struct pine *, int, CONF_S **, unsigned, int);
! char    *generalized_sort_pretty_value(struct pine *, CONF_S *, int, int);
  int	 exclude_config_var(struct pine *, struct variable *, int);
  int      config_exit_cmd(unsigned);
  int	 simple_exit_cmd(unsigned);
diff -rc alpine-2.11/alpine/dispfilt.c alpine-2.11.I.USE/alpine/dispfilt.c
*** alpine-2.11/alpine/dispfilt.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/dispfilt.c	2013-12-01 16:39:17.000000000 -0700
***************
*** 243,248 ****
--- 243,261 ----
  	    fs_give((void **)q);
  	    *q = rl ? rl : cpystr("");
  	}
+ 	else if(!strcmp(*q, "_ADDRESS_")){
+ 	    char *r = NULL;
+ 
+ 	    if(env && env->from && env->from->mailbox && env->from->host){
+ 		size_t l;
+ 		l = strlen(env->from->mailbox) + strlen(env->from->host) + 1;
+ 		r = (char *) fs_get((l+1) * sizeof(char));
+ 		snprintf(r, l+1, "%s@%s", env->from->mailbox, env->from->host);
+ 	    }
+ 
+ 	    fs_give((void **)q);
+ 	    *q = r ? r : cpystr("");
+ 	}
  	else if(!strcmp(*q, "_TMPFILE_")){
  	    if(!tfn){
  		tfn = temp_nam(NULL, "sf"); 	/* send filter file */
***************
*** 461,463 ****
--- 474,536 ----
  
      return(passed);
  }
+ 
+ char *
+ exec_function_rule(char *rawcmd, gf_io_t input_gc, gf_io_t output_pc)
+ {
+     char *status = NULL, *cmd,  *tmpfile = NULL;
+ 
+     if((cmd = expand_filter_tokens(rawcmd,NULL,&tmpfile,NULL,NULL,NULL,NULL,NULL)) != NULL){
+ 	suspend_busy_cue();
+ 	ps_global->mangled_screen = 1;
+ 	if(tmpfile){
+ 	    PIPE_S	  *filter_pipe;
+ 	    FILE          *fp;
+ 	    gf_io_t	   gc, pc;
+ 	    STORE_S       *tmpf_so;
+ 
+ 	    /* write the tmp file */
+ 	    if((tmpf_so = so_get(FileStar, tmpfile, WRITE_ACCESS|OWNER_ONLY|WRITE_TO_LOCALE)) != NULL){
+ 	        /* copy input to tmp file */
+ 		gf_set_so_writec(&pc, tmpf_so);
+ 		gf_filter_init();
+ 		status = gf_pipe(input_gc, pc);
+ 		gf_clear_so_writec(tmpf_so);
+ 		if(so_give(&tmpf_so) != 0 && status == NULL)
+ 		  status = error_description(errno);
+ 
+ 		/* prepare the terminal in case the filter uses it */
+ 		if(status == NULL){
+ 		    if((filter_pipe = open_system_pipe(cmd, NULL, NULL,
+ 						      PIPE_USER|PIPE_PROT|PIPE_NOSHELL|PIPE_SILENT,
+ 						      0, pipe_callback, NULL)) != NULL){
+ 			if(close_system_pipe(&filter_pipe, NULL, pipe_callback) == 0){
+ 			    /* pull result out of tmp file */
+ 			    if((fp = our_fopen(tmpfile, "rb")) != NULL){
+ 				gf_set_readc(&gc, fp, 0L, FileStar, READ_FROM_LOCALE);
+ 				gf_filter_init();
+ 				status = gf_pipe(gc, output_pc);
+ 				fclose(fp);
+ 			    }
+ 			    else
+ 			      status = "Can't read result of EXEC command";
+ 			}
+ 			else
+ 			  status = "EXEC command command returned error.";
+ 		    }
+ 		    else
+ 		      status = "Can't open pipe for EXEC command";
+ 		}
+ 
+ 		our_unlink(tmpfile);
+ 	    }
+ 	    else
+ 	      status = "Can't open EXEC command tmp file";
+ 	}
+ 
+ 	resume_busy_cue(0);
+ 	fs_give((void **)&cmd);
+     }
+ 
+     return(status);
+ }
diff -rc alpine-2.11/alpine/dispfilt.h alpine-2.11.I.USE/alpine/dispfilt.h
*** alpine-2.11/alpine/dispfilt.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/dispfilt.h	2013-12-01 16:34:42.000000000 -0700
***************
*** 24,30 ****
  char	*expand_filter_tokens(char *, ENVELOPE *, char **, char **, char **, int *, int *, int *);
  char	*filter_session_key(void);
  char	*filter_data_file(int);
! 
  
  
  #endif /* PINE_DISPFILT_INCLUDED */
--- 24,30 ----
  char	*expand_filter_tokens(char *, ENVELOPE *, char **, char **, char **, int *, int *, int *);
  char	*filter_session_key(void);
  char	*filter_data_file(int);
! char	*exec_function_rule(char *, gf_io_t, gf_io_t);
  
  
  #endif /* PINE_DISPFILT_INCLUDED */
diff -rc alpine-2.11/alpine/folder.c alpine-2.11.I.USE/alpine/folder.c
*** alpine-2.11/alpine/folder.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/folder.c	2013-12-01 16:37:56.000000000 -0700
***************
*** 247,253 ****
      dprint((1, "=== folder_screen called ====\n"));
      mailcap_free(); /* free resources we won't be using for a while */
      ps->next_screen = SCREEN_FUN_NULL;
! 
      /* Initialize folder state and dispatches */
      memset(&fs, 0, sizeof(FSTATE_S));
      fs.context		= cntxt;
--- 247,253 ----
      dprint((1, "=== folder_screen called ====\n"));
      mailcap_free(); /* free resources we won't be using for a while */
      ps->next_screen = SCREEN_FUN_NULL;
!     strcpy(ps->screen_name, "folder");
      /* Initialize folder state and dispatches */
      memset(&fs, 0, sizeof(FSTATE_S));
      fs.context		= cntxt;
***************
*** 344,349 ****
--- 344,350 ----
        pine_mail_close(*fs.cache_streamp);
  
      ps->prev_screen = folder_screen;
+     strcpy(ps->screen_name, "unknown");
  }
  
  
***************
*** 6342,6352 ****
  char *
  next_folder(MAILSTREAM **streamp, char *next, size_t nextlen, char *current, CONTEXT_S *cntxt, long int *find_recent, int *did_cancel)
  {
!     int       index, recent = 0, failed_status = 0, try_fast;
      char      prompt[128];
      FOLDER_S *f = NULL;
      char      tmp[MAILTMPLEN];
! 
  
      /* note: find_folders may assign "stream" */
      build_folder_list(streamp, cntxt, NULL, NULL,
--- 6343,6359 ----
  char *
  next_folder(MAILSTREAM **streamp, char *next, size_t nextlen, char *current, CONTEXT_S *cntxt, long int *find_recent, int *did_cancel)
  {
!     int       index, recent = 0, failed_status = 0, try_fast, done = 0;
      char      prompt[128];
      FOLDER_S *f = NULL;
      char      tmp[MAILTMPLEN];
!     char *test_current = cpystr(current);
!     int  cur_indx  = folder_index(ps_global->cur_folder, cntxt, FI_FOLDER);
!     int  loop = !strcmp(next, ps_global->cur_folder) ? 0 :
!               (folder_index(test_current, cntxt, FI_FOLDER) <= cur_indx
!                       ? 1 : 0);
!     int  last = !strcmp(ps_global->cur_folder, ps_global->inbox_name)
!                ? 1 : cur_indx;
  
      /* note: find_folders may assign "stream" */
      build_folder_list(streamp, cntxt, NULL, NULL,
***************
*** 6357,6363 ****
      if(find_recent)
        *find_recent = 0L;
  
!     for(index = folder_index(current, cntxt, FI_FOLDER) + 1;
  	index > 0
  	&& index < folder_total(FOLDERS(cntxt))
  	&& (f = folder_entry(index, FOLDERS(cntxt)))
--- 6364,6372 ----
      if(find_recent)
        *find_recent = 0L;
  
! 
! find_new_message:
!     for(index = folder_index(test_current, cntxt, FI_FOLDER) + 1;
  	index > 0
  	&& index < folder_total(FOLDERS(cntxt))
  	&& (f = folder_entry(index, FOLDERS(cntxt)))
***************
*** 6368,6373 ****
--- 6377,6387 ----
  	  int         rv, we_cancel = 0, match;
  	  char        msg_buf[MAX_BM+1];
  
+ 	  if (loop && (index == last)){
+ 	    done++;
+ 	    break;
+ 	  }
+ 
  	  /* must be a folder and it can't be the current one */
  	  if(ps_global->context_current == ps_global->context_list
  	     && !strcmp(ps_global->cur_folder, FLDR_NAME(f)))
***************
*** 6535,6546 ****
--- 6549,6572 ----
      if(f && (!find_recent || recent)){
  	strncpy(next, FLDR_NAME(f), nextlen);
  	next[nextlen-1] = '\0';
+ 	done++;
      }
      else if(nextlen > 0)
        *next = '\0';
  
+     if (!done && F_ON(F_AUTO_CIRCULAR_TAB,ps_global)
+        && strcmp(test_current,ps_global->inbox_name)){
+        done++; loop++;
+ 	if (test_current)
+ 	   fs_give((void **)&test_current);
+ 	test_current = cpystr(ps_global->inbox_name);
+ 	goto find_new_message;
+    }
+ 
      /* BUG: how can this be made smarter so we cache the list? */
      free_folder_list(cntxt);
+     if (test_current)
+       fs_give((void **)&test_current);
      return((*next) ? next : NULL);
  }
  
diff -rc alpine-2.11/alpine/imap.c alpine-2.11.I.USE/alpine/imap.c
*** alpine-2.11/alpine/imap.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/imap.c	2013-12-01 16:38:36.000000000 -0700
***************
*** 2044,2049 ****
--- 2044,2126 ----
  
  #endif	/* PASSFILE */
  
+ void
+ pine_delete_pwd(NETMBX *mb, char *user)
+ {
+     char	hostlist0[MAILTMPLEN], hostlist1[MAILTMPLEN];
+     char	port[20], non_def_port[20], insecure[20];
+     STRLIST_S hostlist[2];
+     MMLOGIN_S  *l;
+     struct servent *sv;
+ 
+ 
+     dprint((9, "pine_delete_pwd\n"));
+ 
+ 				/* do not invalidate password on cancel */
+     if(ps_global->user_says_cancel != 0)
+ 	return;
+ 
+ 	/* setup hostlist */
+     non_def_port[0] = '\0';
+     if(mb->port && mb->service &&
+        (sv = getservbyname(mb->service, "tcp")) &&
+        (mb->port != ntohs(sv->s_port))){
+         snprintf(non_def_port, sizeof(non_def_port), ":%lu", mb->port);
+         non_def_port[sizeof(non_def_port)-1] = '\0';
+         dprint((9, "mm_login: using non-default port=%s\n",
+                    non_def_port ? non_def_port : "?"));
+     }
+ 
+     if(*non_def_port){
+         strncpy(hostlist0, mb->host, sizeof(hostlist0)-1);
+         hostlist0[sizeof(hostlist0)-1] = '\0';
+         strncat(hostlist0, non_def_port, sizeof(hostlist0)-strlen(hostlist0)-1);
+         hostlist0[sizeof(hostlist0)-1] = '\0';
+         hostlist[0].name = hostlist0;
+         if(mb->orighost && mb->orighost[0] && strucmp(mb->host, mb->orighost)){
+             strncpy(hostlist1, mb->orighost, sizeof(hostlist1)-1);
+             hostlist1[sizeof(hostlist1)-1] = '\0';
+             strncat(hostlist1, non_def_port, sizeof(hostlist1)-strlen(hostlist1)-1);
+             hostlist1[sizeof(hostlist1)-1] = '\0';
+             hostlist[0].next = &hostlist[1];
+             hostlist[1].name = hostlist1;
+             hostlist[1].next = NULL;
+         }
+         else
+           hostlist[0].next = NULL;
+     }
+     else{
+         hostlist[0].name = mb->host;
+         if(mb->orighost && mb->orighost[0] && strucmp(mb->host, mb->orighost)){
+             hostlist[0].next = &hostlist[1];
+             hostlist[1].name = mb->orighost;
+             hostlist[1].next = NULL;
+         }
+         else
+           hostlist[0].next = NULL;
+     }
+ 
+     /* delete it from all lists */
+ 
+     for(l = mm_login_list; l; l = l->next)
+       if(imap_same_host(l->hosts, hostlist)
+ 	 && !strcmp(l->user, user ? user : "")
+ 	 && l->passwd){
+ 	    l->invalidpwd = 1;
+ 	    break;
+       }
+ 
+ #ifdef	LOCAL_PASSWD_CACHE
+     for(l = passfile_cache; l; l = l->next)
+       if(imap_same_host(l->hosts, hostlist)
+ 	 && !strcmp(l->user, user ? user : "")
+ 	 && l->passwd){
+ 	    l->invalidpwd = 1;
+ 	    break;
+       }
+     write_passfile(ps_global->pinerc, passfile_cache); /* blast it from passfile */
+ #endif
+ }
  
  #ifdef	LOCAL_PASSWD_CACHE
  
***************
*** 2606,2611 ****
--- 2683,2690 ----
  #endif /* SMIME */
  
      for(n = 0; l; l = l->next, n++){
+ 	if(l->invalidpwd == 1)	/* if password is invalid, do not save it */
+ 	   continue;
  	/*** do any necessary ENcryption here ***/
  	snprintf(tmp, sizeof(tmp), "%s\t%s\t%s\t%d%s%s\n", l->passwd, l->user,
  		l->hosts->name, l->altflag,
diff -rc alpine-2.11/alpine/imap.h alpine-2.11.I.USE/alpine/imap.h
*** alpine-2.11/alpine/imap.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/imap.h	2013-12-01 16:38:36.000000000 -0700
***************
*** 31,37 ****
  int     url_local_certdetails(char *);
  void    pine_sslfailure(char *, char *, unsigned long);
  void	mm_expunged_current(long unsigned int);
! 
  #ifdef	LOCAL_PASSWD_CACHE
  int     get_passfile_passwd(char *, char *, char *, STRLIST_S *, int);
  int     is_using_passfile();
--- 31,38 ----
  int     url_local_certdetails(char *);
  void    pine_sslfailure(char *, char *, unsigned long);
  void	mm_expunged_current(long unsigned int);
! void    pine_delete_pwd(NETMBX *mb, char *user);
!  
  #ifdef	LOCAL_PASSWD_CACHE
  int     get_passfile_passwd(char *, char *, char *, STRLIST_S *, int);
  int     is_using_passfile();
diff -rc alpine-2.11/alpine/keymenu.c alpine-2.11.I.USE/alpine/keymenu.c
*** alpine-2.11/alpine/keymenu.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/keymenu.c	2013-12-01 16:33:57.000000000 -0700
***************
*** 650,659 ****
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	NULL_MENU,
  	/* TRANSLATORS: toggles a collapsed view or an expanded view
  	   of a message thread on and off */
  	{"/",N_("Collapse/Expand"),{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	{"@", N_("Quota"), {MC_QUOTA,1,{'@'}}, KS_NONE},
  	NULL_MENU};
  INST_KEY_MENU(index_keymenu, index_keys);
--- 650,674 ----
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	{"K","Sort Thread",{MC_SORTHREAD,1,{'k'}},KS_NONE},
  	/* TRANSLATORS: toggles a collapsed view or an expanded view
  	   of a message thread on and off */
  	{"/",N_("Collapse/Expand"),{MC_COLLAPSE,1,{'/'}},KS_NONE},
+ 	/* TRANSLATORS: Collapse all threads */
+ 	{"{",N_("Collapse All"),{MC_KOLAPSE,1,{'{'}},KS_NONE},
+ 	/* TRANSLATORS: Expand all threads */
+ 	{"}",N_("Expand All"), {MC_EXPTHREAD,1,{'}'}},KS_NONE},
+ 
+ 	HELP_MENU,
+ 	OTHER_MENU,
+ 	{")","Next Threa",{MC_NEXTHREAD,1,{')'}},KS_NONE},
+ 	{"(","Prev Threa",{MC_PRETHREAD,1,{'('}},KS_NONE},
+ 	{"^R","Remove Thr",{MC_DELTHREAD,1,{ctrl('r')}},KS_NONE},
+ 	{"^U","Undel Thre",{MC_UNDTHREAD,1,{ctrl('u')}},KS_NONE},
+ 	{"^T","Select Thr",{MC_SELTHREAD,1,{ctrl('t')}},KS_NONE},
+ 	NULL_MENU,
+ 	{"[","Close Thre",{MC_CTHREAD,1,{'['}},KS_NONE},
+ 	{"]","Open Threa",{MC_OTHREAD,1,{']'}},KS_NONE},
  	{"@", N_("Quota"), {MC_QUOTA,1,{'@'}}, KS_NONE},
  	NULL_MENU};
  INST_KEY_MENU(index_keymenu, index_keys);
***************
*** 728,736 ****
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	NULL_MENU,
  	{"/",N_("Collapse/Expand"),{MC_COLLAPSE,1,{'/'}},KS_NONE},
  	{"@", N_("Quota"), {MC_QUOTA,1,{'@'}}, KS_NONE},
  	NULL_MENU};
  INST_KEY_MENU(thread_keymenu, thread_keys);
  
--- 743,764 ----
  	RCOMPOSE_MENU,
  	HOMEKEY_MENU,
  	ENDKEY_MENU,
! 	{"]",N_("Open Thread"),{MC_OTHREAD,1,{']'}},KS_NONE},
  	{"/",N_("Collapse/Expand"),{MC_COLLAPSE,1,{'/'}},KS_NONE},
+ 	{")",N_("Next Thread"),{MC_NEXTHREAD,1,{')'}},KS_NONE},    
+ 	{"(",N_("Prev Thread"),{MC_PRETHREAD,1,{'('}},KS_NONE},  
+ 
+ 	HELP_MENU,
+ 	OTHER_MENU,
  	{"@", N_("Quota"), {MC_QUOTA,1,{'@'}}, KS_NONE},
+ 	NULL_MENU, 
+ 	{"^R",N_("Remove Thread"),{MC_DELTHREAD,1,{ctrl('r')}},KS_NONE},
+ 	{"^U",N_("Undelete Thread"),{MC_UNDTHREAD,1,{ctrl('u')}},KS_NONE},
+ 	{"^T",N_("SelecT Thread"),{MC_SELTHREAD,1,{ctrl('t')}},KS_NONE},
+ 	NULL_MENU,
+ 	NULL_MENU,
+ 	NULL_MENU, 
+ 	{"K","Sort Thread",{MC_SORTHREAD,1,{'k'}},KS_NONE},  
  	NULL_MENU};
  INST_KEY_MENU(thread_keymenu, thread_keys);
  
***************
*** 880,886 ****
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
! 	NULL_MENU};
  INST_KEY_MENU(view_keymenu, view_keys);
  
  
--- 908,927 ----
  	NULL_MENU,
  	NULL_MENU,
  	NULL_MENU,
! 	NULL_MENU,
! 
! 	HELP_MENU,
! 	OTHER_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	NULL_MENU,
! 	{"(",N_("Prev Thread"),{MC_PRETHREAD,1,{'('}},KS_NONE},
! 	{")",N_("Next Thread"),{MC_NEXTHREAD,1,{')'}},KS_NONE},
! 	{"^R",N_("Remove Thread"),{MC_DELTHREAD,1,{ctrl('r')}},KS_NONE},
! 	{"^U",N_("Undelete Thread"),{MC_UNDTHREAD,1,{ctrl('u')}},KS_NONE},
! 	{"^T",N_("selecT Thread"),{MC_SELTHREAD,1,{ctrl('t')}},KS_NONE}};
  INST_KEY_MENU(view_keymenu, view_keys);
  
  
diff -rc alpine-2.11/alpine/keymenu.h alpine-2.11.I.USE/alpine/keymenu.h
*** alpine-2.11/alpine/keymenu.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/keymenu.h	2013-12-01 16:33:57.000000000 -0700
***************
*** 215,220 ****
--- 215,233 ----
  #define	MC_DECRYPT	802
  #define MC_QUOTA	803
  #define MC_ADDHEADER	804
+ #define MC_DELTHREAD	805
+ #define MC_UNDTHREAD	806
+ #define MC_SELTHREAD	807
+ #define MC_SSUTHREAD	808
+ #define MC_DSUTHREAD	809
+ #define MC_USUTHREAD	810
+ #define MC_SORTHREAD	811
+ #define MC_NEXTHREAD	812
+ #define MC_KOLAPSE	813
+ #define MC_EXPTHREAD	814
+ #define MC_PRETHREAD	815
+ #define MC_CTHREAD	816
+ #define MC_OTHREAD	817
  
  /*
   * Some standard Key/Command Bindings 
diff -rc alpine-2.11/alpine/mailcmd.c alpine-2.11.I.USE/alpine/mailcmd.c
*** alpine-2.11/alpine/mailcmd.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/mailcmd.c	2013-12-01 16:40:17.000000000 -0700
***************
*** 73,78 ****
--- 73,79 ----
  #include "../pith/tempfile.h"
  #include "../pith/search.h"
  #include "../pith/margin.h"
+ #include "../pith/rules.h"
  #ifdef _WINDOWS
  #include "../pico/osdep/mswin.h"
  #endif
***************
*** 113,119 ****
  char     *choose_a_rule(int);
  int	  select_by_keyword(MAILSTREAM *, SEARCHSET **);
  char     *choose_a_keyword(void);
! int	  select_sort(struct pine *, int, SortOrder *, int *);
  int       print_index(struct pine *, MSGNO_S *, int);
  
  
--- 114,120 ----
  char     *choose_a_rule(int);
  int	  select_by_keyword(MAILSTREAM *, SEARCHSET **);
  char     *choose_a_keyword(void);
! int	  select_sort(struct pine *, int, SortOrder *, int *, int);
  int       print_index(struct pine *, MSGNO_S *, int);
  
  
***************
*** 974,980 ****
  				     state->context_current, &recent_cnt,
  				     F_ON(F_TAB_NO_CONFIRM,state)
  				       ? NULL : &did_cancel))){
! 			if(!in_inbox){
  			    static ESCKEY_S inbox_opt[] = {
  				{'y', 'y', "Y", N_("Yes")},
  				{'n', 'n', "N", N_("No")},
--- 975,981 ----
  				     state->context_current, &recent_cnt,
  				     F_ON(F_TAB_NO_CONFIRM,state)
  				       ? NULL : &did_cancel))){
! 			if(!in_inbox && F_OFF(F_AUTO_CIRCULAR_TAB,state)){
  			    static ESCKEY_S inbox_opt[] = {
  				{'y', 'y', "Y", N_("Yes")},
  				{'n', 'n', "N", N_("No")},
***************
*** 1335,1341 ****
  	if(any_messages(msgmap, NULL, NULL)){
  	    if(any_lflagged(msgmap, MN_SLCT) > 0L){
  		if(apply_command(state, stream, msgmap, 0,
! 				 AC_NONE, question_line)){
  		    if(F_ON(F_AUTO_UNSELECT, state)){
  			agg_select_all(stream, msgmap, NULL, 0);
  			unzoom_index(state, stream, msgmap);
--- 1336,1342 ----
  	if(any_messages(msgmap, NULL, NULL)){
  	    if(any_lflagged(msgmap, MN_SLCT) > 0L){
  		if(apply_command(state, stream, msgmap, 0,
! 				 AC_NONE, question_line, 1)){
  		    if(F_ON(F_AUTO_UNSELECT, state)){
  			agg_select_all(stream, msgmap, NULL, 0);
  			unzoom_index(state, stream, msgmap);
***************
*** 1353,1375 ****
  
            /*-------- Sort command -------*/
        case MC_SORT :
  	{
  	    int were_threading = THREADING();
  	    SortOrder sort = mn_get_sort(msgmap);
  	    int	      rev  = mn_get_revsort(msgmap);
  
  	    dprint((1,"MAIL_CMD: sort\n"));		    
! 	    if(select_sort(state, question_line, &sort, &rev)){
  		/* $ command reinitializes threading collapsed/expanded info */
  		if(SORT_IS_THREADED(msgmap) && !SEP_THRDINDX())
  		  erase_threading_info(stream, msgmap);
  
  		if(ps_global && ps_global->ttyo){
  		    blank_keymenu(ps_global->ttyo->screen_rows - 2, 0);
  		    ps_global->mangled_footer = 1;
  		}
  
! 		sort_folder(stream, msgmap, sort, rev, SRT_VRB|SRT_MAN);
  	    }
  
  	    state->mangled_footer = 1;
--- 1354,1388 ----
  
            /*-------- Sort command -------*/
        case MC_SORT :
+       case MC_SORTHREAD:
  	{
  	    int were_threading = THREADING();
  	    SortOrder sort = mn_get_sort(msgmap);
  	    int	      rev  = mn_get_revsort(msgmap);
+ 	    int	      thread = (command == MC_SORT) ? 0 : 1;
  
  	    dprint((1,"MAIL_CMD: sort\n"));		    
! 	    if(sort == SortThread)
! 		sort = ps_global->thread_cur_sort;
! 	    if(select_sort(state, question_line, &sort, &rev, thread)){
  		/* $ command reinitializes threading collapsed/expanded info */
  		if(SORT_IS_THREADED(msgmap) && !SEP_THRDINDX())
  		  erase_threading_info(stream, msgmap);
  
+ 		if(command == MC_SORTHREAD){
+ 		  ps_global->thread_cur_sort = sort;
+ 		  sort = SortThread;
+ 		}
+ 		else if(sort == SortThread)	/* command = MC_SORT */
+ 		  ps_global->thread_cur_sort = F_ON(F_THREAD_SORTS_BY_ARRIVAL, ps_global)
+ 						? SortArrival : ps_global->thread_def_sort;
+ 
  		if(ps_global && ps_global->ttyo){
  		    blank_keymenu(ps_global->ttyo->screen_rows - 2, 0);
  		    ps_global->mangled_footer = 1;
  		}
  
! 		sort_folder(stream, msgmap, sort, rev, SRT_VRB|SRT_MAN, 1);
  	    }
  
  	    state->mangled_footer = 1;
***************
*** 2594,2599 ****
--- 2607,2615 ----
  		role->nick = cpystr("Default Role");
  	    }
  
+ 	    if(state->role)
+ 	      fs_give((void **)&state->role);
+ 	    state->role = cpystr(role->nick); /* remember the role */
  	    state->redrawer = NULL;
  	    switch(action){
  	      case 'c':
***************
*** 2644,2655 ****
  	    char *nmsgs, ENVELOPE *env, long int rawmsgno, char *section,
  	    SaveDel *dela, SavePreserveOrder *prea)
  {
!     int		      rc, ku = -1, n, flags, last_rc = 0, saveable_count = 0, done = 0;
      int		      delindex, preindex, r;
      char	      prompt[6*MAX_SCREEN_COLS+1], *p, expanded[MAILTMPLEN];
      char              *buf = tmp_20k_buf;
      char              shortbuf[200];
!     char              *folder;
      HelpType	      help;
      SaveDel           del = DontAsk;
      SavePreserveOrder pre = DontAskPreserve;
--- 2660,2671 ----
  	    char *nmsgs, ENVELOPE *env, long int rawmsgno, char *section,
  	    SaveDel *dela, SavePreserveOrder *prea)
  {
!     int		      rc, ku = -1, n = 0, flags, last_rc = 0, saveable_count = 0, done = 0;
      int		      delindex, preindex, r;
      char	      prompt[6*MAX_SCREEN_COLS+1], *p, expanded[MAILTMPLEN];
      char              *buf = tmp_20k_buf;
      char              shortbuf[200];
!     char              *folder, folder2[MAXPATH];
      HelpType	      help;
      SaveDel           del = DontAsk;
      SavePreserveOrder pre = DontAskPreserve;
***************
*** 2657,2662 ****
--- 2673,2679 ----
      static HISTORY_S *history = NULL;
      CONTEXT_S	     *tc;
      ESCKEY_S	      ekey[10];
+     RULE_RESULT	     *rule;
  
      if(!cntxt)
        panic("no context ptr in save_prompt");
***************
*** 2666,2671 ****
--- 2683,2697 ----
      if(!(folder = save_get_default(state, env, rawmsgno, section, cntxt)))
        return(0);		/* message expunged! */
  
+     if (rule = get_result_rule(V_SAVE_RULES, FOR_SAVE, env)){
+        strncpy(folder2,rule->result,sizeof(folder2)-1);
+        folder2[sizeof(folder2)-1] = '\0';
+        folder = folder2;
+        if (rule->result)
+ 	   fs_give((void **)&rule->result);
+        fs_give((void **)&rule);
+     }
+ 
      /* how many context's can be saved to... */
      for(tc = state->context_list; tc; tc = tc->next)
        if(!NEWS_TEST(tc))
***************
*** 3174,3179 ****
--- 3200,3209 ----
  		if(SORT_IS_THREADED(msgmap))
  		  refresh_sort(stream, msgmap, SRT_NON);
  
+ 		if (msgmap->nmsgs
+ 			&& F_ON(F_ENHANCED_THREAD, state) && COLL_THRDS())
+ 			kolapse_thread(state, stream, msgmap, '[', 0);
+ 
  		state->mangled_body = 1;
  		state->mangled_header = 1;
  		q_status_message2(SM_ORDER, 0, 4,
***************
*** 3268,3273 ****
--- 3298,3306 ----
  	 */
  	if(SORT_IS_THREADED(msgmap))
  	  refresh_sort(stream, msgmap, SRT_NON);
+ 	if (msgmap->nmsgs
+ 		&& F_ON(F_ENHANCED_THREAD, state) && COLL_THRDS())
+ 		kolapse_thread(state, stream, msgmap, '[', 0);
      }
      else{
  	if(del_count)
***************
*** 3349,3354 ****
--- 3382,3390 ----
  	{-1, 0, NULL, NULL}
      };
  
+     if(F_ON(F_IGNORE_SIZE, ps_global))
+       return 'y';
+ 
      if(flags & SSCP_INIT || flags & SSCP_END){
  	if(flags & SSCP_END && possible_corruption)
  	  q_status_message(SM_ORDER, 3, 3, "There is possible data corruption, check the results");
***************
*** 6945,6951 ****
  	 * Maybe it makes sense to zoom after a select but not after a colon
  	 * command even though they are very similar.
  	 */
! 	thread_command(state, state->mail_stream, msgmap, ':', -FOOTER_ROWS(state));
      }
      else{
  	if((all_selected =
--- 6981,6987 ----
  	 * Maybe it makes sense to zoom after a select but not after a colon
  	 * command even though they are very similar.
  	 */
! 	thread_command(state, state->mail_stream, msgmap, ':', -FOOTER_ROWS(state), 1);
      }
      else{
  	if((all_selected =
***************
*** 7001,7007 ****
    ----*/
  int
  apply_command(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap,
! 	      UCS preloadkeystroke, int flags, int q_line)
  {
      int i = 8,			/* number of static entries in sel_opts3 */
          rv = 0,
--- 7037,7043 ----
    ----*/
  int
  apply_command(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap,
! 	      UCS preloadkeystroke, int flags, int q_line, int display)
  {
      int i = 8,			/* number of static entries in sel_opts3 */
          rv = 0,
***************
*** 7153,7161 ****
  	collapse_or_expand(state, stream, msgmap,
  			   F_ON(F_SLASH_COLL_ENTIRE, ps_global)
  			     ? 0L
! 			     : mn_get_cur(msgmap));
  	break;
  
        case ':' :
  	select_thread_stmp(state, stream, msgmap);
  	break;
--- 7189,7207 ----
  	collapse_or_expand(state, stream, msgmap,
  			   F_ON(F_SLASH_COLL_ENTIRE, ps_global)
  			     ? 0L
! 			     : mn_get_cur(msgmap),
! 			   display);
  	break;
  
+       case '[' :
+ 	collapse_this_thread(state, stream, msgmap, display, 0);
+       break;
+ 
+       case ']' :
+ 	expand_this_thread(state, stream, msgmap, display, 0);
+       break;
+ 
+ 
        case ':' :
  	select_thread_stmp(state, stream, msgmap);
  	break;
***************
*** 7189,7195 ****
  int
  select_by_number(MAILSTREAM *stream, MSGNO_S *msgmap, SEARCHSET **limitsrch)
  {
!     int r, end;
      long n1, n2, raw;
      char number1[16], number2[16], numbers[80], *p, *t;
      HelpType help;
--- 7235,7241 ----
  int
  select_by_number(MAILSTREAM *stream, MSGNO_S *msgmap, SEARCHSET **limitsrch)
  {
!     int r, end, cur;
      long n1, n2, raw;
      char number1[16], number2[16], numbers[80], *p, *t;
      HelpType help;
***************
*** 7236,7242 ****
  
  	*t = '\0';
  
! 	end = 0;
  	if(number1[0] == '\0'){
  	    if(*p == '-'){
  		q_status_message1(SM_ORDER | SM_DING, 0, 2,
--- 7282,7288 ----
  
  	*t = '\0';
  
! 	end = cur = 0;
  	if(number1[0] == '\0'){
  	    if(*p == '-'){
  		q_status_message1(SM_ORDER | SM_DING, 0, 2,
***************
*** 7248,7253 ****
--- 7294,7307 ----
  		end = 1;
  		p += strlen("end");
  	    }
+ 	    else if(!strucmp(p, "$")){
+ 		end = 1;
+ 		p++;
+ 	    }
+ 	    else if(!struncmp(p, ".",1)){
+ 		cur = 1;
+ 		p++;
+ 	    }
  	    else{
  		q_status_message1(SM_ORDER | SM_DING, 0, 2,
  			        _("Invalid message number: %s"), numbers);
***************
*** 7257,7262 ****
--- 7311,7318 ----
  
  	if(end)
  	  n1 = mn_get_total(msgmap);
+ 	else if(cur)
+ 	  n1 = mn_get_cur(msgmap);
  	else if((n1 = atol(number1)) < 1L || n1 > mn_get_total(msgmap)){
  	    q_status_message1(SM_ORDER | SM_DING, 0, 2,
  			      _("\"%s\" out of message number range"),
***************
*** 7271,7282 ****
  
  	    *t = '\0';
  
! 	    end = 0;
  	    if(number2[0] == '\0'){
  		if(!strucmp("end", p)){
  		    end = 1;
  		    p += strlen("end");
  		}
  		else{
  		    q_status_message1(SM_ORDER | SM_DING, 0, 2,
  		 _("Invalid number range, missing number after \"-\": %s"),
--- 7327,7346 ----
  
  	    *t = '\0';
  
! 	    end = cur = 0;
  	    if(number2[0] == '\0'){
  		if(!strucmp("end", p)){
  		    end = 1;
  		    p += strlen("end");
  		}
+ 		else if(!strucmp(p, "$")){
+ 		   end = 1;
+ 		   p++;
+ 		}
+ 		else if(!struncmp(p, ".",1)){
+ 		   cur = 1;
+ 		   p++;
+ 		}
  		else{
  		    q_status_message1(SM_ORDER | SM_DING, 0, 2,
  		 _("Invalid number range, missing number after \"-\": %s"),
***************
*** 7287,7292 ****
--- 7351,7358 ----
  
  	    if(end)
  	      n2 = mn_get_total(msgmap);
+ 	    else if(cur)
+ 	      n2 = mn_get_cur(msgmap);
  	    else if((n2 = atol(number2)) < 1L || n2 > mn_get_total(msgmap)){
  		q_status_message1(SM_ORDER | SM_DING, 0, 2,
  				  _("\"%s\" out of message number range"),
***************
*** 9014,9023 ****
        Returns 0 if it was cancelled, 1 otherwise.
    ----*/
  int
! select_sort(struct pine *state, int ql, SortOrder *sort, int *rev)
  {
      char      prompt[200], tmp[3], *p;
!     int       s, i;
      int       deefault = 'a', retval = 1;
      HelpType  help;
      ESCKEY_S  sorts[14];
--- 9080,9089 ----
        Returns 0 if it was cancelled, 1 otherwise.
    ----*/
  int
! select_sort(struct pine *state, int ql, SortOrder *sort, int *rev, int thread)
  {
      char      prompt[200], tmp[3], *p;
!     int       s, i, j;
      int       deefault = 'a', retval = 1;
      HelpType  help;
      ESCKEY_S  sorts[14];
***************
*** 9050,9066 ****
        strncpy(prompt, _("Choose type of sort, or 'R' to reverse current sort : "),
  	      sizeof(prompt));
  
!     for(i = 0; state->sort_types[i] != EndofList; i++) {
! 	sorts[i].rval	   = i;
! 	p = sorts[i].label = sort_name(state->sort_types[i]);
! 	while(*(p+1) && islower((unsigned char)*p))
! 	  p++;
! 
! 	sorts[i].ch   = tolower((unsigned char)(tmp[0] = *p));
! 	sorts[i].name = cpystr(tmp);
! 
!         if(mn_get_sort(state->msgmap) == state->sort_types[i])
! 	  deefault = sorts[i].rval;
      }
  
      sorts[i].ch     = 'r';
--- 9116,9141 ----
        strncpy(prompt, _("Choose type of sort, or 'R' to reverse current sort : "),
  	      sizeof(prompt));
  
!     for(i = 0, j = 0; state->sort_types[i] != EndofList; i++) {
!        sorts[i].rval = i;
!        sorts[i].name = cpystr("");
!        sorts[i].label = "";
!        sorts[i].ch    = -2;
!        if (!thread || allowed_thread_key(state->sort_types[i])){
!           p = sorts[j].label = sort_name(state->sort_types[i]);
!           while(*(p+1) && islower((unsigned char)*p))
!             p++;
!           sorts[j].ch   = tolower((unsigned char)(tmp[0] = *p));
!           sorts[j++].name = cpystr(tmp);
!        }
! 
!        if (thread){
!           if (state->thread_def_sort == state->sort_types[i])
!               deefault = sorts[j-1].rval;
!        }
!        else
!            if(mn_get_sort(state->msgmap) == state->sort_types[i])
!              deefault = sorts[i].rval;
      }
  
      sorts[i].ch     = 'r';
***************
*** 9084,9091 ****
  	state->mangled_body = 1;		/* signal screen's changed */
  	if(s == 'r')
  	  *rev = !mn_get_revsort(state->msgmap);
! 	else
  	  *sort = state->sort_types[s];
  
  	if(F_ON(F_SHOW_SORT, ps_global))
  	  ps_global->mangled_header = 1;
--- 9159,9175 ----
  	state->mangled_body = 1;		/* signal screen's changed */
  	if(s == 'r')
  	  *rev = !mn_get_revsort(state->msgmap);
! 	else{
! 	  if(thread){
! 	    for(i = 0; state->sort_types[i] != EndofList; i++){
! 	      if(struncmp(sort_name(state->sort_types[i]),
!                   sorts[s].label, strlen(sorts[s].label)) == 0)
!         	break;
! 	    }
! 	    s = i;
! 	  }
  	  *sort = state->sort_types[s];
+ 	}
  
  	if(F_ON(F_SHOW_SORT, ps_global))
  	  ps_global->mangled_header = 1;
***************
*** 9470,9472 ****
--- 9554,9931 ----
  }
  
  #endif	/* _WINDOWS */
+ 
+ void
+ cmd_delete_this_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     unsigned long rawno, top, save_kolapsed;
+     PINETHRD_S   *thrd = NULL, *nxthrd;
+ 
+     if(!stream)
+       return;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_this_thread(stream, msgmap, rawno);
+     top =  mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     save_kolapsed = this_thread_is_kolapsed(state, stream, msgmap, top);
+     collapse_this_thread(state, stream, msgmap, 0, 0);
+     thread_command(state, stream, msgmap, 'd', -FOOTER_ROWS(state), 1);
+     if (!save_kolapsed)
+        expand_this_thread(state, stream, msgmap, 0, 0);
+ }
+ 
+ void
+ cmd_delete_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     unsigned long rawno, top, orig_top, topnxt, save_kolapsed;
+     PINETHRD_S   *thrd = NULL, *nxthrd;
+     int done = 0, count;
+ 
+     if(!stream)
+       return;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap, rawno);
+     top =  orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     while (!done){
+       cmd_delete_this_thread(state, stream, msgmap);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+          || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+          || (orig_top != top_thread(stream, top)))
+          done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, rawno));
+     cmd_delete(state, msgmap, MCMD_NONE, cmd_delete_index);
+     count = count_thread(state, stream, msgmap, rawno);
+     q_status_message2(SM_ORDER, 0, 1, "%s message%s marked deleted",
+                 int2string(count), plural(count));
+ }
+ 
+ int
+ collapse_this_thread(state, stream, msgmap, display, special)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int          display;
+     int		 special;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL, *nthrd;
+     unsigned long rawno, orig, msgno;
+ 
+     if(!stream)
+       return 0;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(rawno)
+        thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+        return rv;
+ 
+     collapsed = this_thread_is_kolapsed(state, stream, msgmap, rawno);
+ 
+     if (special && collapsed){
+ 	expand_this_thread(state, stream, msgmap, 0, 0);
+ 	collapsed = 0;
+     }
+ 
+     clear_index_cache_ent(stream, rawno, 0);
+ 
+     if (!collapsed && thrd->next){
+        if (thrd->rawno == top_thread(stream, thrd->rawno))
+          collapse_or_expand(state, stream, msgmap, mn_get_cur(msgmap), display);
+        else{
+ 	 set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno), MN_COLL, 1);
+ 	 set_thread_subtree(stream, thrd, msgmap, 1, MN_CHID);
+        }
+     }
+     else{
+        if (!collapsed && special 
+ 	   && ((F_OFF(F_ENHANCED_THREAD, state) && !thrd->next) 
+ 	        || F_ON(F_ENHANCED_THREAD, state))){
+ 	  if (thrd->toploose){
+ 	    if (thrd->rawno != thrd->toploose)
+ 	       set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno),MN_CHID, 
+ 									     1);
+ 	    else
+ 	       set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno),MN_COLL,
+ 									     1);
+ 	  }
+        }
+        else{
+          rv = 0; 
+          if (display)
+             q_status_message(SM_ORDER, 0, 1, "Thread already collapsed");
+        }
+     }
+     return rv;
+ }
+ 
+ void
+ collapse_thread(state, stream, msgmap, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int          display;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long orig, orig_top, top;
+ 
+     if(!stream)
+       return;
+ 
+     expand_this_thread(state, stream, msgmap, display, 1);
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap,orig);
+     top = orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     while (!done){
+       collapse_this_thread(state, stream, msgmap, display, 1);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, orig_top));
+ }
+ 
+ int
+ expand_this_thread(state, stream, msgmap, display, special)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int          display;
+     int		 special;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL, *nthrd;
+     unsigned long rawno, orig, msgno;
+ 
+     if(!stream)
+       return 0;
+ 
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_this_thread(stream, msgmap,orig);
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(rawno)
+        thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+        return rv;
+ 
+     collapsed = this_thread_is_kolapsed(state, stream, msgmap, rawno);
+ 
+     if (special && !collapsed){
+ 	collapse_this_thread(state, stream, msgmap, 0, 0);
+ 	collapsed = 1;
+     }
+ 
+     clear_index_cache_ent(stream, rawno, 0);
+ 
+      if (collapsed && thrd->next){
+        if (thrd->rawno == top_thread(stream, thrd->rawno))
+          collapse_or_expand(state, stream, msgmap, mn_get_cur(msgmap), display);
+        else{
+         set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno), MN_COLL, 0);
+ 	 set_thread_subtree(stream, thrd, msgmap, 0, MN_CHID);
+        }
+      }
+      else{
+        if (collapsed && special 
+ 	&& ((F_OFF(F_ENHANCED_THREAD, state) && !thrd->next) 
+ 	   || F_ON(F_ENHANCED_THREAD, state))){ 
+ 	  if (thrd->toploose)
+ 	    if (thrd->rawno != thrd->toploose)
+ 	       set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno),MN_CHID, 0);
+ 	    else
+ 	       set_lflag(stream, msgmap, mn_raw2m(msgmap,thrd->rawno),MN_COLL, 0);
+        }
+        else{
+          rv = 0; 
+          if (display)
+             q_status_message(SM_ORDER, 0, 1, "Thread already expanded");
+        }
+      }
+     return rv;
+ }
+ 
+ void
+ expand_thread(state, stream, msgmap, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     int          display;
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long orig, orig_top, top;
+ 
+     if(!stream)
+       return;
+ 
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     top = orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     while (!done){
+       expand_this_thread(state, stream, msgmap, display, 1);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, orig_top));
+ }
+ 
+ 
+ void
+ cmd_undelete_this_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     unsigned long rawno;
+     int save_kolapsed;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     save_kolapsed = this_thread_is_kolapsed(state, stream, msgmap, rawno);
+     collapse_this_thread(state, stream, msgmap, 0, 0);
+     thread_command(state, stream, msgmap, 'u', -FOOTER_ROWS(state), 1);
+     if (!save_kolapsed)
+        expand_this_thread(state, stream, msgmap, 0, 0);
+ }
+ 
+ void
+ cmd_undelete_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno, top, orig_top;
+     int done = 0, count;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap, rawno);
+     top =  orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return;
+ 
+     while (!done){
+       cmd_undelete_this_thread(state, stream, msgmap);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, rawno));
+     count = count_thread(state, stream, msgmap, rawno);
+     q_status_message2(SM_ORDER, 0, 1, "Deletion mark removed from %s message%s",
+ 		int2string(count), plural(count));
+ }
+ 
+ void
+ kolapse_thread(state, stream, msgmap, ch, display)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+     char      ch;
+     int		display;
+ {
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno;
+     int       rv = 1, done = 0;
+ 
+     if(!stream)
+       return;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return;
+ 
+     clear_index_cache(stream, 0);
+     mn_set_cur(msgmap,1); /* go to the first message */
+     while (!done){
+       if (ch == '[')
+ 	collapse_thread(state, stream, msgmap, display);
+       else
+ 	expand_thread(state, stream, msgmap, display);
+       if ((rv = move_next_thread(state, stream, msgmap, 0)) <= 0)
+          done++;
+     }
+ 
+     if (rv < 0){
+       if (display)
+       q_status_message(SM_ORDER, 0, 1, (ch == '[')
+                ? "Error while collapsing thread"
+                : "Error while expanding thread");
+     }
+     else
+       if(display)
+       q_status_message(SM_ORDER, 0, 1, (ch == '[')
+                ? "All threads collapsed. Use \"}\" to expand them"
+                : "All threads expanded. Use \"{\" to collapse them");
+ 
+     mn_set_cur(msgmap,mn_raw2m(msgmap, top_thread(stream,rawno)));
+ }
+ 
+ void
+ cmd_select_thread(state, stream, msgmap)
+     struct pine *state;
+     MAILSTREAM  *stream;
+     MSGNO_S     *msgmap;
+ {
+     unsigned long rawno;
+     int save_kolapsed;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     save_kolapsed = thread_is_kolapsed(state, stream, msgmap, rawno);
+     collapse_thread(state, stream, msgmap, 0);
+     thread_command(state, stream, msgmap, ':', -FOOTER_ROWS(state), 1);
+     if (!save_kolapsed)
+        expand_thread(state, stream, msgmap, 0);
+ }
+ 
diff -rc alpine-2.11/alpine/mailcmd.h alpine-2.11.I.USE/alpine/mailcmd.h
*** alpine-2.11/alpine/mailcmd.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/mailcmd.h	2013-12-01 16:33:57.000000000 -0700
***************
*** 84,90 ****
  int	    ask_mailbox_reopen(struct pine *, int *);
  void	    visit_folder(struct pine *, char *, CONTEXT_S *, MAILSTREAM *, unsigned long);
  int	    select_by_current(struct pine *, MSGNO_S *, CmdWhere);
! int	    apply_command(struct pine *, MAILSTREAM *, MSGNO_S *, UCS, int, int);
  char      **choose_list_of_keywords(void);
  char       *choose_a_charset(int);
  char      **choose_list_of_charsets(void);
--- 84,90 ----
  int	    ask_mailbox_reopen(struct pine *, int *);
  void	    visit_folder(struct pine *, char *, CONTEXT_S *, MAILSTREAM *, unsigned long);
  int	    select_by_current(struct pine *, MSGNO_S *, CmdWhere);
! int	    apply_command(struct pine *, MAILSTREAM *, MSGNO_S *, UCS, int, int, int);
  char      **choose_list_of_keywords(void);
  char       *choose_a_charset(int);
  char      **choose_list_of_charsets(void);
***************
*** 102,107 ****
  int	    flag_callback(int, long);
  MPopup	   *flag_submenu(MESSAGECACHE *);
  #endif
! 
  
  #endif /* PINE_MAILCMD_INCLUDED */
--- 102,116 ----
  int	    flag_callback(int, long);
  MPopup	   *flag_submenu(MESSAGECACHE *);
  #endif
! void          cmd_delete_thread(struct pine *, MAILSTREAM *, MSGNO_S *);
! void          cmd_delete_this_thread(struct pine *, MAILSTREAM *, MSGNO_S *);
! void          cmd_undelete_this_thread(struct pine *, MAILSTREAM *, MSGNO_S *);
! void          cmd_undelete_thread(struct pine *, MAILSTREAM *, MSGNO_S *);
! void          cmd_select_thread(struct pine *, MAILSTREAM *, MSGNO_S *);
! void          kolapse_thread(struct pine *, MAILSTREAM *, MSGNO_S *, char, int);
! void          collapse_thread(struct pine *, MAILSTREAM *, MSGNO_S *, int);
! void          expand_thread(struct pine *, MAILSTREAM *, MSGNO_S *, int);
! int           collapse_this_thread(struct pine *, MAILSTREAM *, MSGNO_S *, int, int);
! int           expand_this_thread(struct pine *, MAILSTREAM *, MSGNO_S *, int, int);
  
  #endif /* PINE_MAILCMD_INCLUDED */
diff -rc alpine-2.11/alpine/mailindx.c alpine-2.11.I.USE/alpine/mailindx.c
*** alpine-2.11/alpine/mailindx.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/mailindx.c	2013-12-01 16:34:44.000000000 -0700
***************
*** 229,234 ****
--- 229,236 ----
      state->prev_screen = mail_index_screen;
      state->next_screen = SCREEN_FUN_NULL;
  
+     setup_threading_display_style();
+ 
      if(THRD_AUTO_VIEW()
         && sp_viewing_a_thread(state->mail_stream)
         && state->view_skipped_index
***************
*** 240,249 ****
--- 242,255 ----
  
      adjust_cur_to_visible(state->mail_stream, state->msgmap);
  
+     strcpy(state->screen_name,"index");
+ 
      if(THRD_INDX())
        thread_index_screen(state);
      else
        index_index_screen(state);
+ 
+     strcpy(state->screen_name,"unknown");
  }
  
  
***************
*** 561,566 ****
--- 567,573 ----
  
              /*---------- Scroll line up ----------*/
  	  case MC_CHARUP :
+ previtem:
  	    (void) process_cmd(state, stream, msgmap, MC_PREVITEM,
  			       (style == MsgIndex
  				|| style == MultiMsgIndex
***************
*** 578,583 ****
--- 585,591 ----
  
              /*---------- Scroll line down ----------*/
  	  case MC_CHARDOWN :
+ nextitem:
  	    /*
  	     * Special Page framing handling here.  If we
  	     * did something that should scroll-by-a-line, frame
***************
*** 795,800 ****
--- 803,809 ----
  
  
  	  case MC_THRDINDX :
+ mc_thrdindx:
  	    msgmap->top = msgmap->top_after_thrd;
  	    if(unview_thread(state, stream, msgmap)){
  		state->next_screen = mail_index_screen;
***************
*** 845,851 ****
  			      && mp.col == id.plus_col
  			      && style != ThreadIndex){
  			      collapse_or_expand(state, stream, msgmap,
! 						 mn_get_cur(msgmap));
  			  }
  			  else if (mp.doubleclick){
  			      if(mp.button == M_BUTTON_LEFT){
--- 854,860 ----
  			      && mp.col == id.plus_col
  			      && style != ThreadIndex){
  			      collapse_or_expand(state, stream, msgmap,
! 						 mn_get_cur(msgmap), 1);
  			  }
  			  else if (mp.doubleclick){
  			      if(mp.button == M_BUTTON_LEFT){
***************
*** 954,962 ****
  
  
  	  case MC_COLLAPSE :
! 	    thread_command(state, stream, msgmap, ch, -FOOTER_ROWS(state));
  	    break;
  
            case MC_DELETE :
            case MC_UNDELETE :
            case MC_REPLY :
--- 963,1067 ----
  
  
  	  case MC_COLLAPSE :
! 	    thread_command(state, stream, msgmap, ch, -FOOTER_ROWS(state), 1);
  	    break;
  
+ 	  case MC_CTHREAD  :
+ 	     if (SEP_THRDINDX())
+ 	        goto mc_thrdindx;
+ 	   else
+ 	     if (THREADING()){
+ 	        if (any_messages(ps_global->msgmap, NULL,
+ 							"to collapse a thread"))
+ 		   collapse_thread(state, stream,msgmap, 1);
+ 	     }
+ 	     else
+ 		q_status_message(SM_ORDER, 0, 1,
+ 		  "Command available in threaded mode only");
+ 	  break;
+ 
+ 	  case MC_OTHREAD  :
+ 	     if (SEP_THRDINDX())
+ 		goto view_a_thread;
+ 	  else
+ 	     if (THREADING()){
+ 		if (any_messages(ps_global->msgmap, NULL, "to expand a thread"))
+ 		   expand_thread(state, stream,msgmap, 1);
+ 	     }
+ 	     else
+ 		q_status_message(SM_ORDER, 0, 1,
+ 				"Command available in threaded mode only");
+ 	     break;
+ 
+ 	    case MC_NEXTHREAD:
+ 	    case MC_PRETHREAD:
+ 	     if (THRD_INDX()){
+ 		if (cmd == MC_NEXTHREAD)
+ 		   goto nextitem;
+ 		else
+ 		   goto previtem;
+ 	     }
+ 	     else
+ 		if (THREADING()){
+ 		   if (any_messages(ps_global->msgmap, NULL,
+ 						"to move to other thread"))
+ 		      move_thread(state, stream, msgmap,
+ 						cmd == MC_NEXTHREAD ? 1 : -1);
+ 		}
+ 		else
+ 		   q_status_message(SM_ORDER, 0, 1,
+ 			"Command available in threaded mode only");
+ 	     break;
+ 
+           case MC_KOLAPSE:
+           case MC_EXPTHREAD:
+               if (SEP_THRDINDX()){
+                       q_status_message(SM_ORDER, 0, 1,
+                               "Command not available in this screen");
+               }
+               else{
+               if (THREADING()){
+                  if (any_messages(ps_global->msgmap, NULL,
+                            cmd == MC_KOLAPSE ? "to collapse" : "to expand"))
+                     kolapse_thread(state, stream, msgmap,
+                               (cmd == MC_KOLAPSE) ? '[' : ']', 1);
+               }
+               else
+                   q_status_message(SM_ORDER, 0, 1,
+                        "Command available in threaded mode only");
+             }
+           break;
+ 
+         case MC_DELTHREAD:
+            if (THREADING()){
+               if (any_messages(ps_global->msgmap, NULL, "to delete"))
+                     cmd_delete_thread(state, stream, msgmap);
+            }
+            else
+               q_status_message(SM_ORDER, 0, 1,
+                        "Command available in threaded mode only");
+           break;
+ 
+         case MC_UNDTHREAD:
+            if (THREADING()){
+               if (any_messages(ps_global->msgmap, NULL, "to undelete"))
+                   cmd_undelete_thread(state, stream, msgmap);
+            }
+            else
+               q_status_message(SM_ORDER, 0, 1,
+                        "Command available in threaded mode only");
+         break;
+ 
+         case MC_SELTHREAD:
+            if (THREADING()){
+               if (any_messages(ps_global->msgmap, NULL, "to undelete"))
+                   cmd_select_thread(state, stream, msgmap);
+            }
+            else
+               q_status_message(SM_ORDER, 0, 1,
+                        "Command available in threaded mode only");
+         break;
+ 
            case MC_DELETE :
            case MC_UNDELETE :
            case MC_REPLY :
***************
*** 977,989 ****
  		  if(rawno)
  		    thrd = fetch_thread(stream, rawno);
  
! 		  collapsed = thrd && thrd->next
! 			      && get_lflag(stream, NULL, rawno, MN_COLL);
  	      }
  
  	      if(collapsed){
  		  thread_command(state, stream, msgmap,
! 				 ch, -FOOTER_ROWS(state));
  		  /* increment current */
  		  if(cmd == MC_DELETE){
  		      advance_cur_after_delete(state, stream, msgmap,
--- 1082,1093 ----
  		  if(rawno)
  		    thrd = fetch_thread(stream, rawno);
  
! 		collapsed = thread_is_kolapsed(ps_global, stream, msgmap, rawno);
  	      }
  
  	      if(collapsed){
  		  thread_command(state, stream, msgmap,
! 				 ch, -FOOTER_ROWS(state),1);
  		  /* increment current */
  		  if(cmd == MC_DELETE){
  		      advance_cur_after_delete(state, stream, msgmap,
***************
*** 2675,2680 ****
--- 2779,2785 ----
  		      n = mn_raw2m(msgs, thrd->rawno);
  
  		    while(thrd){
+ 			unsigned long branch;
  			if(!msgline_hidden(stream, msgs, n, 0)
  			   && (++m % lines_per_page) == 1L)
  			  t = n;
***************
*** 2743,2753 ****
  
  	    /* n is the end of this thread */
  	    while(thrd){
  		n = mn_raw2m(msgs, thrd->rawno);
! 		if(thrd->branch)
! 		  thrd = fetch_thread(stream, thrd->branch);
! 		else if(thrd->next)
! 		  thrd = fetch_thread(stream, thrd->next);
  		else
  		  thrd = NULL;
  	    }
--- 2848,2859 ----
  
  	    /* n is the end of this thread */
  	    while(thrd){
+ 		unsigned long next = 0L, branch = 0L;
  		n = mn_raw2m(msgs, thrd->rawno);
! 		if(branch = get_branch(stream,thrd))
! 		  thrd = fetch_thread(stream, branch);
! 		else if(next = get_next(stream,thrd))
! 		  thrd = fetch_thread(stream, next);
  		else
  		  thrd = NULL;
  	    }
***************
*** 2855,2861 ****
  
  void
  thread_command(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap,
! 	       UCS preloadkeystroke, int q_line)
  {
      PINETHRD_S   *thrd = NULL;
      unsigned long rawno, save_branch;
--- 2961,2967 ----
  
  void
  thread_command(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap,
! 	       UCS preloadkeystroke, int q_line, int display)
  {
      PINETHRD_S   *thrd = NULL;
      unsigned long rawno, save_branch;
***************
*** 2904,2910 ****
        cancel_busy_cue(0);
  
      (void ) apply_command(state, stream, msgmap, preloadkeystroke, flags,
! 			  q_line);
  
      /* restore the original flags */
      copy_lflags(stream, msgmap, MN_STMP, MN_SLCT);
--- 3010,3016 ----
        cancel_busy_cue(0);
  
      (void ) apply_command(state, stream, msgmap, preloadkeystroke, flags,
! 			  q_line, display);
  
      /* restore the original flags */
      copy_lflags(stream, msgmap, MN_STMP, MN_SLCT);
***************
*** 3398,3404 ****
      if(set){
  	sort_folder(ps_global->mail_stream, ps_global->msgmap,
  		    order & 0x000000ff,
! 		    (order & 0x00000100) != 0, SRT_VRB);
  	mswin_beginupdate();
  	update_titlebar_message();
  	update_titlebar_status();
--- 3504,3510 ----
      if(set){
  	sort_folder(ps_global->mail_stream, ps_global->msgmap,
  		    order & 0x000000ff,
! 		    (order & 0x00000100) != 0, SRT_VRB, 1);
  	mswin_beginupdate();
  	update_titlebar_message();
  	update_titlebar_status();
diff -rc alpine-2.11/alpine/mailindx.h alpine-2.11.I.USE/alpine/mailindx.h
*** alpine-2.11/alpine/mailindx.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/mailindx.h	2013-12-01 16:33:57.000000000 -0700
***************
*** 103,109 ****
  void		 paint_index_hline(MAILSTREAM *, long, ICE_S *);
  void		 setup_index_state(int);
  void		 warn_other_cmds(void);
! void		 thread_command(struct pine *, MAILSTREAM *, MSGNO_S *, UCS, int);
  COLOR_PAIR      *apply_rev_color(COLOR_PAIR *, int);
  #ifdef	_WINDOWS
  int		 index_sort_callback(int, long);
--- 103,109 ----
  void		 paint_index_hline(MAILSTREAM *, long, ICE_S *);
  void		 setup_index_state(int);
  void		 warn_other_cmds(void);
! void		 thread_command(struct pine *, MAILSTREAM *, MSGNO_S *, UCS, int, int);
  COLOR_PAIR      *apply_rev_color(COLOR_PAIR *, int);
  #ifdef	_WINDOWS
  int		 index_sort_callback(int, long);
diff -rc alpine-2.11/alpine/mailpart.c alpine-2.11.I.USE/alpine/mailpart.c
*** alpine-2.11/alpine/mailpart.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/mailpart.c	2013-12-01 16:40:07.000000000 -0700
***************
*** 2146,2151 ****
--- 2146,2156 ----
          return(1);
      }
  
+     /* ok, we have a filename. Now check if there is a template, and if
+      * so, rename the file accordingly
+      */
+     filename = mc_template(filename, a->body, a->can_display & MCD_EXT_PROMPT);
+ 
      if((store = so_get(FileStar, filename, WRITE_ACCESS|OWNER_ONLY)) == NULL){
          q_status_message2(SM_ORDER | SM_DING, 3, 5,
                            _("Error \"%s\", Can't write file %s"),
***************
*** 3308,3314 ****
      /*
       * For consistency, the first question is always "include text?"
       */
!     if((include_text = reply_text_query(ps_global, 1, &prefix)) >= 0
         && reply_news_test(a->body->nested.msg->env, outgoing) > 0
         && reply_harvest(ps_global, msgno, a->number,
  			a->body->nested.msg->env, &saved_from,
--- 3313,3319 ----
      /*
       * For consistency, the first question is always "include text?"
       */
!     if((include_text = reply_text_query(ps_global, 1, NULL, &prefix)) >= 0
         && reply_news_test(a->body->nested.msg->env, outgoing) > 0
         && reply_harvest(ps_global, msgno, a->number,
  			a->body->nested.msg->env, &saved_from,
diff -rc alpine-2.11/alpine/mailview.c alpine-2.11.I.USE/alpine/mailview.c
*** alpine-2.11/alpine/mailview.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/mailview.c	2013-12-01 16:36:01.000000000 -0700
***************
*** 45,50 ****
--- 45,51 ----
  #include "dispfilt.h"
  #include "busy.h"
  #include "smime.h"
+ #include "roleconf.h"
  #include "../pith/conf.h"
  #include "../pith/filter.h"
  #include "../pith/msgno.h"
***************
*** 130,135 ****
--- 131,137 ----
  #define	SS_CUR	2
  #define	SS_FREE	3
  
+ static ACTION_S *role_chosen = NULL;
  
  /*
   * Handle hints.
***************
*** 204,210 ****
--- 206,220 ----
  int	    pcpine_view_cursor(int, long);
  #endif
  
+ static char *prefix;
+ #define NO_FLOWED  0x0000
+ #define IS_FLOWED  0x0001
+ #define DELETEQUO  0x0010
+ #define COLORAQUO  0x0100
+ #define RAWSTRING  0x1000
  
+ int         is_word (char *, int, int);
+ int         is_mailbox(char *, int, int);
  
  /*----------------------------------------------------------------------
       Format a buffer with the text of the current message for browser
***************
*** 243,248 ****
--- 253,260 ----
      ps->prev_screen = mail_view_screen;
      ps->force_prefer_plain = ps->force_no_prefer_plain = 0;
  
+     strcpy(ps->screen_name, "text");
+ 
      if(ps->ttyo->screen_rows - HEADER_ROWS(ps) - FOOTER_ROWS(ps) < 1){
  	q_status_message(SM_ORDER | SM_DING, 0, 3,
  			 _("Screen too small to view message"));
***************
*** 295,300 ****
--- 307,323 ----
  	else
  	  ps->unseen_in_view = !mc->seen;
  
+ 	prefix = reply_quote_str(env);
+ 	/* Make sure the prefix is not only made of spaces, so that we do not
+ 	 * paint the screen incorrectly
+ 	 */
+ 	if (prefix && *prefix){
+ 	   int i;
+ 	   for (i = 0; isspace((unsigned char) prefix[i]); i++);
+ 	   if (i == strlen(prefix))
+ 	     fs_give((void **)&prefix);
+ 	}
+ 
  	init_handles(&handles);
  
  	store = so_get(src, NULL, EDIT_ACCESS);
***************
*** 479,484 ****
--- 502,511 ----
      }
      while(ps->next_screen == SCREEN_FUN_NULL);
  
+     strcpy(ps->screen_name, "unknown");
+ 
+     if (prefix && *prefix)
+        fs_give((void **)&prefix);
      if(we_cancel)
        cancel_busy_cue(-1);
  
***************
*** 733,738 ****
--- 760,767 ----
  	{0, 'a', "A", N_("editApp")},
  	{-1, 0, NULL, NULL}};
  
+     if (role_chosen)
+ 	free_action(&role_chosen);
      if(handle->type == URL){
  	launch_opts[4].ch = 'u';
  
***************
*** 847,858 ****
  	 * sense if you just say View selected URL ...
  	 */
  	if(handle->type == URL &&
! 	   !struncmp(handle->h.url.path, "mailto:", 7))
! 	  snprintf(prompt, sizeof(prompt), "Compose mail to \"%.*s%s\" ? ",
! 		  MIN(MAX(0,sc - 25), sizeof(prompt)-50), handle->h.url.path+7,
! 		  (strlen(handle->h.url.path+7) > MAX(0,sc-25)) ? "..." : "");
! 	else
! 	  snprintf(prompt, sizeof(prompt), "View selected %s %s%.*s%s ? ",
  		  (handle->type == URL) ? "URL" : "Attachment",
  		  (handle->type == URL) ? "\"" : "",
  		  MIN(MAX(0,sc-27), sizeof(prompt)-50),
--- 876,917 ----
  	 * sense if you just say View selected URL ...
  	 */
  	if(handle->type == URL &&
! 	  !struncmp(handle->h.url.path, "mailto:", 7)){
! 	  int rolenick = role_chosen ? strlen(role_chosen->nick) : 0;
! 	  int offset   = 25 + (role_chosen ? 20 : 0);
! 	  int offset2  = max(0, sc - offset) - strlen(handle->h.url.path+7);
! 	  int offset3  = sc - strlen(handle->h.url.path+7) - rolenick - offset;
! 	  int laddress = min(max(0,sc - offset), sizeof(prompt)-50);
! 	  int lrole    = rolenick;
! 
! 	  if (offset3 < 0){
! 		lrole    = rolenick;
! 		laddress = sc - offset - lrole;
! 		offset3 = laddress - 20; /* redefine offset3 */
! 		if (offset3 < 0){
! 		   laddress = 20;
! 		   lrole    = sc - offset - laddress;
! 		}
! 	  }
! 	  launch_opts[2].ch = 'r';
! 	  launch_opts[2].rval = 'r';
! 	  launch_opts[2].name = "R";
! 	  launch_opts[2].label = N_("Set Role");
! 	  snprintf(prompt, sizeof(prompt), "Compose mail to \"%.*s%s\" %s%.*s%s%s? ",
! 		laddress, handle->h.url.path+7,
! 		(offset2 < 0 ? "..." : ""),
! 		(role_chosen ? "using role \"" : ""),
! 		(role_chosen ? lrole : 0),
! 		(role_chosen ? role_chosen->nick  : ""),
! 		(role_chosen ? (rolenick > lrole ? "..." : "") : ""),
! 		(role_chosen ? "\" " : ""));
! 	}
! 	else{
! 	    launch_opts[2].ch = -2;
! 	    launch_opts[2].rval = 0;
! 	    launch_opts[2].name = NULL;
! 	    launch_opts[2].label = NULL;
! 	    snprintf(prompt, sizeof(prompt), "View selected %s %s%.*s%s ? ",
  		  (handle->type == URL) ? "URL" : "Attachment",
  		  (handle->type == URL) ? "\"" : "",
  		  MIN(MAX(0,sc-27), sizeof(prompt)-50),
***************
*** 860,865 ****
--- 919,925 ----
  		  (handle->type == URL)
  		    ? ((strlen(handle->h.url.path) > MAX(0,sc-27))
  			    ? "...\"" : "\"") : "");
+ 	}
  
  	prompt[sizeof(prompt)-1] = '\0';
  
***************
*** 868,873 ****
--- 928,956 ----
  	  case 'y' :
  	    return(1);
  
+           case 'r':
+ 	  {
+ 	  void (*prev_screen)(struct pine *) = ps_global->prev_screen,
+ 		    (*redraw)(void) = ps_global->redrawer;
+ 	  ps_global->redrawer = NULL;
+ 	  ps_global->next_screen = SCREEN_FUN_NULL;
+ 	  if(role_select_screen(ps_global, &role_chosen, 1) < 0){
+ 	     cmd_cancelled("Compose");
+ 	   ps_global->next_screen = prev_screen;
+ 	   ps_global->redrawer = redraw;
+ 	     if(ps_global->redrawer)
+ 	       (*ps_global->redrawer)();
+ 	     return 0;
+ 	  }
+ 	  ps_global->next_screen = prev_screen;
+ 	  ps_global->redrawer = redraw;
+ 	  if(role_chosen)
+ 	  role_chosen = combine_inherited_role(role_chosen);
+ 	  if(ps_global->redrawer)
+ 	    (*ps_global->redrawer)();
+ 	  break;
+ 	}
+ 
  	  case 'u' :
  	    strncpy(tmp, handle->h.url.path, sizeof(tmp)-1);
  	    tmp[sizeof(tmp)-1] = '\0';
***************
*** 1718,1724 ****
  	fs_give((void **) &urlp);
  
  	rflags = ROLE_COMPOSE;
! 	if(nonempty_patterns(rflags, &dummy)){
  	    role = set_role_from_msg(ps_global, rflags, -1L, NULL);
  	    if(confirm_role(rflags, &role))
  	      role = combine_inherited_role(role);
--- 1801,1807 ----
  	fs_give((void **) &urlp);
  
  	rflags = ROLE_COMPOSE;
! 	if(!(role = copy_action(role_chosen)) && nonempty_patterns(rflags, &dummy)){
  	    role = set_role_from_msg(ps_global, rflags, -1L, NULL);
  	    if(confirm_role(rflags, &role))
  	      role = combine_inherited_role(role);
***************
*** 1794,1799 ****
--- 1877,1883 ----
      
      free_redraft_pos(&redraft_pos);
      free_action(&role);
+     free_action(&role_chosen);
  
      return(rv);
  }
***************
*** 3364,3369 ****
--- 3448,3499 ----
  	    print_to_printer(sparms);
  	    break;
  
+           case MC_NEXTHREAD:
+           case MC_PRETHREAD:
+              if (THREADING()){
+                 if (any_messages(ps_global->msgmap, NULL,
+                                         "to move to other thread"))
+                   move_thread(ps_global, ps_global->mail_stream, ps_global->msgmap,
+                                                 cmd == MC_NEXTHREAD ? 1 : -1);
+ 		  done = 1;
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 1,
+                          "Command available in threaded mode only");
+           break;
+ 
+           case MC_DELTHREAD:
+              if (THREADING()){
+                 if (any_messages(ps_global->msgmap, NULL, "to delete"))
+                     cmd_delete_thread(ps_global, ps_global->mail_stream, ps_global->msgmap);
+ 		done = 1;
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 1,
+                          "Command available in threaded mode only");
+           break;  
+                 
+           case MC_UNDTHREAD:
+              if (THREADING()){
+                 if (any_messages(ps_global->msgmap, NULL, "to undelete"))
+                     cmd_undelete_thread(ps_global, ps_global->mail_stream, ps_global->msgmap);
+ 		done = 1;
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 1,
+                          "Command available in threaded mode only");   
+           break;
+              
+           case MC_SELTHREAD:
+              if (THREADING()){
+                 if (any_messages(ps_global->msgmap, NULL, "to undelete"))
+                     cmd_select_thread(ps_global, ps_global->mail_stream, ps_global->msgmap);
+ 		done = 1;
+              }
+              else
+                 q_status_message(SM_ORDER, 0, 1,
+                          "Command available in threaded mode only");
+           break;
  
  	    /* ------- First handle on Line ------ */
  	  case MC_GOTOBOL :
diff -rc alpine-2.11/alpine/Makefile.am alpine-2.11.I.USE/alpine/Makefile.am
*** alpine-2.11/alpine/Makefile.am	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/Makefile.am	2013-12-01 16:41:02.000000000 -0700
***************
*** 46,48 ****
--- 46,49 ----
  date.c:
  	echo "char datestamp[]="\"`date`\"";" > date.c
  	echo "char hoststamp[]="\"`hostname`\"";" >> date.c
+ 	cat ../patchlevel >> date.c
diff -rc alpine-2.11/alpine/Makefile.in alpine-2.11.I.USE/alpine/Makefile.in
*** alpine-2.11/alpine/Makefile.in	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/Makefile.in	2013-12-01 16:41:02.000000000 -0700
***************
*** 822,827 ****
--- 822,828 ----
  date.c:
  	echo "char datestamp[]="\"`date`\"";" > date.c
  	echo "char hoststamp[]="\"`hostname`\"";" >> date.c
+ 	cat ../patchlevel >> date.c
  
  # Tell versions [3.59,3.63) of GNU make to not export all variables.
  # Otherwise a system limit (for SysV at least) may be exceeded.
diff -rc alpine-2.11/alpine/osdep/debuging.c alpine-2.11.I.USE/alpine/osdep/debuging.c
*** alpine-2.11/alpine/osdep/debuging.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/osdep/debuging.c	2013-12-01 16:41:02.000000000 -0700
***************
*** 105,110 ****
--- 105,111 ----
  
      if(debugfile != NULL){
  	char rev[128];
+ 	extern char plevstamp[];
  	time_t now = time((time_t *)0);
  	if(ps_global->debug_flush)
  	  setvbuf(debugfile, (char *)NULL, _IOLBF, BUFSIZ);
***************
*** 127,132 ****
--- 128,135 ----
  	       get_alpine_revision_string(rev, sizeof(rev)),
  	       ctime(&now)));
  
+ 	dprint((0, "This version uses all.patch:\n%s\n\n", plevstamp));
+ 
  	dprint((0, "Starting after the reading_pinerc calls, the data in this file should\nbe encoded as UTF-8. Before that it will be in the user's native charset.\n"));
  	if(dfile && (debug > DEFAULT_DEBUG ||
  		     ps_global->debug_imap > 0 ||
diff -rc alpine-2.11/alpine/osdep/execview.c alpine-2.11.I.USE/alpine/osdep/execview.c
*** alpine-2.11/alpine/osdep/execview.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/osdep/execview.c	2013-12-01 16:40:48.000000000 -0700
***************
*** 261,267 ****
      p = command = (char *)fs_get((l+1) * sizeof(char));
      if(!needsterminal)  /* put in background if it doesn't need terminal */
        *p++ = '(';
!     snprintf(p, l+1-(p-command), "%s ; rm -f %s", cmd, image_file);
      command[l] = '\0';
      p += strlen(p);
      if(!needsterminal && (p-command)+5 < l){
--- 261,267 ----
      p = command = (char *)fs_get((l+1) * sizeof(char));
      if(!needsterminal)  /* put in background if it doesn't need terminal */
        *p++ = '(';
!     snprintf(p, l+1-(p-command), "%s ; sleep %d ; rm -f %s", cmd, ps_global->sleep, image_file);
      command[l] = '\0';
      p += strlen(p);
      if(!needsterminal && (p-command)+5 < l){
diff -rc alpine-2.11/alpine/osdep/termin.gen.c alpine-2.11.I.USE/alpine/osdep/termin.gen.c
*** alpine-2.11/alpine/osdep/termin.gen.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/osdep/termin.gen.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 33,38 ****
--- 33,40 ----
  #include "../../pith/newmail.h"
  #include "../../pith/conf.h"
  #include "../../pith/busy.h"
+ #include "../../pith/list.h"
+ #include "../../pith/rules.h"
  
  #include "../../pico/estruct.h"
  #include "../../pico/pico.h"
***************
*** 67,78 ****
  int	pcpine_oe_cursor(int, long);
  #endif
  
  
  /*
   *     Generic tty input routines
   */
  
! 
  /*----------------------------------------------------------------------
          Read a character from keyboard with timeout
   Input:  none
--- 69,98 ----
  int	pcpine_oe_cursor(int, long);
  #endif
  
+ void
+ fake_config_screen(tt)
+      struct ttyo **tt;
+ {
+     struct ttyo *ttyo;
+ 
+     ttyo = (struct ttyo *)fs_get(sizeof (struct ttyo));
+ 
+     ttyo->header_rows = 2;
+     ttyo->footer_rows = 3;
+     ttyo->screen_rows = 24;
+     ttyo->screen_cols = 80;
+ 
+     *tt = ttyo;
+ 
+ }
+ 
  
  /*
   *     Generic tty input routines
   */
  
! void    process_init_cmds(struct pine *, char **);
! void    queue_init_errors(struct pine *);
  /*----------------------------------------------------------------------
          Read a character from keyboard with timeout
   Input:  none
***************
*** 114,119 ****
--- 134,174 ----
        *utf8str = NULL;
  
      ucs = read_char(tm);
+     if(!ps_global->initial_cmds){
+       RULE_RESULT *rule;
+       char **list = NULL, *error = NULL;
+       int    commas = 0, k;   /* From args.c */
+ 
+       ps_global->pressed_key = cpystr(pretty_command(ucs));
+       rule = (RULE_RESULT *)get_result_rule(V_KEY_RULES, FOR_KEY, NULL);
+       if(ps_global->pressed_key)
+         fs_give((void **)&ps_global->pressed_key);
+       if (rule){
+          for(k = 0; rule->result[k]; k++)
+             if(rule->result[k] == ',') commas++;
+          list = parse_list(rule->result, commas+1, 0, &error);
+          if(error)
+             sprintf(tmp_20k_buf, "Error in parsing command list: %s, %s",
+                       rule->result, error);
+          if (rule->result)
+            fs_give((void **)&rule->result);
+          fs_give((void **)&rule);
+          if(error){
+             q_status_message(SM_ORDER | SM_DING, 0, 2, tmp_20k_buf);
+             return (NO_OP_COMMAND);
+          }
+ 	 process_init_cmds(ps_global, list);
+ 	 if(ps_global->init_errs){
+ 	    queue_init_errors(ps_global);
+             return (NO_OP_COMMAND);
+ 	 }
+ 	 ucs = read_char(tm);
+ 	 ps_global->in_init_seq = 1;  /* no output please */
+ 	 for(k = 0; k < commas; k++)
+             if(list[k]) fs_give((void **)&list[k]);
+          if (list) fs_give((void **)list);
+       }
+     }
      if(ucs != NO_OP_COMMAND && ucs != NO_OP_IDLE && ucs != KEY_RESIZE)
        zero_new_mail_count();
  
***************
*** 307,313 ****
  	       (escape_list && escape_list[0].ch != -1 && escape_list[0].label)
  		 ? escape_list[0].label: ""));
  
!     if(!ps_global->ttyo)
        return(pre_screen_config_opt_enter(utf8string, utf8string_size, utf8prompt,
  					 escape_list, help, flags));
  
--- 362,368 ----
  	       (escape_list && escape_list[0].ch != -1 && escape_list[0].label)
  		 ? escape_list[0].label: ""));
  
!     if(!ps_global->ttyo || ps_global->send_immediately)
        return(pre_screen_config_opt_enter(utf8string, utf8string_size, utf8prompt,
  					 escape_list, help, flags));
  
***************
*** 1154,1163 ****
  		}
  	    }
  	}
! 
  	if(!*ps_global->initial_cmds && ps_global->free_initial_cmds){
  	    fs_give((void **) &ps_global->free_initial_cmds);
  	    ps_global->initial_cmds = NULL;
  	}
  
  	return(ret);
--- 1209,1219 ----
  		}
  	    }
  	}
! 	ps_global->initial_cmds_offset++;
  	if(!*ps_global->initial_cmds && ps_global->free_initial_cmds){
  	    fs_give((void **) &ps_global->free_initial_cmds);
  	    ps_global->initial_cmds = NULL;
+ 	    firsttime = (char) 1;
  	}
  
  	return(ret);
diff -rc alpine-2.11/alpine/osdep/termin.gen.h alpine-2.11.I.USE/alpine/osdep/termin.gen.h
*** alpine-2.11/alpine/osdep/termin.gen.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/osdep/termin.gen.h	2013-12-01 16:35:25.000000000 -0700
***************
*** 33,38 ****
--- 33,39 ----
  int	key_recorder(int);
  int	key_playback(int);
  int	recent_keystroke(int *, char *, size_t);
+ void	fake_config_screen(struct ttyo **);
  int	init_tty_driver(struct pine *);
  void	end_tty_driver(struct pine *);
  int	PineRaw(int);
diff -rc alpine-2.11/alpine/osdep/termin.unx.c alpine-2.11.I.USE/alpine/osdep/termin.unx.c
*** alpine-2.11/alpine/osdep/termin.unx.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/osdep/termin.unx.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 111,116 ****
--- 111,118 ----
  int
  init_tty_driver(struct pine *ps)
  {
+    if(ps->send_immediately)
+      return 0;
  #ifdef	MOUSE
      if(F_ON(F_ENABLE_MOUSE, ps_global))
        init_mouse();
***************
*** 683,688 ****
--- 685,693 ----
  void
  init_keyboard(int use_fkeys)
  {
+     if (ps_global->send_immediately)
+ 	return;
+ 
      if(use_fkeys && (!strucmp(term_name,"vt102")
  		     || !strucmp(term_name,"vt100")))
        printf("\033\133\071\071\150");
***************
*** 700,705 ****
--- 705,713 ----
  void
  end_keyboard(int use_fkeys)
  {
+     if(ps_global->send_immediately)
+ 	return;
+ 
      if(use_fkeys && (!strcmp(term_name, "vt102")
  		     || !strcmp(term_name, "vt100"))){
  	printf("\033\133\071\071\154");
diff -rc alpine-2.11/alpine/osdep/termout.unx.c alpine-2.11.I.USE/alpine/osdep/termout.unx.c
*** alpine-2.11/alpine/osdep/termout.unx.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/osdep/termout.unx.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 206,211 ****
--- 206,214 ----
  void
  init_screen(void)
  {
+     if(ps_global->send_immediately)
+ 	return;
+ 
      if(_termcap_init)			/* init using termcap's rule */
        tputs(_termcap_init, 1, outchar);
  
***************
*** 313,318 ****
--- 316,324 ----
  {
      int footer_rows_was_one = 0;
  
+     if(ps_global->send_immediately)
+       return;
+ 
      if(!panicking()){
  
  	dprint((9, "end_screen called\n"));
***************
*** 367,373 ****
      _line = 0;	/* clear leaves us at top... */
      _col  = 0;
  
!     if(ps_global->in_init_seq)
        return;
  
      mark_status_unknown();
--- 373,379 ----
      _line = 0;	/* clear leaves us at top... */
      _col  = 0;
  
!     if(ps_global->in_init_seq || ps_global->send_immediately)
        return;
  
      mark_status_unknown();
diff -rc alpine-2.11/alpine/radio.c alpine-2.11.I.USE/alpine/radio.c
*** alpine-2.11/alpine/radio.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/radio.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 122,128 ****
      int	  rv, width;
      size_t len;
  
!     if(!ps_global->ttyo)
        return(pre_screen_config_want_to(question, dflt, on_ctrl_C));
  #ifdef _WINDOWS
      if (mswin_usedialog ()) {
--- 122,128 ----
      int	  rv, width;
      size_t len;
  
!     if(!ps_global->ttyo || ps_global->send_immediately)
        return(pre_screen_config_want_to(question, dflt, on_ctrl_C));
  #ifdef _WINDOWS
      if (mswin_usedialog ()) {
diff -rc alpine-2.11/alpine/reply.c alpine-2.11.I.USE/alpine/reply.c
*** alpine-2.11/alpine/reply.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/reply.c	2013-12-01 16:41:34.000000000 -0700
***************
*** 62,68 ****
  #include "../pith/tempfile.h"
  #include "../pith/busy.h"
  #include "../pith/ablookup.h"
! 
  
  /*
   * Internal Prototypes
--- 62,69 ----
  #include "../pith/tempfile.h"
  #include "../pith/busy.h"
  #include "../pith/ablookup.h"
! #include "../pith/copyaddr.h"
! #include "../pith/rules.h"
  
  /*
   * Internal Prototypes
***************
*** 109,119 ****
      long        msgno, j, totalm, rflags, *seq = NULL;
      int         i, include_text = 0, times = -1, warned = 0, rv = 0,
  		flags = RSF_QUERY_REPLY_ALL, reply_raw_body = 0;
!     int         rolemsg = 0, copytomsg = 0;
      gf_io_t     pc;
      PAT_STATE   dummy;
      REDRAFT_POS_S *redraft_pos = NULL;
      ACTION_S   *role = NULL, *nrole;
  #if	defined(DOS) && !defined(_WINDOWS)
      char *reserve;
  #endif
--- 110,121 ----
      long        msgno, j, totalm, rflags, *seq = NULL;
      int         i, include_text = 0, times = -1, warned = 0, rv = 0,
  		flags = RSF_QUERY_REPLY_ALL, reply_raw_body = 0;
!     int         rolemsg = 0, copytomsg = 0, do_role_early = 0;
      gf_io_t     pc;
      PAT_STATE   dummy;
      REDRAFT_POS_S *redraft_pos = NULL;
      ACTION_S   *role = NULL, *nrole;
+     RULE_RESULT *rule;
  #if	defined(DOS) && !defined(_WINDOWS)
      char *reserve;
  #endif
***************
*** 139,144 ****
--- 141,209 ----
         && F_ON(F_ENABLE_FULL_HDR_AND_TEXT, ps_global))
        reply_raw_body = 1;
  
+     /* Setup possible role */
+     if(role_arg)
+       role = copy_action(role_arg);
+ 
+     if(!role && F_ON(F_ENABLE_EDIT_REPLY_INDENT, pine_state)){
+ 	for(msgno = mn_first_cur(pine_state->msgmap);
+ 	    msgno > 0L;  msgno = mn_next_cur(pine_state->msgmap)){
+ 
+ 	    env = pine_mail_fetchstructure(pine_state->mail_stream,
+ 					   mn_m2raw(pine_state->msgmap, msgno),
+ 					   NULL);
+ 	    if(!env) {
+ 		q_status_message1(SM_ORDER,3,4,
+ 			    _("Error fetching message %s. Can't reply to it."),
+ 				long2string(msgno));
+ 		goto done_early;
+ 	    }
+ 
+ 	    if(rule = get_result_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE , env)){
+ 	        RULELIST *list = get_rulelist_from_code(V_REPLY_INDENT_RULES,
+                                                 ps_global->rule_list);
+ 	        RULE_S *prule = get_rule(list, rule->number);
+ 		if(condition_contains_token(prule->condition, ROLE_TOKEN))
+ 		  do_role_early++;
+ 		if(rule->result)
+ 		  fs_give((void **)&rule->result);
+ 		fs_give((void **)&rule);
+ 	    }
+ 	}
+     }
+ 
+     if(do_role_early){
+ 	rflags = ROLE_REPLY;
+ 	if(nonempty_patterns(rflags, &dummy)){
+ 	    /* setup default role */
+ 	    nrole = NULL;
+ 	    j = mn_first_cur(pine_state->msgmap);
+ 	    do {
+ 		role = nrole;
+ 		nrole = set_role_from_msg(pine_state, rflags,
+ 					  mn_m2raw(pine_state->msgmap, j),
+ 					  NULL);
+ 	    } while(nrole && (!role || nrole == role)
+ 		    && (j=mn_next_cur(pine_state->msgmap)) > 0L);
+ 
+ 	    if(!role || nrole == role)
+ 	      role = nrole;
+ 	    else
+ 	      role = NULL;
+ 
+ 	    if(confirm_role(rflags, &role))
+ 	      role = combine_inherited_role(role);
+ 	    else{				/* cancel reply */
+ 		role = NULL;
+ 		cmd_cancelled("Reply");
+ 		goto done_early;
+ 	    }
+ 	}
+     }
+ 
+     if (role)
+ 	ps_global->role = cpystr(role->nick); /* remember the role */
+ 
      /*
       * We may have to loop through first to figure out what default
       * reply-indent-string to offer...
***************
*** 230,236 ****
  	if(!times){		/* only first time */
  	    char *p = cpystr(prefix);
  
! 	    if((include_text=reply_text_query(pine_state,totalm,&prefix)) < 0)
  	      goto done_early;
  	    
  	    /* edited prefix? */
--- 295,301 ----
  	if(!times){		/* only first time */
  	    char *p = cpystr(prefix);
  
! 	    if((include_text=reply_text_query(pine_state,totalm,env,&prefix)) < 0)
  	      goto done_early;
  	    
  	    /* edited prefix? */
***************
*** 286,293 ****
  		outgoing->subject = cpystr("Re: several messages");
  	    }
  	}
! 	else
! 	  outgoing->subject = reply_subject(env->subject, NULL, 0);
      }
  
      /* fill reply header */
--- 351,368 ----
  		outgoing->subject = cpystr("Re: several messages");
  	    }
  	}
! 	else{
! 	   RULE_RESULT *rule;
! 	   rule = get_result_rule(V_RESUB_RULES,FOR_RESUB|FOR_TRIM , env);
! 	   if (rule){
! 	     outgoing->subject = reply_subject(rule->result, NULL, 0);
! 	     if (rule->result)
! 	        fs_give((void **)&rule->result);
! 	     fs_give((void **)&rule);
! 	   }
! 	   else
! 	       outgoing->subject = reply_subject(env->subject, NULL, 0);
! 	}
      }
  
      /* fill reply header */
***************
*** 306,318 ****
      if(sp_expunge_count(pine_state->mail_stream))	/* cur msg expunged */
        goto done_early;
  
!     /* Setup possible role */
!     if(role_arg)
!       role = copy_action(role_arg);
  
!     if(!role){
  	rflags = ROLE_REPLY;
! 	if(nonempty_patterns(rflags, &dummy)){
  	    /* setup default role */
  	    nrole = NULL;
  	    j = mn_first_cur(pine_state->msgmap);
--- 381,395 ----
      if(sp_expunge_count(pine_state->mail_stream))	/* cur msg expunged */
        goto done_early;
  
!     if (ps_global->reply.role_chosen){
!       if(role_arg)
!         free_action(&role);
!       role = ps_global->reply.role_chosen;
!     }
  
!     if(!role && !do_role_early){
  	rflags = ROLE_REPLY;
! 	if(!ps_global->reply.role_chosen && nonempty_patterns(rflags, &dummy)){
  	    /* setup default role */
  	    nrole = NULL;
  	    j = mn_first_cur(pine_state->msgmap);
***************
*** 548,554 ****
  
  	    if(orig_body == NULL || orig_body->type == TYPETEXT || reply_raw_body) {
  		reply_delimiter(env, role, pc);
! 		if(F_ON(F_INCLUDE_HEADER, pine_state))
  		  reply_forward_header(pine_state->mail_stream,
  				       mn_m2raw(pine_state->msgmap,msgno),
  				       NULL, env, pc, prefix);
--- 625,631 ----
  
  	    if(orig_body == NULL || orig_body->type == TYPETEXT || reply_raw_body) {
  		reply_delimiter(env, role, pc);
! 		if(ps_global->reply.inchdr)
  		  reply_forward_header(pine_state->mail_stream,
  				       mn_m2raw(pine_state->msgmap,msgno),
  				       NULL, env, pc, prefix);
***************
*** 567,573 ****
  		   && orig_body->nested.part->body.type == TYPETEXT) {
  		    /*---- First part of the message is text -----*/
  		    reply_delimiter(env, role, pc);
! 		    if(F_ON(F_INCLUDE_HEADER, pine_state))
  		      reply_forward_header(pine_state->mail_stream,
  					   mn_m2raw(pine_state->msgmap,
  						    msgno),
--- 644,650 ----
  		   && orig_body->nested.part->body.type == TYPETEXT) {
  		    /*---- First part of the message is text -----*/
  		    reply_delimiter(env, role, pc);
! 		    if(ps_global->reply.inchdr)
  		      reply_forward_header(pine_state->mail_stream,
  					   mn_m2raw(pine_state->msgmap,
  						    msgno),
***************
*** 721,726 ****
--- 798,806 ----
      if(prefix)
        fs_give((void **)&prefix);
  
+     if (ps_global->role)
+ 	fs_give((void **)&ps_global->role);
+ 
      if(fcc)
        fs_give((void **) &fcc);
  
***************
*** 876,882 ****
  
  	prompt[sizeof(prompt)-1] = '\0';
  
! 	cmd = radio_buttons(prompt, -FOOTER_ROWS(ps_global), ekey,
  			    'y', 'x', help, RB_NORM);
  
  	switch(cmd){
--- 956,963 ----
  
  	prompt[sizeof(prompt)-1] = '\0';
  
! 	cmd = ps_global->send_immediately ? 'n' :
! 		radio_buttons(prompt, -FOOTER_ROWS(ps_global), ekey,
  			    'y', 'x', help, RB_NORM);
  
  	switch(cmd){
***************
*** 1003,1050 ****
   *	     0 if we're NOT to include the text
   *	    -1 on cancel or error
   */
  int
! reply_text_query(struct pine *ps, long int many, char **prefix)
  {
      int ret, edited = 0;
!     static ESCKEY_S rtq_opts[] = {
! 	{'y', 'y', "Y", N_("Yes")},
! 	{'n', 'n', "N", N_("No")},
! 	{-1, 0, NULL, NULL},	                  /* may be overridden below */
! 	{-1, 0, NULL, NULL}
!     };
  
      if(F_ON(F_AUTO_INCLUDE_IN_REPLY, ps)
!        && F_OFF(F_ENABLE_EDIT_REPLY_INDENT, ps))
        return(1);
  
!     while(1){
! 	if(many > 1L)
! 	  /* TRANSLATORS: The final three %s's can probably be safely ignored */
! 	  snprintf(tmp_20k_buf, SIZEOF_20KBUF, _("Include %s original messages in Reply%s%s%s? "),
! 		comatose(many),
! 		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? " (using \"" : "",
! 		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? *prefix : "",
! 		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? "\")" : "");
! 	else
! 	  snprintf(tmp_20k_buf, SIZEOF_20KBUF, _("Include original message in Reply%s%s%s? "),
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? " (using \"" : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? *prefix : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? "\")" : "");
  
! 	if(F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps)){
! 	    rtq_opts[2].ch    = ctrl('R');
! 	    rtq_opts[2].rval  = 'r';
! 	    rtq_opts[2].name  = "^R";
! 	    rtq_opts[2].label = N_("Edit Indent String");
! 	}
! 	else
! 	  rtq_opts[2].ch    = -1;
  
  	switch(ret = radio_buttons(tmp_20k_buf, 
  				   ps->ttyo->screen_rows > 4
  				     ? -FOOTER_ROWS(ps_global) : -1,
! 				   rtq_opts,
  				   (edited || F_ON(F_AUTO_INCLUDE_IN_REPLY, ps))
  				       ? 'y' : 'n',
  				   'x', NO_HELP, RB_SEQ_SENSITIVE)){
--- 1084,1196 ----
   *	     0 if we're NOT to include the text
   *	    -1 on cancel or error
   */
+ #define MAX_REPLY_OPTIONS 8
  int
! reply_text_query(struct pine *ps, long int many, ENVELOPE *env, char **prefix)
  {
      int ret, edited = 0;
!     static ESCKEY_S compose_style[MAX_REPLY_OPTIONS];
!     int	ekey_num;
!     int	orig_sf;
! 
!     orig_sf = *prefix && **prefix ? (F_OFF(F_QUELL_FLOWED_TEXT, ps)
! 		&& F_OFF(F_STRIP_WS_BEFORE_SEND, ps)
! 		&& (strcmp(*prefix, "> ") == 0
! 			|| strcmp(*prefix, ">") == 0)) : 0;
! 
!     ps_global->reply.no_send_flowed = !orig_sf;
!     ps_global->reply.role_chosen = NULL;
!     ps_global->reply.strip = ps->full_header == 0
! 		&& (F_ON(F_ENABLE_STRIP_SIGDASHES, ps)
! 			|| F_ON(F_ENABLE_SIGDASHES, ps));
!     ps_global->reply.attach = F_ON(F_ATTACHMENTS_IN_REPLY, ps);
!     ps_global->reply.inchdr = F_ON(F_INCLUDE_HEADER, ps);
  
      if(F_ON(F_AUTO_INCLUDE_IN_REPLY, ps)
!         && F_OFF(F_ENABLE_EDIT_REPLY_INDENT, ps) && F_OFF(F_ALT_REPLY_MENU,ps))
        return(1);
  
!     while(1){ 
! 	  /* TRANSLATORS: The final five %s's can probably be safely ignored */
! 	snprintf(tmp_20k_buf, SIZEOF_20KBUF, _("Include %s%soriginal message%s in Reply%s%s%s%s%s%s? "),
! 		(many > 1L) ? comatose(many) : "",
! 		(many > 1L) ? " " : "",
! 		(many > 1L) ? "s" : "",
! 		(many > 1L) ? "s" : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? " (using \"" : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? *prefix : "",
+ 		ps_global->reply.role_chosen ? "\" and role \"" : "",
+ 		ps_global->reply.role_chosen ? ps_global->reply.role_chosen->nick : "",
  		F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps) ? "\")" : "");
  
! 	ekey_num = 0;
! 	compose_style[ekey_num].ch    = 'y';
! 	compose_style[ekey_num].rval  = 'y';
! 	compose_style[ekey_num].name  = "Y";
! 	compose_style[ekey_num++].label = N_("Yes");
! 
! 	compose_style[ekey_num].ch    = 'n';
! 	compose_style[ekey_num].rval  = 'n';
! 	compose_style[ekey_num].name  = "N";
! 	compose_style[ekey_num++].label = N_("No");
! 
! 	if (F_ON(F_ENABLE_EDIT_REPLY_INDENT, ps)){
! 	   compose_style[ekey_num].ch      = ctrl('R');
! 	   compose_style[ekey_num].rval    = 'r';
! 	   compose_style[ekey_num].name    = "^R";
! 	   compose_style[ekey_num++].label = N_("Edit Indent String");
! 	}
! 
! 	/***** Alternate Reply Menu ********/
! 
! 	if (F_ON(F_ALT_REPLY_MENU, ps)){
! 	     unsigned which_help;
! 
! 	   if (F_ON(F_ENABLE_STRIP_SIGDASHES, ps) ||
! 		F_ON(F_ENABLE_SIGDASHES, ps)){
! 	      compose_style[ekey_num].ch      = 's';
! 	      compose_style[ekey_num].rval    = 'S';
! 	      compose_style[ekey_num].name    = "S";
! 	      compose_style[ekey_num++].label = ps_global->reply.strip 
! 						? N_("No Strip"): N_("Strip Sig");
! 	   }
! 
! 	   compose_style[ekey_num].ch      = 'r';
! 	   compose_style[ekey_num].rval    = 'R';
! 	   compose_style[ekey_num].name    = "R";
! 	   compose_style[ekey_num++].label = N_("Set Role");
! 
! 	   if(orig_sf){
! 	      compose_style[ekey_num].ch      = 'f';
! 	      compose_style[ekey_num].rval    = 'F';
! 	      compose_style[ekey_num].name    = "F";
! 	      compose_style[ekey_num++].label = ps_global->reply.no_send_flowed 
! 						? N_("Quell Flow") : N_("Send Flowd");
! 	   }
! 
! 	   compose_style[ekey_num].ch      = 'a';
! 	   compose_style[ekey_num].rval    = 'A';
! 	   compose_style[ekey_num].name    = "A";
! 	   compose_style[ekey_num++].label = ps_global->reply.attach 
! 						? N_("No Attach"): N_("Inc Attac");
! 
! 	   compose_style[ekey_num].ch      = 'h';
! 	   compose_style[ekey_num].rval    = 'H';
! 	   compose_style[ekey_num].name    = "H";
! 	   compose_style[ekey_num++].label = ps_global->reply.inchdr 
! 						? N_("No Header") : N_("Inc Head");
! 
! 	}
! 	compose_style[ekey_num].ch    = -1;
! 	compose_style[ekey_num].name  = NULL;
! 	compose_style[ekey_num].label = NULL;
! 
! 	/***** End Alt Reply Menu  *********/
  
  	switch(ret = radio_buttons(tmp_20k_buf, 
  				   ps->ttyo->screen_rows > 4
  				     ? -FOOTER_ROWS(ps_global) : -1,
! 				   compose_style,
  				   (edited || F_ON(F_AUTO_INCLUDE_IN_REPLY, ps))
  				       ? 'y' : 'n',
  				   'x', NO_HELP, RB_SEQ_SENSITIVE)){
***************
*** 1052,1057 ****
--- 1198,1243 ----
  	    cmd_cancelled("Reply");
  	    return(-1);
  
+ 	  case 'F':
+ 		ps_global->reply.no_send_flowed = (ps_global->reply.no_send_flowed + 1) % 2;
+ 		break;
+ 
+ 	  case 'S':
+ 		ps_global->reply.strip = (ps_global->reply.strip + 1) % 2;
+ 	   break;
+ 
+ 	  case 'A':
+ 		ps_global->reply.attach = (ps_global->reply.attach + 1) % 2;
+ 	   break;
+ 
+ 	  case 'H':
+ 		ps_global->reply.inchdr = (ps_global->reply.inchdr + 1) % 2;
+ 	   break;
+ 
+ 
+ 	  case 'R':
+ 	  {
+            void (*prev_screen)(struct pine *) = ps->prev_screen,
+                (*redraw)(void) = ps->redrawer;
+            ps->redrawer = NULL;
+            ps->next_screen = SCREEN_FUN_NULL;
+            if(role_select_screen(ps, &ps_global->reply.role_chosen, 1) < 0){
+              cmd_cancelled("Reply");
+              ps->next_screen = prev_screen;
+              ps->redrawer = redraw;
+ 	     if (ps->redrawer)
+ 		(*ps->redrawer)();
+ 	     continue;
+            }
+            ps->next_screen = prev_screen;
+            ps->redrawer = redraw;
+            if(ps_global->reply.role_chosen)
+               ps_global->reply.role_chosen = combine_inherited_role(ps_global->reply.role_chosen);
+ 	  }
+ 	  if (ps->redrawer)
+ 	     (*ps->redrawer)();
+ 	  break;
+ 
  	  case 'r':
  	    if(prefix && *prefix){
  		int  done = 0;
***************
*** 1075,1080 ****
--- 1261,1272 ----
  			if(flags & OE_USER_MODIFIED){
  			    fs_give((void **)prefix);
  			    *prefix = removing_quotes(cpystr(buf));
+ 			    orig_sf = *prefix && **prefix ?
+ 					   (F_OFF(F_QUELL_FLOWED_TEXT, ps)
+ 					&& F_OFF(F_STRIP_WS_BEFORE_SEND, ps)
+ 					&& (strcmp(*prefix, "> ") == 0
+ 					|| strcmp(*prefix, ">") == 0)) : 0;
+ 			    ps_global->reply.no_send_flowed = !orig_sf;
  			    edited = 1;
  			}
  
***************
*** 1471,1479 ****
  	}
      }
  
!     if(role)
        q_status_message1(SM_ORDER, 3, 4,
  			_("Forwarding using role \"%s\""), role->nick);
  
      if(role && role->template){
  	char *filtered;
--- 1663,1676 ----
  	}
      }
  
!     if (ps_global->role)
!       fs_give((void **)&ps_global->role);
! 
!     if(role){
        q_status_message1(SM_ORDER, 3, 4,
  			_("Forwarding using role \"%s\""), role->nick);
+       ps_global->role = cpystr(role->nick);
+     }
  
      if(role && role->template){
  	char *filtered;
***************
*** 1705,1710 ****
--- 1902,1908 ----
  #if	defined(DOS) && !defined(_WINDOWS)
      free((void *)reserve);
  #endif
+     outgoing->sparep = env && env->from ? copyaddr(env->from) : NULL;
      pine_send(outgoing, &body, "FORWARD MESSAGE",
  	      role, NULL, &reply, redraft_pos,
  	      NULL, NULL, 0);
***************
*** 2457,2462 ****
--- 2655,2662 ----
  {
      int rv;
      
+     if(ps_global->send_immediately)
+       return 0;
      clear_cursor_pos();			/* can't know where cursor is */
      mark_status_dirty();		/* don't count on cached text */
      fix_windsize(ps_global);
diff -rc alpine-2.11/alpine/reply.h alpine-2.11.I.USE/alpine/reply.h
*** alpine-2.11/alpine/reply.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/reply.h	2013-12-01 16:35:41.000000000 -0700
***************
*** 28,34 ****
  int	    confirm_role(long, ACTION_S **);
  int	    reply_to_all_query(int *);
  int	    reply_using_replyto_query(void);
! int	    reply_text_query(struct pine *, long, char **);
  int	    reply_news_test(ENVELOPE *, ENVELOPE *);
  char       *get_signature_file(char *, int, int, int);
  int	    forward(struct pine *, ACTION_S *);
--- 28,34 ----
  int	    confirm_role(long, ACTION_S **);
  int	    reply_to_all_query(int *);
  int	    reply_using_replyto_query(void);
! int	    reply_text_query(struct pine *, long, ENVELOPE *, char **);
  int	    reply_news_test(ENVELOPE *, ENVELOPE *);
  char       *get_signature_file(char *, int, int, int);
  int	    forward(struct pine *, ACTION_S *);
diff -rc alpine-2.11/alpine/roleconf.c alpine-2.11.I.USE/alpine/roleconf.c
*** alpine-2.11/alpine/roleconf.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/roleconf.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 140,147 ****
--- 140,152 ----
  
      if(!(nonempty_patterns(rflags, &pstate) &&
           first_pattern(&pstate))){
+ 	if(!ps->send_immediately)
  	q_status_message(SM_ORDER, 3, 3,
  			 _("No roles available. Use Setup/Rules to add roles."));
+ 	else{
+ 	   printf( _("No roles available. Use Setup/Rules to add roles."));
+ 	   exit(-1);
+ 	}
  	return(ret);
      }
  
***************
*** 4478,4488 ****
  	ctmp->tool		  = role_sort_tool;
  	ctmp->valoffset	    	  = rindent;
  	ctmp->flags              |= CF_NOSELECT;
! 	ctmp->value     = cpystr(set_choose);				\
  
  	pval = PVAL(&sort_act_var, ew);
  	if(pval)
! 	  decode_sort(pval, &def_sort, &def_sort_rev);
  
  	/* allow user to set their default sort order */
  	new_confline(&ctmp)->var = &sort_act_var;
--- 4483,4493 ----
  	ctmp->tool		  = role_sort_tool;
  	ctmp->valoffset	    	  = rindent;
  	ctmp->flags              |= CF_NOSELECT;
! 	ctmp->value     = cpystr(set_choose);
  
  	pval = PVAL(&sort_act_var, ew);
  	if(pval)
! 	  decode_sort(pval, &def_sort, &def_sort_rev, 0);
  
  	/* allow user to set their default sort order */
  	new_confline(&ctmp)->var = &sort_act_var;
***************
*** 4492,4498 ****
  	ctmp->tool	      = role_sort_tool;
  	ctmp->valoffset	      = rindent;
  	ctmp->varmem	      = -1;
! 	ctmp->value	      = generalized_sort_pretty_value(ps, ctmp, 0);
  
  	for(j = 0; j < 2; j++){
  	    for(i = 0; ps->sort_types[i] != EndofList; i++){
--- 4497,4503 ----
  	ctmp->tool	      = role_sort_tool;
  	ctmp->valoffset	      = rindent;
  	ctmp->varmem	      = -1;
! 	ctmp->value	      = generalized_sort_pretty_value(ps, ctmp, 0, 0);
  
  	for(j = 0; j < 2; j++){
  	    for(i = 0; ps->sort_types[i] != EndofList; i++){
***************
*** 4504,4510 ****
  		ctmp->valoffset	      = rindent;
  		ctmp->varmem	      = i + (j * EndofList);
  		ctmp->value	      = generalized_sort_pretty_value(ps, ctmp,
! 								      0);
  	    }
  	}
  
--- 4509,4515 ----
  		ctmp->valoffset	      = rindent;
  		ctmp->varmem	      = i + (j * EndofList);
  		ctmp->value	      = generalized_sort_pretty_value(ps, ctmp,
! 								      0, 0);
  	    }
  	}
  
***************
*** 5437,5443 ****
  	  (*result)->patgrp->stat_boy = PAT_STAT_EITHER;
  
  	if(sort_act){
! 	    decode_sort(sort_act, &def_sort, &def_sort_rev);
  	    (*result)->action->sort_is_set = 1;
  	    (*result)->action->sortorder = def_sort;
  	    (*result)->action->revsort = (def_sort_rev ? 1 : 0);
--- 5442,5448 ----
  	  (*result)->patgrp->stat_boy = PAT_STAT_EITHER;
  
  	if(sort_act){
! 	    decode_sort(sort_act, &def_sort, &def_sort_rev, 0);
  	    (*result)->action->sort_is_set = 1;
  	    (*result)->action->sortorder = def_sort;
  	    (*result)->action->revsort = (def_sort_rev ? 1 : 0);
***************
*** 7706,7711 ****
--- 7711,7721 ----
  	    if(apval)
  	      *apval = (role && role->nick) ? cpystr(role->nick) : NULL;
  
+ 	    if (ps_global->role)
+ 		fs_give((void **)&ps_global->role);
+ 	    if (role && role->nick)
+ 		ps_global->role = cpystr(role->nick);
+ 
  	    if((*cl)->value)
  	      fs_give((void **)&((*cl)->value));
  
diff -rc alpine-2.11/alpine/send.c alpine-2.11.I.USE/alpine/send.c
*** alpine-2.11/alpine/send.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/send.c	2013-12-01 16:38:56.000000000 -0700
***************
*** 63,69 ****
  #include "../pith/mimetype.h"
  #include "../pith/send.h"
  #include "../pith/smime.h"
! 
  
  typedef struct body_particulars {
      unsigned short     type, encoding, had_csp;
--- 63,69 ----
  #include "../pith/mimetype.h"
  #include "../pith/send.h"
  #include "../pith/smime.h"
! #include "../pith/rules.h"
  
  typedef struct body_particulars {
      unsigned short     type, encoding, had_csp;
***************
*** 239,244 ****
--- 239,249 ----
  	role->nick = cpystr("Default Role");
      }
  
+     if (ps_global->role)
+        fs_give((void **)&ps_global->role);  
+ 
+     ps_global->role = cpystr(role->nick);
+ 
      pine_state->redrawer = NULL;
      compose_mail(NULL, NULL, role, NULL, NULL);
      free_action(&role);
***************
*** 448,455 ****
  
  	      ps_global->next_screen = prev_screen;
  	      ps_global->redrawer = redraw;
! 	      if(role)
  		role = combine_inherited_role(role);
  	    }
  	    break;
  	  
--- 453,464 ----
  
  	      ps_global->next_screen = prev_screen;
  	      ps_global->redrawer = redraw;
! 	      if (ps_global->role)
! 		  fs_give((void **)&ps_global->role);  
! 	      if(role){
  		role = combine_inherited_role(role);
+ 		ps_global->role = cpystr(role->nick);
+ 	      }
  	    }
  	    break;
  	  
***************
*** 614,619 ****
--- 623,629 ----
          if(given_to)
  	  rfc822_parse_adrlist(&outgoing->to, given_to, ps_global->maildomain);
  
+         outgoing->subject = cpystr(ps_global->subject);
          outgoing->message_id = generate_message_id();
  
  	/*
***************
*** 644,652 ****
  	    }
  	}
  
! 	if(role)
  	  q_status_message1(SM_ORDER, 3, 4, _("Composing using role \"%s\""),
  			    role->nick);
  
  	/*
  	 * The type of storage object allocated below is vitally
--- 654,667 ----
  	    }
  	}
  
! 	if (ps_global->role)
! 	    fs_give((void **)&ps_global->role);
! 
! 	if(role){
  	  q_status_message1(SM_ORDER, 3, 4, _("Composing using role \"%s\""),
  			    role->nick);
+ 	  ps_global->role = cpystr(role->nick);
+ 	}
  
  	/*
  	 * The type of storage object allocated below is vitally
***************
*** 912,918 ****
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, KS_NONE},
    {"From    : ",  "From",        h_composer_from,       10, 0, NULL,
     build_address, NULL, NULL, addr_book_compose,    "To AddrBk", NULL, abook_nickname_complete,
!    0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, KS_TOADDRBOOK},
    {"Reply-To: ",  "Reply To",    h_composer_reply_to,   10, 0, NULL,
     build_address, NULL, NULL, addr_book_compose,    "To AddrBk", NULL, abook_nickname_complete,
     0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, KS_TOADDRBOOK},
--- 927,933 ----
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, KS_NONE},
    {"From    : ",  "From",        h_composer_from,       10, 0, NULL,
     build_address, NULL, NULL, addr_book_compose,    "To AddrBk", NULL, abook_nickname_complete,
!    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, KS_TOADDRBOOK},
    {"Reply-To: ",  "Reply To",    h_composer_reply_to,   10, 0, NULL,
     build_address, NULL, NULL, addr_book_compose,    "To AddrBk", NULL, abook_nickname_complete,
     0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, KS_TOADDRBOOK},
***************
*** 1782,1787 ****
--- 1797,1805 ----
      pbf = &pbuf1;
      standard_picobuf_setup(pbf);
  
+     pbf->auto_cmds = ps_global->initial_cmds_backup + 
+ 						ps_global->initial_cmds_offset;
+ 
      /*
       * Cancel any pending initial commands since pico uses a different
       * input routine.  If we didn't cancel them, they would happen after
***************
*** 2305,2310 ****
--- 2323,2333 ----
  			he->rich_header = 0;
  		    }
  		}
+ 		if (F_ON(F_ALLOW_CHANGING_FROM, ps_global) &&
+ 		   !ps_global->never_allow_changing_from){
+ 		  he->display_it  = 1;  /* show it */
+ 		  he->rich_header = 0;
+ 		}
  
  		he_from			= he;
  		break;
***************
*** 2414,2419 ****
--- 2437,2462 ----
  		    removing_trailing_white_space(pf->textbuf);
  		    (void)removing_double_quotes(pf->textbuf);
  		    build_address(pf->textbuf, &addr, NULL, NULL, NULL);
+ 		    if (!strncmp(pf->name,"Lcc",3) && addr && *addr){
+ 			RULE_RESULT *rule;
+ 
+   			outgoing->date = (unsigned char *) cpystr(addr);
+ 			ps_global->procid = cpystr("fwd-lcc");
+ 			rule = get_result_rule(V_FORWARD_RULES,
+ 			           FOR_COMPOSE|FOR_TRIM, outgoing);
+ 			if (rule){
+ 			    addr = cpystr(rule->result);
+ 			    removing_trailing_white_space(addr);
+ 			    (void)removing_extra_stuff(addr);
+ 			    if (rule->result)
+ 				fs_give((void **)&rule->result);
+ 				fs_give((void **)&rule);
+ 			}
+ 			fs_give((void **)&ps_global->procid);
+ 			if (outgoing->date)
+ 			    fs_give((void **)&outgoing->date);
+ 		    }   
+ 
  		    rfc822_parse_adrlist(pf->addr, addr,
  					 ps_global->maildomain);
  		    fs_give((void **)&addr);
***************
*** 2983,2989 ****
  #ifdef _WINDOWS
  	mswin_setwindowmenu (MENU_DEFAULT);
  #endif
! 	fix_windsize(ps_global);
  
  	/*
  	 * Only reinitialize signals if we didn't receive an interesting
--- 3026,3037 ----
  #ifdef _WINDOWS
  	mswin_setwindowmenu (MENU_DEFAULT);
  #endif
! 	if (ps_global->send_immediately){  
! 	   if(ps_global->free_initial_cmds_backup)
! 	      fs_give((void **)&ps_global->free_initial_cmds_backup);
! 	} 
! 	else
! 	   fix_windsize(ps_global);
  
  	/*
  	 * Only reinitialize signals if we didn't receive an interesting
***************
*** 3042,3048 ****
  	if(outgoing->return_path)
  	  mail_free_address(&outgoing->return_path);
  
! 	outgoing->return_path = rfc822_cpy_adr(outgoing->from);
  
  	/*
  	 * Don't ever believe the sender that is there.
--- 3090,3098 ----
  	if(outgoing->return_path)
  	  mail_free_address(&outgoing->return_path);
  
!         outgoing->return_path = F_ON(F_USE_DOMAIN_NAME,ps_global) 
! 				? rfc822_cpy_adr(generate_from())
! 				: rfc822_cpy_adr(outgoing->from);
  
  	/*
  	 * Don't ever believe the sender that is there.
***************
*** 3719,3728 ****
  	    if(sending_filter_requested
  	       && !filter_message_text(sending_filter_requested, outgoing,
  				       *body, &orig_so, &header)){
! 		q_status_message1(SM_ORDER, 3, 3,
  				 _("Problem filtering!  Nothing sent%s."),
  				 fcc ? " or saved to fcc" : "");
! 		continue;
  	    }
  
              /*------ Actually post  -------*/
--- 3769,3784 ----
  	    if(sending_filter_requested
  	       && !filter_message_text(sending_filter_requested, outgoing,
  				       *body, &orig_so, &header)){
! 		if (!ps_global->send_immediately){
! 		     q_status_message1(SM_ORDER, 3, 3,
  				 _("Problem filtering!  Nothing sent%s."),
  				 fcc ? " or saved to fcc" : "");
! 		     continue;
! 		}
! 		else{
! 		   fprintf(stderr, _("Problem filtering! Nothing sent or saved to Fcc\n"));
! 		   exit(-1);
! 		}
  	    }
  
              /*------ Actually post  -------*/
***************
*** 3966,3971 ****
--- 4022,4029 ----
              /*----- Mail Post FAILED, back to composer -----*/
              if(result & (P_MAIL_LOSE | P_FCC_LOSE)){
  		dprint((1, "Send failed, continuing\n"));
+ 		if (ps_global->send_immediately)
+ 		   exit(1);
  
  		if(result & P_FCC_LOSE){
  		    /*
***************
*** 4000,4005 ****
--- 4058,4064 ----
  	    update_answered_flags(reply);
  
              /*----- Signed, sealed, delivered! ------*/
+          if (!ps_global->send_immediately)
  	    q_status_message(SM_ORDER, 0, 3,
  			     pine_send_status(result, fcc, tmp_20k_buf, SIZEOF_20KBUF, NULL));
  
***************
*** 4466,4472 ****
  	return(1);
      }
  
!     if(F_ON(F_SEND_WO_CONFIRM, ps_global)){
  	if(result)
  	  *result = NULL;
  
--- 4525,4531 ----
  	return(1);
      }
  
!     if(!ps_global->send_immediately && F_ON(F_SEND_WO_CONFIRM, ps_global)){
  	if(result)
  	  *result = NULL;
  
***************
*** 4646,4652 ****
  
      opts[i].ch = -1;
  
!     fix_windsize(ps_global);
  
      while(1){
  	if(filters && filters->filter && (p = strindex(filters->filter, ' ')))
--- 4705,4712 ----
  
      opts[i].ch = -1;
  
!     if (!ps_global->send_immediately)
!        fix_windsize(ps_global);
  
      while(1){
  	if(filters && filters->filter && (p = strindex(filters->filter, ' ')))
***************
*** 4828,4834 ****
  	if(double_rad +
  	   ((call_mailer_flags & CM_DSN_SHOW)
  	       ? 4 : F_ON(F_DSN, ps_global) ? 1 : 0) > 11)
! 	  rv = double_radio_buttons(tmp_20k_buf, -FOOTER_ROWS(ps_global), opts,
  			   'y', 'z',
  			   (F_ON(F_DSN, ps_global) && allow_flowed)
  					          ? h_send_prompt_dsn_flowed :
--- 4888,4895 ----
  	if(double_rad +
  	   ((call_mailer_flags & CM_DSN_SHOW)
  	       ? 4 : F_ON(F_DSN, ps_global) ? 1 : 0) > 11)
! 	  rv = ps_global->send_immediately ? 'y' :
! 		double_radio_buttons(tmp_20k_buf, -FOOTER_ROWS(ps_global), opts,
  			   'y', 'z',
  			   (F_ON(F_DSN, ps_global) && allow_flowed)
  					          ? h_send_prompt_dsn_flowed :
***************
*** 4837,4843 ****
  						       h_send_prompt,
  			   RB_NORM);
  	else
! 	  rv = radio_buttons(tmp_20k_buf, -FOOTER_ROWS(ps_global), opts,
  			   'y', 'z',
  			   (double_rad +
  			    ((call_mailer_flags & CM_DSN_SHOW)
--- 4898,4905 ----
  						       h_send_prompt,
  			   RB_NORM);
  	else
! 	  rv = ps_global->send_immediately ? 'y' :
! 		radio_buttons(tmp_20k_buf, -FOOTER_ROWS(ps_global), opts,
  			   'y', 'z',
  			   (double_rad +
  			    ((call_mailer_flags & CM_DSN_SHOW)
***************
*** 5174,5184 ****
--- 5236,5248 ----
  	{'c', 'c', "C", N_("Confirm")},
  	{'n', 'n', "N", N_("No")},
  	{'y', 'y', "", ""},
+ 	{'t', 't', "T", N_("CounT")},
  	{-1, 0, NULL, NULL}
      };
  
      ps_global->redrawer = redraw_pico;
      fix_windsize(ps_global);
+     pbf->curpos[0] = '\0';
      
      while(1){
  	rv = radio_buttons(prompt, -FOOTER_ROWS(ps_global), opts,
***************
*** 5191,5202 ****
  	    q_status_message(SM_INFO, 1, 3, _(" Type \"C\" to cancel message "));
  	    display_message('x');
  	}
  	else
  	  break;
      }
  
      ps_global->redrawer = redraw;
!     return(rstr);
  }
  
  
--- 5255,5270 ----
  	    q_status_message(SM_INFO, 1, 3, _(" Type \"C\" to cancel message "));
  	    display_message('x');
  	}
+ 	else if(rv == 't'){
+ 	    showcpos(1,0);
+ 	    break;
+ 	}
  	else
  	  break;
      }
  
      ps_global->redrawer = redraw;
!     return(pbf->curpos[0] ? pbf->curpos : rstr);
  }
  
  
***************
*** 5300,5308 ****
  	    if((tmp_so = so_get(PicoText, NULL, EDIT_ACCESS)) != NULL){
  		gf_set_so_writec(&pc, tmp_so);
  		ps_global->mangled_screen = 1;
! 		suspend_busy_cue();
! 		ClearScreen();
! 		fflush(stdout);
  		if(tmpf){
  		    PIPE_S *fpipe;
  
--- 5368,5378 ----
  	    if((tmp_so = so_get(PicoText, NULL, EDIT_ACCESS)) != NULL){
  		gf_set_so_writec(&pc, tmp_so);
  		ps_global->mangled_screen = 1;
! 		if (!ps_global->send_immediately){
! 		   suspend_busy_cue();
! 		   ClearScreen();
! 		   fflush(stdout);
! 		}
  		if(tmpf){
  		    PIPE_S *fpipe;
  
***************
*** 5414,5421 ****
  		    set_mime_type_by_grope(b);
  		}
  
! 		ClearScreen();
! 		resume_busy_cue(0);
  	    }
  	    else
  	      errstr = "Can't create space for filtered text.";
--- 5484,5493 ----
  		    set_mime_type_by_grope(b);
  		}
  
! 		if (!ps_global->send_immediately){
! 		   ClearScreen();
! 		   resume_busy_cue(0);
! 		}
  	    }
  	    else
  	      errstr = "Can't create space for filtered text.";
***************
*** 5446,5455 ****
  	if(tmp_so)
  	  so_give(&tmp_so);
  
! 	q_status_message1(SM_ORDER | SM_DING, 3, 6, _("Problem filtering: %s"),
  			  errstr);
! 	dprint((1, "Filter FAILED: %s\n",
  	       errstr ? errstr : "?"));
      }
  
      return(errstr == NULL);
--- 5518,5533 ----
  	if(tmp_so)
  	  so_give(&tmp_so);
  
! 	if (!ps_global->send_immediately){
! 	     q_status_message1(SM_ORDER | SM_DING, 3, 6, _("Problem filtering: %s"),
  			  errstr);
! 	     dprint((1, "Filter FAILED: %s\n",
  	       errstr ? errstr : "?"));
+ 	}
+ 	else{
+ 	   fprintf(stderr, _("Filter FAILED: %s\n"), errstr ? errstr : "?");
+ 	   exit(-1);
+ 	}
      }
  
      return(errstr == NULL);
diff -rc alpine-2.11/alpine/setup.c alpine-2.11.I.USE/alpine/setup.c
*** alpine-2.11/alpine/setup.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/setup.c	2013-12-01 16:40:48.000000000 -0700
***************
*** 258,264 ****
  	    ctmpa->flags             |= CF_NOSELECT;
  	    ctmpa->value = cpystr("---  ----------------------");
  
! 	    decode_sort(pval, &def_sort, &def_sort_rev);
  
  	    for(j = 0; j < 2; j++){
  		for(i = 0; ps->sort_types[i] != EndofList; i++){
--- 258,264 ----
  	    ctmpa->flags             |= CF_NOSELECT;
  	    ctmpa->value = cpystr("---  ----------------------");
  
! 	    decode_sort(pval, &def_sort, &def_sort_rev, 0);
  
  	    for(j = 0; j < 2; j++){
  		for(i = 0; ps->sort_types[i] != EndofList; i++){
***************
*** 273,278 ****
--- 273,327 ----
  		}
  	    }
  	}
+         else if(vtmp == &ps->vars[V_THREAD_SORT_KEY]){ /* radio case */
+             SortOrder thread_def_sort;
+             int       thread_def_sort_rev, lv;
+ 
+             ctmpa->flags       |= CF_NOSELECT;
+             ctmpa->keymenu      = &config_radiobutton_keymenu;
+             ctmpa->tool         = NULL;
+ 
+             /* put a nice delimiter before list */
+             new_confline(&ctmpa)->var = NULL;
+             ctmpa->varnamep               = ctmpb;
+             ctmpa->keymenu                = &config_radiobutton_keymenu;
+             ctmpa->help                   = NO_HELP;
+             ctmpa->tool                   = radiobutton_tool;
+             ctmpa->valoffset              = 12;
+             ctmpa->flags                 |= CF_NOSELECT;
+             ctmpa->value = cpystr("Set    Thread Sort Options");
+ 
+             new_confline(&ctmpa)->var = NULL;
+             ctmpa->varnamep           = ctmpb;
+             ctmpa->keymenu            = &config_radiobutton_keymenu;
+             ctmpa->help               = NO_HELP;
+             ctmpa->tool               = radiobutton_tool;
+             ctmpa->valoffset          = 12;
+             ctmpa->flags             |= CF_NOSELECT;
+             ctmpa->value = cpystr("---  ----------------------");
+   
+             /* find longest value's name */
+             for(lv = 0, i = 0; ps->sort_types[i] != EndofList; i++)
+               if(lv < (j = strlen(sort_name(ps->sort_types[i]))))
+                 lv = j;
+ 
+             decode_sort(pval, &thread_def_sort, &thread_def_sort_rev, 1);
+ 
+             for(j = 0; j < 2; j++){
+                 for(i = 0; ps->sort_types[i] != EndofList; i++){
+ 		  if (allowed_thread_key(ps->sort_types[i])){
+                     new_confline(&ctmpa)->var = vtmp;
+                     ctmpa->varnamep           = ctmpb;
+                     ctmpa->keymenu            = &config_radiobutton_keymenu;
+                     ctmpa->help               = config_help(vtmp - ps->vars, 0);
+                     ctmpa->tool               = radiobutton_tool;
+                     ctmpa->valoffset          = 12;
+                     ctmpa->varmem             = i + (j * EndofList);
+                     ctmpa->value              = pretty_value(ps, ctmpa);
+ 		  }
+                 }
+             }
+         }
  	else if(vtmp == &ps->vars[V_USE_ONLY_DOMAIN_NAME]){ /* yesno case */
  	    ctmpa->keymenu = &config_yesno_keymenu;
  	    ctmpa->tool	   = yesno_tool;
***************
*** 335,340 ****
--- 384,390 ----
  	}
  	else{
  	    if(vtmp == &ps->vars[V_FILLCOL]
+ 	       || vtmp == &ps->vars[V_SLEEP]
  	       || vtmp == &ps->vars[V_QUOTE_SUPPRESSION]
  	       || vtmp == &ps->vars[V_OVERLAP]
  	       || vtmp == &ps->vars[V_MAXREMSTREAM]
***************
*** 464,469 ****
--- 514,528 ----
  	}
      }
  
+     pval = PVAL(&ps->vars[V_THREAD_SORT_KEY], ew);
+     if(vsave[V_THREAD_SORT_KEY].saved_user_val.p && pval
+        && strcmp(vsave[V_THREAD_SORT_KEY].saved_user_val.p, pval)){
+       if(!mn_get_mansort(ps_global->msgmap)){
+ 	  clear_index_cache(ps_global->mail_stream, 0);
+           reset_sort_order(SRT_VRB);
+       }
+     }
+ 
      treat_color_vars_as_text = 0;
      free_saved_config(ps, &vsave, expose_hidden_config);
  #ifdef _WINDOWS
diff -rc alpine-2.11/alpine/status.c alpine-2.11.I.USE/alpine/status.c
*** alpine-2.11/alpine/status.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/alpine/status.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 111,116 ****
--- 111,119 ----
      char  *clean_msg;
      size_t mlen;
  
+     if (ps_global->send_immediately)
+ 	return;
+ 
      status_message_lock();
  
      /*
***************
*** 605,610 ****
--- 608,616 ----
      SMQ_T *q, *copy_of_q;
      int ding;
  
+     if(ps_global->send_immediately)
+       return;
+ 
  start_over:
      status_message_lock();
  
diff -rc alpine-2.11/doc/alpine.1 alpine-2.11.I.USE/doc/alpine.1
*** alpine-2.11/doc/alpine.1	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/doc/alpine.1	2013-12-01 16:39:27.000000000 -0700
***************
*** 164,169 ****
--- 164,171 ----
  .IP \fB-n\ \fInumber\fR 20
  Start up with current message-number set to 
  .I number.
+ .IP \fB-noutf8\fR 20
+ Warns Alpine that piped input is not encoded in UTF-8.
  .IP \fB-o\fR 20
  Open first folder read-only.
  .IP \fB-p\ \fIconfig-file\fR 20
diff -rc alpine-2.11/imap/src/c-client/imap4r1.c alpine-2.11.I.USE/imap/src/c-client/imap4r1.c
*** alpine-2.11/imap/src/c-client/imap4r1.c	2013-08-14 22:36:13.000000000 -0600
--- alpine-2.11.I.USE/imap/src/c-client/imap4r1.c	2013-12-01 16:38:36.000000000 -0700
***************
*** 1156,1161 ****
--- 1156,1162 ----
  	}
  				/* no error if protocol-initiated cancel */
  	lsterr = cpystr (reply->text);
+ 	delete_password(mb, usr);
        }
      }
      while (LOCAL->netstream && !LOCAL->byeseen && trial &&
***************
*** 1207,1212 ****
--- 1208,1214 ----
  	if (imap_OK (stream,reply = imap_send (stream,"LOGIN",args)))
  	  ret = LONGT;		/* success */
  	else {
+ 	  delete_password(mb, usr);
  	  mm_log (reply->text,WARN);
  	  if (!LOCAL->referral && (trial == imap_maxlogintrials))
  	    mm_log ("Too many login failures",ERROR);
diff -rc alpine-2.11/imap/src/c-client/mail.c alpine-2.11.I.USE/imap/src/c-client/mail.c
*** alpine-2.11/imap/src/c-client/mail.c	2013-08-14 22:36:13.000000000 -0600
--- alpine-2.11.I.USE/imap/src/c-client/mail.c	2013-12-01 16:41:24.000000000 -0700
***************
*** 52,57 ****
--- 52,59 ----
  static rfc822out_t mail822out = NIL;
  				/* RFC-822 output generator (new style) */
  static rfc822outfull_t mail822outfull = NIL;
+ 				/* Erase password (client side) */
+ static deletepwd_t erase_password = NIL;
  				/* SMTP verbose callback */
  static smtpverbose_t mailsmtpverbose = mm_dlog;
  				/* proxy copy routine */
***************
*** 544,549 ****
--- 546,556 ----
    case GET_SENDCOMMAND:
      ret = (void *) mailsendcommand;
      break;
+   case SET_ERASEPASSWORD:
+     erase_password = (deletepwd_t) value;
+   case GET_ERASEPASSWORD:
+     ret = (void *) erase_password;
+     break;
  
    case SET_SERVICENAME:
      servicename = (char *) value;
***************
*** 991,997 ****
    MAILSTREAM *ts;
    char *s,*t,tmp[MAILTMPLEN];
    size_t i;
!   DRIVER *d;
  				/* never allow names with newlines */
    if (s = strpbrk (mailbox,"\015\012")) {
      MM_LOG ("Can't create mailbox with such a name",ERROR);
--- 998,1004 ----
    MAILSTREAM *ts;
    char *s,*t,tmp[MAILTMPLEN];
    size_t i;
!   DRIVER *d, *md;
  				/* never allow names with newlines */
    if (s = strpbrk (mailbox,"\015\012")) {
      MM_LOG ("Can't create mailbox with such a name",ERROR);
***************
*** 1015,1020 ****
--- 1022,1029 ----
      return NIL;
    }
  
+   /* Hack, we should do this better, but it works */
+     for (md = maildrivers; md && strcmp (md->name, "md"); md = md->next);
  				/* see if special driver hack */
    if ((mailbox[0] == '#') && ((mailbox[1] == 'd') || (mailbox[1] == 'D')) &&
        ((mailbox[2] == 'r') || (mailbox[2] == 'R')) &&
***************
*** 1045,1050 ****
--- 1054,1066 ----
  	   (((*mailbox == '{') || (*mailbox == '#')) &&
  	    (stream = mail_open (NIL,mailbox,OP_PROTOTYPE | OP_SILENT))))
      d = stream->dtb;
+   else if(mailbox[0] == '#'
+ 	&& (mailbox[1] == 'm' || mailbox[1] == 'M')
+ 	&& (mailbox[2] == 'd' || mailbox[2] == 'D'
+ 	    || mailbox[2] == 'c' || mailbox[2] == 'C')
+ 	&& mailbox[3] == '/'
+ 	&& mailbox[4] != '\0')
+      return (*md->create)(stream, mailbox);
    else if ((*mailbox != '{') && (ts = default_proto (NIL))) d = ts->dtb;
    else {			/* failed utterly */
      sprintf (tmp,"Can't create mailbox %.80s: indeterminate format",mailbox);
***************
*** 3352,3364 ****
  			   long flags)
  {
    STRINGLIST *hdrs;
!   int notfound;
    unsigned long i;
    char c,*s,*e,*t,tmp[MAILTMPLEN];
    char *src = text;
    char *dst = src;
    char *end = text + len;
!   text[len] = '\012';		/* guard against running off buffer */
    while (src < end) {		/* process header */
  				/* slurp header line name */
      for (s = src,e = s + MAILTMPLEN - 1,e = (e < end ? e : end),t = tmp;
--- 3368,3380 ----
  			   long flags)
  {
    STRINGLIST *hdrs;
!   int notfound, fix = text[len - 1] == '\0';
    unsigned long i;
    char c,*s,*e,*t,tmp[MAILTMPLEN];
    char *src = text;
    char *dst = src;
    char *end = text + len;
!   text[fix ? len - 1 : len] = '\012';	/* guard against running off buffer */
    while (src < end) {		/* process header */
  				/* slurp header line name */
      for (s = src,e = s + MAILTMPLEN - 1,e = (e < end ? e : end),t = tmp;
***************
*** 3397,3402 ****
--- 3413,3422 ----
      }
    }
    *dst = '\0';			/* tie off destination */
+   if(fix){
+ 	text[len] = '\012';
+ 	text[len-1] = '\0';
+   }
    return dst - text;
  }
  
***************
*** 6121,6126 ****
--- 6141,6155 ----
        return i;
    return 0;
  }
+ /* Client side callback warning to delete wrong password
+  * 
+  */
+ void delete_password(NETMBX *mb, char *user)
+ {
+   deletepwd_t ep = mail_parameters(NULL, GET_ERASEPASSWORD, NULL);
+   if (ep) (ep)(mb, user);
+ }
+ 
  
  /* Standard TCP/IP network driver */
  
diff -rc alpine-2.11/imap/src/c-client/mail.h alpine-2.11.I.USE/imap/src/c-client/mail.h
*** alpine-2.11/imap/src/c-client/mail.h	2013-08-14 22:36:13.000000000 -0600
--- alpine-2.11.I.USE/imap/src/c-client/mail.h	2013-12-01 16:38:36.000000000 -0700
***************
*** 177,182 ****
--- 177,184 ----
  #define SET_EXTERNALAUTHID (long) 230
  #define GET_SSLCAPATH (long) 231
  #define SET_SSLCAPATH (long) 232
+ #define GET_ERASEPASSWORD (long) 233
+ #define SET_ERASEPASSWORD (long) 234
  
  	/* 3xx: TCP/IP */
  #define GET_OPENTIMEOUT (long) 300
***************
*** 353,358 ****
--- 355,364 ----
  #define SET_SCANCONTENTS (long) 573
  #define GET_MHALLOWINBOX (long) 574
  #define SET_MHALLOWINBOX (long) 575
+ #define GET_COURIERSTYLE (long) 576
+ #define SET_COURIERSTYLE (long) 577
+ #define SET_MDINBOXPATH  (long) 578
+ #define GET_MDINBOXPATH  (long) 579
  
  /* Driver flags */
  
***************
*** 1326,1331 ****
--- 1332,1338 ----
  typedef void *(*blocknotify_t) (int reason,void *data);
  typedef long (*kinit_t) (char *host,char *reason);
  typedef void (*sendcommand_t) (MAILSTREAM *stream,char *cmd,long flags);
+ typedef void (*deletepwd_t) (NETMBX *mb,char *user);
  typedef char *(*newsrcquery_t) (MAILSTREAM *stream,char *mulname,char *name);
  typedef void (*getacl_t) (MAILSTREAM *stream,char *mailbox,ACLLIST *acl);
  typedef void (*listrights_t) (MAILSTREAM *stream,char *mailbox,char *id,
***************
*** 1605,1610 ****
--- 1612,1619 ----
  void mm_fatal (char *string);
  void *mm_cache (MAILSTREAM *stream,unsigned long msgno,long op);
  
+ void delete_password (NETMBX *mb, char *user);
+ 
  extern STRINGDRIVER mail_string;
  void mail_versioncheck (char *version);
  void mail_link (DRIVER *driver);
diff -rc alpine-2.11/imap/src/c-client/nntp.c alpine-2.11.I.USE/imap/src/c-client/nntp.c
*** alpine-2.11/imap/src/c-client/nntp.c	2013-08-14 22:36:13.000000000 -0600
--- alpine-2.11.I.USE/imap/src/c-client/nntp.c	2013-12-01 16:38:36.000000000 -0700
***************
*** 2031,2036 ****
--- 2031,2037 ----
        sprintf (tmp,"Retrying using %s authentication after %.80s",
  	       at->name,lsterr);
        mm_log (tmp,NIL);
+       delete_password(mb, mb ? mb->user : NULL);
        fs_give ((void **) &lsterr);
      }
      trial = 0;			/* initial trial count */
***************
*** 2039,2044 ****
--- 2040,2046 ----
        if (lsterr) {
  	sprintf (tmp,"Retrying %s authentication after %.80s",at->name,lsterr);
  	mm_log (tmp,WARN);
+ 	delete_password(mb, mb ? mb->user : NULL);
  	fs_give ((void **) &lsterr);
        }
        stream->saslcancel = NIL;
***************
*** 2064,2069 ****
--- 2066,2072 ----
        sprintf (tmp,"Can not authenticate to NNTP server: %.80s",lsterr);
        mm_log (tmp,ERROR);
      }
+     delete_password(mb, mb ? mb->user : NULL);
      fs_give ((void **) &lsterr);
    }
    else if (mb->secflag)		/* no SASL, can't do /secure */
***************
*** 2092,2097 ****
--- 2095,2102 ----
        stream->sensitive = T;	/* hide this command */
        if (nntp_send_work (stream,"AUTHINFO PASS",pwd) == NNTPAUTHED)
  	ret = LONGT;		/* password OK */
+       else
+         delete_password(mb, mb ? mb->user : NULL);
        stream->sensitive = NIL;	/* unhide */
        if (ret) break;		/* OK if successful */
      default:			/* authentication failed */
diff -rc alpine-2.11/imap/src/c-client/pop3.c alpine-2.11.I.USE/imap/src/c-client/pop3.c
*** alpine-2.11/imap/src/c-client/pop3.c	2013-08-14 22:36:13.000000000 -0600
--- alpine-2.11.I.USE/imap/src/c-client/pop3.c	2013-12-01 16:38:36.000000000 -0700
***************
*** 615,620 ****
--- 615,621 ----
  	sprintf (pwd,"Retrying using %.80s authentication after %.80s",
  		 at->name,t);
  	mm_log (pwd,NIL);
+ 	delete_password(mb, usr);
  	fs_give ((void **) &t);
        }
        trial = 0;		/* initial trial count */
***************
*** 622,627 ****
--- 623,629 ----
  	if (t) {
  	  sprintf (pwd,"Retrying %s authentication after %.80s",at->name,t);
  	  mm_log (pwd,WARN);
+ 	  delete_password(mb, usr);
  	  fs_give ((void **) &t);
  	}
  	LOCAL->saslcancel = NIL;
***************
*** 667,672 ****
--- 669,675 ----
  	  LOCAL->sensitive=NIL;	/* unhide */
  	}
  	if (!ret) {		/* failure */
+ 	  delete_password(mb, usr);
  	  mm_log (LOCAL->reply,WARN);
  	  if (trial == pop3_maxlogintrials)
  	    mm_log ("Too many login failures",ERROR);
diff -rc alpine-2.11/imap/src/osdep/unix/dummy.c alpine-2.11.I.USE/imap/src/osdep/unix/dummy.c
*** alpine-2.11/imap/src/osdep/unix/dummy.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/imap/src/osdep/unix/dummy.c	2013-12-01 16:34:08.000000000 -0700
***************
*** 106,118 ****
   * Accepts: mailbox name
   * Returns: our driver if name is valid, NIL otherwise
   */
! 
  DRIVER *dummy_valid (char *name)
  {
!   char *s,tmp[MAILTMPLEN];
    struct stat sbuf;
  				/* must be valid local mailbox */
!   if (name && *name && (*name != '{') && (s = mailboxfile (tmp,name))) {
  				/* indeterminate clearbox INBOX */
      if (!*s) return &dummydriver;
      else if (!stat (s,&sbuf)) switch (sbuf.st_mode & S_IFMT) {
--- 106,124 ----
   * Accepts: mailbox name
   * Returns: our driver if name is valid, NIL otherwise
   */
! char * maildir_remove_root(char *);
  DRIVER *dummy_valid (char *name)
  {
!   char *s,tmp[MAILTMPLEN], *rname;
    struct stat sbuf;
+ 
+   if(strlen(name) > MAILTMPLEN)
+    name[MAILTMPLEN] = '\0';
+ 
+   strcpy(tmp, name);
+   rname = maildir_remove_root(tmp);
  				/* must be valid local mailbox */
!   if (rname && *rname && (*rname != '{') && (s = mailboxfile (tmp,rname))) {
  				/* indeterminate clearbox INBOX */
      if (!*s) return &dummydriver;
      else if (!stat (s,&sbuf)) switch (sbuf.st_mode & S_IFMT) {
***************
*** 121,128 ****
        return &dummydriver;
      }
  				/* blackbox INBOX does not exist yet */
!     else if (!compare_cstring (name,"INBOX")) return &dummydriver;
    }
    return NIL;
  }
  
--- 127,135 ----
        return &dummydriver;
      }
  				/* blackbox INBOX does not exist yet */
!     else if (!compare_cstring (rname,"INBOX")) return &dummydriver;
    }
+   if(rname) fs_give((void **)&rname);
    return NIL;
  }
  
***************
*** 454,459 ****
--- 461,468 ----
  {
    char *s,tmp[MAILTMPLEN];
    long ret = NIL;
+   if(!strncmp(mailbox,"#md/",4) || !strncmp(mailbox,"#mc/", 4))
+     return maildir_create(stream, mailbox);
  				/* validate name */
    if (!(compare_cstring (mailbox,"INBOX") && (s = dummy_file (tmp,mailbox)))) {
      sprintf (tmp,"Can't create %.80s: invalid name",mailbox);
***************
*** 519,524 ****
--- 528,541 ----
  {
    struct stat sbuf;
    char *s,tmp[MAILTMPLEN];
+   if (!strncmp(mailbox,"#md/",4) || !strncmp(mailbox,"#mc/", 4) 
+ 	|| is_valid_maildir(&mailbox)){
+     char tmp[MAILTMPLEN] = {'\0'};
+     strcpy(tmp, mailbox);
+     if(tmp[strlen(tmp) - 1] != '/')
+        tmp[strlen(tmp)] = '/';
+      return maildir_delete(stream, tmp);
+   }
    if (!(s = dummy_file (tmp,mailbox))) {
      sprintf (tmp,"Can't delete - invalid name: %.80s",s);
      MM_LOG (tmp,ERROR);
***************
*** 544,555 ****
  long dummy_rename (MAILSTREAM *stream,char *old,char *newname)
  {
    struct stat sbuf;
!   char c,*s,tmp[MAILTMPLEN],mbx[MAILTMPLEN],oldname[MAILTMPLEN];
  				/* no trailing / allowed */
!   if (!dummy_file (oldname,old) || !(s = dummy_file (mbx,newname)) ||
        stat (oldname,&sbuf) || ((s = strrchr (s,'/')) && !s[1] &&
  			       ((sbuf.st_mode & S_IFMT) != S_IFDIR))) {
!     sprintf (mbx,"Can't rename %.80s to %.80s: invalid name",old,newname);
      MM_LOG (mbx,ERROR);
      return NIL;
    }
--- 561,583 ----
  long dummy_rename (MAILSTREAM *stream,char *old,char *newname)
  {
    struct stat sbuf;
!   char c,*s,tmp[MAILTMPLEN],mbx[MAILTMPLEN],oldname[MAILTMPLEN], *rold, *rnewname;
! 
!   if(strlen(old) > MAILTMPLEN)
!     old[MAILTMPLEN] = '\0';
! 
!   if(strlen(newname) > MAILTMPLEN)
!     newname[MAILTMPLEN] = '\0';
! 
!   strcpy(tmp, old);
!   rold = maildir_remove_root(tmp);
!   strcpy(tmp, newname);
!   rnewname = maildir_remove_root(tmp);
  				/* no trailing / allowed */
!   if (!dummy_file (oldname,rold) || !(s = dummy_file (mbx,rnewname)) ||
        stat (oldname,&sbuf) || ((s = strrchr (s,'/')) && !s[1] &&
  			       ((sbuf.st_mode & S_IFMT) != S_IFDIR))) {
!     sprintf (mbx,"Can't rename %.80s to %.80s: invalid name",rold,rnewname);
      MM_LOG (mbx,ERROR);
      return NIL;
    }
***************
*** 565,578 ****
      }
    }
  				/* rename of non-ex INBOX creates dest */
!   if (!compare_cstring (old,"INBOX") && stat (oldname,&sbuf))
      return dummy_create (NIL,mbx);
    if (rename (oldname,mbx)) {
!     sprintf (tmp,"Can't rename mailbox %.80s to %.80s: %.80s",old,newname,
  	     strerror (errno));
      MM_LOG (tmp,ERROR);
      return NIL;
    }
    return T;			/* return success */
  }
  
--- 593,608 ----
      }
    }
  				/* rename of non-ex INBOX creates dest */
!   if (!compare_cstring (rold,"INBOX") && stat (oldname,&sbuf))
      return dummy_create (NIL,mbx);
    if (rename (oldname,mbx)) {
!     sprintf (tmp,"Can't rename mailbox %.80s to %.80s: %.80s",rold,rnewname,
  	     strerror (errno));
      MM_LOG (tmp,ERROR);
      return NIL;
    }
+   if(rold) fs_give((void **)&rold);
+   if(rnewname) fs_give((void **)&rnewname);
    return T;			/* return success */
  }
  
diff -rc alpine-2.11/imap/src/osdep/unix/maildir.c alpine-2.11.I.USE/imap/src/osdep/unix/maildir.c
*** alpine-2.11/imap/src/osdep/unix/maildir.c	2013-12-01 16:41:34.000000000 -0700
--- alpine-2.11.I.USE/imap/src/osdep/unix/maildir.c	2013-12-01 16:34:08.000000000 -0700
***************
*** 0 ****
--- 1,2638 ----
+ /*
+  * Maildir driver for Alpine 2.00
+  * 
+  * Written by Eduardo Chappa <chappa@gmx.com>
+  * Last Update: May 29, 2011.
+  *
+  */
+ 
+ #include <stdio.h>
+ #include <ctype.h>
+ #include <errno.h>
+ extern int errno;		/* just in case */
+ #include "mail.h"
+ #include <pwd.h>
+ #include <sys/stat.h>
+ #include <sys/time.h>
+ #include "osdep.h"
+ #include "rfc822.h"
+ #include "fdstring.h"
+ #include "misc.h"
+ #include "dummy.h"
+ #include "maildir.h"
+ 
+ /* Driver dispatch used by MAIL */
+ DRIVER maildirdriver = {
+   "md",				/* driver name, yes it's md, not maildir */
+   DR_MAIL|DR_LOCAL|DR_NAMESPACE|DR_DIRFMT,		/* driver flags */
+   (DRIVER *) NIL,		/* next driver 				*/
+   maildir_valid,		/* mailbox is valid for us 		*/
+   maildir_parameters,		/* manipulate parameters		*/
+   NIL,				/* scan mailboxes 			*/
+   maildir_list,			/* find mailboxes 			*/
+   maildir_lsub,			/* find subscribed mailboxes 		*/
+   maildir_sub,			/* subscribe to mailbox 		*/
+   maildir_unsub,		/* unsubscribe from mailbox 		*/
+   maildir_create,		/* create mailbox 			*/
+   maildir_delete,		/* delete mailbox 			*/
+   maildir_rename,		/* rename mailbox 			*/
+   mail_status_default,		/* status of mailbox 			*/
+   maildir_open,			/* open mailbox				*/
+   maildir_close,		/* close mailbox 			*/
+   maildir_fast,			/* fetch message "fast" attributes	*/
+   NIL,				/* fetch message flags 			*/
+   NIL,				/* fetch overview 			*/
+   NIL,				/* fetch message structure 		*/
+   maildir_header,		/* fetch message header 		*/
+   maildir_text,			/* fetch message body 			*/
+   NIL,				/* fetch partial message text 		*/
+   NIL,				/* unique identifier 			*/
+   NIL,				/* message number 			*/
+   NIL,				/* modify flags 			*/
+   maildir_flagmsg,		/* per-message modify flags 		*/
+   NIL,				/* search for message based on criteria */
+   NIL,				/* sort messages 			*/
+   NIL,				/* thread messages 			*/
+   maildir_ping,			/* ping mailbox to see if still alive 	*/
+   maildir_check,		/* check for new messages		*/
+   maildir_expunge,		/* expunge deleted messages 		*/
+   maildir_copy,			/* copy messages to another mailbox 	*/
+   maildir_append,		/* append string message to mailbox 	*/
+   NIL				/* garbage collect stream 		*/
+ };
+ 
+ 
+ DRIVER courierdriver = {
+   "mc",	/* Why a separate driver? So that createproto will work		*/
+   DR_MAIL|DR_LOCAL|DR_NAMESPACE|DR_DIRFMT,		/* driver flags */
+   (DRIVER *) NIL,		/* next driver 				*/
+   maildir_valid,		/* mailbox is valid for us 		*/
+   maildir_parameters,		/* manipulate parameters		*/
+   NIL,				/* scan mailboxes 			*/
+   courier_list,			/* find mailboxes 			*/
+   maildir_lsub,			/* find subscribed mailboxes 		*/
+   maildir_sub,			/* subscribe to mailbox 		*/
+   maildir_unsub,		/* unsubscribe from mailbox 		*/
+   maildir_create,		/* create mailbox 			*/
+   maildir_delete,		/* delete mailbox 			*/
+   maildir_rename,		/* rename mailbox 			*/
+   mail_status_default,		/* status of mailbox 			*/
+   maildir_open,			/* open mailbox				*/
+   maildir_close,		/* close mailbox 			*/
+   maildir_fast,			/* fetch message "fast" attributes	*/
+   NIL,				/* fetch message flags 			*/
+   NIL,				/* fetch overview 			*/
+   NIL,				/* fetch message structure 		*/
+   maildir_header,		/* fetch message header 		*/
+   maildir_text,			/* fetch message body 			*/
+   NIL,				/* fetch partial message text 		*/
+   NIL,				/* unique identifier 			*/
+   NIL,				/* message number 			*/
+   NIL,				/* modify flags 			*/
+   maildir_flagmsg,		/* per-message modify flags 		*/
+   NIL,				/* search for message based on criteria */
+   NIL,				/* sort messages 			*/
+   NIL,				/* thread messages 			*/
+   maildir_ping,			/* ping mailbox to see if still alive 	*/
+   maildir_check,		/* check for new messages		*/
+   maildir_expunge,		/* expunge deleted messages 		*/
+   maildir_copy,			/* copy messages to another mailbox 	*/
+   maildir_append,		/* append string message to mailbox 	*/
+   NIL				/* garbage collect stream 		*/
+ };
+ 
+ MAILSTREAM maildirproto = {&maildirdriver};	/* prototype stream */
+ MAILSTREAM courierproto = {&courierdriver};	/* prototype stream */
+ 
+ long maildir_dirfmttest (char *name)
+ {
+   int i;
+   for (i = 0; mdstruct[i] && strcmp(name, mdstruct[i]); i++);
+   return (i < EndDir) || !strcmp(name, MDDIR) 
+ 	|| !strncmp(name, MDUIDLAST, strlen(MDUIDLAST))
+ 	|| !strncmp(name, MDUIDTEMP, strlen(MDUIDTEMP)) ? LONGT : NIL;
+ }
+ 
+ void 
+ md_domain_name(void)
+ {
+    int i, j;
+ 
+    strcpy(mdlocaldomain, mylocalhost ());
+    for (i = 0; mdlocaldomain[i] != '\0' ;)
+       if(mdlocaldomain[i] == '/' || mdlocaldomain[i] == ':'){
+ 	 for(j = strlen(mdlocaldomain); j >= i; j--)
+ 	    mdlocaldomain[j+4] = mdlocaldomain[j];
+ 	 mdlocaldomain[i++] = '\\';
+ 	 mdlocaldomain[i++] = '0';
+ 	 if(mdlocaldomain[i] == '/'){
+ 	    mdlocaldomain[i++] = '5';
+ 	    mdlocaldomain[i++] = '7';
+ 	 } else {
+ 	    mdlocaldomain[i++] = '7';
+ 	    mdlocaldomain[i++] = '2';
+ 	 }
+       }
+       else
+ 	i++;
+ }
+ 
+ char *
+ myrootdir(char *name)
+ {
+ return myhomedir();
+ }
+ 
+ char *
+ mdirpath(void)
+ {
+   char *path = maildir_parameters(GET_MDINBOXPATH, NIL);
+   return path ? (path[0] ? path : ".") : "Maildir";
+ }
+ 
+ /* remove the "#md/" or "#mc/" part from a folder name
+  * memory freed by caller
+  */
+ char *
+ maildir_remove_root (char *name)
+ {
+   int courier = IS_COURIER(name), offset;
+   char realname[MAILTMPLEN];
+ 
+   offset = maildir_valid_name(name) ? (name[3] == '/' ? 4 : 3) : 0;
+   if(courier)
+      courier_realname(name+offset, realname);
+   else
+      strcpy(realname, name+offset);
+   return cpystr(realname);
+ }
+ 
+ 
+ /* Check validity of the name, we accept:
+  *	a) #md/directory/folder
+  *	b) #md/inbox
+  * A few considerations: We can only accept as valid
+  *  a) names that start with #md/ and the directory exists or
+  *  b) names that do not start with #md/ but are maildir directories (have
+  *     the /cur, /tmp and /new structure)
+  */
+ int maildir_valid_name (char *name)
+ {
+   char tmpname[MAILTMPLEN] = {'\0'};
+ 
+    if (mdfpath)
+       fs_give((void **)&mdfpath);
+    if (name && (name[0] != '#'))
+ 	snprintf(tmpname, sizeof(tmpname), "%s%s",MDPREFIX(CCLIENT), name);
+    mdfpath = cpystr(tmpname[0] ? tmpname : name);
+ 
+   return IS_CCLIENT(name) || IS_COURIER(name);
+ }
+ 
+ /* Check if the directory whose path is given by name is a valid maildir
+  *  directory (contains /cur, /tmp and /new)
+  */
+ int maildir_valid_dir (char *name)
+ {
+  int len;
+  DirNamesType i;
+  struct stat sbuf;
+  char tmp[MAILTMPLEN];
+ 
+    if(name[strlen(name) - 1] == '/')
+       name[strlen(name) - 1] = '\0';
+    len = strlen(name);
+    for (i = Cur; i != EndDir; i++){
+       MDFLD(tmp, name, i);
+       if (stat(tmp, &sbuf) < 0 || !S_ISDIR(sbuf.st_mode))
+ 	  break;
+    }
+    name[len] = '\0';
+    return (i == EndDir) ? T : NIL;
+ }
+ 
+ void courier_realname(char *name, char *realname)
+ {
+   int i,j;
+ 
+   if(!name)
+     return;
+ 
+   for (i = 0, j = 0; i < MAILTMPLEN && j < strlen(name); j++, i++){
+       realname[i] = name[j];
+       if(name[j] == '/' && name[j+1] != '.' && name[j+1] != '%' 
+ 		&& name[j+1] != '*') 
+ 	realname[++i] = '.';
+   }
+   if(realname[i-1] == '.')
+     i--; 
+   realname[i] = '\0';
+ }
+ 
+ 
+ /* given a maildir folder, return its path. Memory freed by caller. Directory
+  * does not contain the trailing slash "/". On error NULL is returned.
+  */
+ int maildir_file_path (char *name, char *tmp, size_t sizeoftmp)
+ {
+    char *maildirpath = mdirpath(), *rname;
+    int courier = IS_COURIER(name);
+ 
+    /* There are several ways in which the path can come, so we will handle 
+       them here. First we deal with #mc/ or #md/ prefix by removing the 
+       prefix, if any */
+ 
+     if(strlen(name) >= MAILTMPLEN)
+       name[MAILTMPLEN] = '\0';
+     strcpy(tmp, name);
+     rname = maildir_remove_root(tmp);
+     tmp[0] = '\0';	/* just in case something fails */
+ 
+     if (strlen(myrootdir(rname)) + 
+ 		max(strlen(rname), strlen(maildirpath)) > sizeoftmp){
+ 	errno = ENAMETOOLONG;
+ 	snprintf(tmp, sizeoftmp, "Error opening \"%s\": %s", rname, strerror (errno));
+ 	mm_log(tmp,ERROR);
+ 	if(rname) fs_give((void **)&rname);
+ 	return NIL;
+     }
+ 
+     /* There are two ways in which the name can come here, either as a 
+        full path or not. If it is not a full path it can come in two ways, 
+        either as a file system path (Maildir/.Drafts) or as a maildir path 
+        (INBOX.Drafts)
+      */
+ 
+      if(*rname == '/'){	/* full path */
+ 	strncpy(tmp, rname, sizeoftmp); /* do nothing */
+ 	tmp[sizeoftmp-1] = '\0';
+      }
+      else
+ 	snprintf (tmp, sizeoftmp, "%s/%s%s%s", myrootdir (rname),
+ 	    strncmp (ucase (strcpy (tmp, rname)), "INBOX", 5) 
+ 		? rname : maildirpath,
+ 	    strncmp (ucase (strcpy (tmp, rname)), "INBOX", 5) 
+ 		? "" : (courier ? "/" : ""),
+ 	    strncmp (ucase (strcpy (tmp, rname)), "INBOX", 5) 
+ 		? "" : (*(rname+5) == MDSEPARATOR(courier) ? rname+5 : ""));
+     if(rname) fs_give((void **)&rname);
+     return tmp[0] ? T : NIL;
+ }
+ 
+ /* This function is given a full path for a mailbox and returns
+  * if it is a valid maildir transformed to canonical notation
+  */
+ int
+ is_valid_maildir (char **name)
+ {
+   if (!strncmp(*name, myrootdir (*name), strlen(myrootdir(*name)))){
+      (*name) += strlen(myrootdir(*name));
+      if (**name == '/') (*name)++;
+   }
+   return maildir_valid(*name) ? T :  NIL;
+ }
+ 
+ /* Check validity of mailbox. This routine does not send errors to log, other
+  *  routines calling this one may do so, though
+  */ 
+ 
+ DRIVER *maildir_valid (char *name)
+ {
+    char tmpname[MAILTMPLEN];
+ 
+    maildir_file_path(name, tmpname, sizeof(tmpname));
+    
+    return maildir_valid_dir(tmpname) 
+ 		? (IS_COURIER(name) ? &courierdriver : &maildirdriver) : NIL;
+ }
+ 
+ void maildir_fast (MAILSTREAM *stream,char *sequence,long flags)
+ {
+   unsigned long i;
+   MESSAGECACHE *elt;
+                                 /* get sequence */
+   if (stream && LOCAL && ((flags & FT_UID) ?
+                           mail_uid_sequence (stream,sequence) :
+                           mail_sequence (stream,sequence)))
+     for (i = 1L; i <= stream->nmsgs; i++) {
+       if ((elt = mail_elt (stream,i))->sequence && (elt->valid = T) &&
+           !(elt->day && elt->rfc822_size)) {
+         ENVELOPE **env = NIL;
+         ENVELOPE *e = NIL;
+         if (!stream->scache) env = &elt->private.msg.env;
+         else if (stream->msgno == i) env = &stream->env;
+         else env = &e;
+         if (!*env || !elt->rfc822_size) {
+           STRING bs;
+           unsigned long hs;
+           char *ht = (*stream->dtb->header) (stream,i,&hs,NIL);
+ 
+           if (!*env) rfc822_parse_msg (env,NIL,ht,hs,NIL,BADHOST,
+                                        stream->dtb->flags);
+           if (!elt->rfc822_size) {
+             (*stream->dtb->text) (stream,i,&bs,FT_PEEK);
+             elt->rfc822_size = hs + SIZE (&bs) - GETPOS (&bs);
+           }
+         }
+ 
+         if (!elt->day && *env && (*env)->date)
+           mail_parse_date (elt,(*env)->date);
+ 
+         if (!elt->day) elt->day = elt->month = 1;
+         mail_free_envelope (&e);
+       }
+     }
+ }
+ 
+ int
+ maildir_eliminate_duplicate (char *name, struct direct ***flist, unsigned long *nfiles)
+ {
+    int i, j, k, error = 0, scanr;
+    char new[MAILTMPLEN], old[MAILTMPLEN], tmp[MAILTMPLEN], *str;
+    struct direct **names = NIL;
+ 
+    if((scanr = maildir_doscandir(name, &names, CCLIENT)) < 0)
+      return -1;
+ 
+    if(nfiles) *nfiles = scanr;
+    for(i = 0, j = 1, k = 0;  j < scanr; i++, j++){
+       if(k)
+ 	names[i] = names[i+k];
+       if(same_maildir_file(names[i]->d_name, names[j]->d_name)){
+ 	int d, f, r, s;
+ 	maildir_getflag(names[i]->d_name, &d, &f, &r, &s, NIL);
+ 	snprintf(old, sizeof(old), "%s/%s", name, names[i]->d_name);
+ 	snprintf(new, sizeof(new), "%s/.%s", name, names[i]->d_name);
+ 	if(rename(old, new) < 0 && errno != EEXIST)
+ 	  error++;
+ 	if(!error){
+ 	  for(; j < scanr
+ 		&& same_maildir_file(names[i]->d_name, names[j]->d_name)
+ 	      ; j++, k++){
+ 	      maildir_getflag(names[j]->d_name, (d ? NIL : &d), 
+ 			(f ? NIL : &f), (r ? NIL : &r), (s ? NIL : &s), NIL);
+ 	      snprintf(tmp, sizeof(tmp), "%s/%s", name, names[j]->d_name);
+ 	      if(unlink(tmp) < 0){	/* Hmmm... a problem, let's see */
+ 		struct stat sbuf;
+ 		if (stat(tmp, &sbuf) == 0 && (sbuf.st_mode & S_IFMT) == S_IFREG)
+ 		   error++;
+ 	      }
+ 	  }
+ 	  if((str = strrchr(names[i]->d_name,FLAGSEP)) != NULL) *str = '\0';
+ 	  snprintf (old, sizeof(old), "%s/%s%s%s%s%s%s", name, names[i]->d_name, MDSEP(2),
+ 		MDFLAG(Draft, d), MDFLAG(Flagged, f), MDFLAG(Replied, r), 
+ 		MDFLAG(Seen, s));
+ 	  if(rename(new, old) < 0)
+ 	     error++;
+ 	}
+       }
+ 
+    }
+    if(k > 0)
+      fs_give((void **)&names);
+    else
+      *flist = names;
+    return error ? -1 : k;
+ }
+ 
+ int
+ maildir_doscandir(char *name, struct direct ***flist, int flag)
+ {
+ return scandir(name, flist, 
+ 		flag == CCLIENT ? maildir_select : courier_dir_select, 
+ 		flag == CCLIENT ? maildir_namesort : courier_dir_sort);
+ }
+ 
+ /* 
+  * return all files in a given directory. This is a separate call
+  * so that if there are warnings during compilation this only appears once.
+  */
+ unsigned long
+ maildir_scandir (char *name, struct direct ***flist, 
+ 			unsigned long *nfiles, int *scand, int flag)
+ {
+   struct stat sbuf;
+   int rv = -2;	/* impossible value */
+ 
+   if (scand)
+      *scand = -1;	/* assume error for safety */
+   *nfiles = 0;
+   if((stat(name,&sbuf) < 0) 
+ 	|| (flag == CCLIENT
+ 	 && ((rv = maildir_eliminate_duplicate(name, flist, nfiles)) < 0)))
+      return 0L;
+ 
+   if (scand && (rv > 0 || rv == -2))
+      *nfiles = maildir_doscandir(name, flist, flag);
+ 
+   if(scand) *scand = *nfiles;
+ 
+   return (unsigned long) sbuf.st_ctime;
+ }
+ 
+ /* Does a message with given name exists (or was it removed)?
+  * Returns: 1 - yes, such message exist,
+  *	    0 - No, that message does not exist anymore
+  *
+  * Parameters: stream, name of mailbox, new name if his message does not
+  *		exist.
+  */
+ 
+ int maildir_message_exists(MAILSTREAM *stream, char *name, char *newfile)
+ {
+   char tmp[MAILTMPLEN];
+   int gotit = NIL;
+   DIR *dir;
+   struct direct *d;
+   struct stat sbuf;
+ 
+   /* First check directly if it exists, if not there, look for it */
+   snprintf(tmp, sizeof(tmp), "%s/%s", LOCAL->path[Cur], name);
+   if ((stat(tmp, &sbuf) == 0) && ((sbuf.st_mode & S_IFMT) == S_IFREG))
+     return T;
+ 
+   if (!(dir = opendir (LOCAL->path[Cur])))
+      return NIL;
+ 
+   while ((d = readdir(dir)) && gotit == NIL){
+     if (d->d_name[0] == '.')
+       continue;
+     if (same_maildir_file(d->d_name, name)){
+ 	  gotit = T;
+ 	  strcpy(newfile, d->d_name);
+     }
+   }
+   closedir(dir);
+   return gotit;
+ }
+ 
+ /* Maildir open */
+  
+ MAILSTREAM *maildir_open (MAILSTREAM *stream)
+ {
+   char tmp[MAILTMPLEN];
+   struct stat sbuf;
+ 
+   if (!stream) return &maildirproto;
+   if (stream->local) fatal ("maildir recycle stream");
+   md_domain_name();    /* get domain name for maildir files in mdlocaldomain */
+   if(mypid == (pid_t) 0)
+     mypid = getpid();
+   if (!stream->rdonly){
+      stream->perm_seen = stream->perm_deleted = stream->perm_flagged = 
+ 	stream->perm_answered = stream->perm_draft = T;
+   }
+   stream->local = (MAILDIRLOCAL *) fs_get (sizeof (MAILDIRLOCAL));
+   memset(LOCAL, 0, sizeof(MAILDIRLOCAL));
+   LOCAL->fd = -1;
+ 
+   LOCAL->courier = IS_COURIER(stream->mailbox);
+   strcpy(tmp, stream->mailbox);
+   if (maildir_file_path (stream->mailbox, tmp, sizeof(tmp)))
+      LOCAL->dir = cpystr (tmp);
+   LOCAL->candouid = maildir_can_assign_uid(stream);
+   maildir_read_uid(stream, &stream->uid_last, &stream->uid_validity);
+   if (LOCAL->dir){
+      LOCAL->path = (char **) fs_get(EndDir*sizeof(char *));
+      MDFLD(tmp, LOCAL->dir, Cur); LOCAL->path[Cur] = cpystr (tmp);
+      MDFLD(tmp, LOCAL->dir, New); LOCAL->path[New] = cpystr (tmp);
+      MDFLD(tmp, LOCAL->dir, Tmp); LOCAL->path[Tmp] = cpystr (tmp);
+      if (stat (LOCAL->path[Cur],&sbuf) < 0) {
+          snprintf (tmp, sizeof(tmp), "Can't open folder %s: %s",
+ 				stream->mailbox,strerror (errno));
+          mm_log (tmp,ERROR);
+ 	 maildir_close(stream, 0);
+         return NIL;
+      }
+   }
+ 
+   if(maildir_file_path (stream->mailbox, tmp, sizeof(tmp))){
+     fs_give ((void **) &stream->mailbox);
+     stream->mailbox = cpystr(tmp);
+   }
+ 
+   LOCAL->buf = (char *) fs_get (CHUNKSIZE);
+   LOCAL->buflen = CHUNKSIZE - 1;
+   stream->sequence++;
+   stream->nmsgs = stream->recent = 0L;
+ 
+   maildir_parse_folder(stream, 1);
+ 
+   return stream;
+ }
+ 
+ /* Maildir initial parsing of the folder */
+ void
+ maildir_parse_folder (MAILSTREAM *stream, int full)
+ {
+    char tmp[MAILTMPLEN];
+    struct direct **namescur = NIL, **namesnew = NIL;
+    unsigned long i, nfilescur = 0L, nfilesnew = 0L, oldpos, newpos, total;
+    int scan_err, rescan, loop = 0;
+ 
+    if (!stream)		/* what??? */
+       return;
+ 
+    MM_CRITICAL(stream);
+ 
+    maildir_scandir (LOCAL->path[New], &namesnew, &nfilesnew, &scan_err, CCLIENT);
+    if (scan_err < 0)
+       maildir_abort(stream);
+ 
+    /* Scan old messages first, escoba! */
+    if(stream->rdonly ||
+       (LOCAL && ((maildir_initial_check(stream, Cur) == 0)
+ 							|| nfilesnew > 0L))){
+       LOCAL->scantime =  maildir_scandir (LOCAL->path[Cur], &namescur, &nfilescur, 
+ 					&scan_err, CCLIENT);
+       if (scan_err < 0){
+ 	if(namesnew){
+ 	  for(i = 0L; i < nfilesnew; i++)
+ 	    fs_give((void **)&namesnew[i]);
+ 	  fs_give((void **) &namesnew);
+ 	}
+ 	maildir_abort(stream);
+       }
+    }
+    if(LOCAL && (maildir_initial_check(stream, New) == 0)
+ 	&& (nfilescur > 0L)){
+       while(LOCAL && loop < 10){
+ 	 if(nfilesnew == 0L)
+ 	   maildir_scandir (LOCAL->path[New], &namesnew, &nfilesnew, &scan_err, CCLIENT);
+          if (scan_err < 0){
+ 	    if(namesnew){
+ 	      for(i = 0L; i < nfilesnew; i++)
+ 		fs_give((void **)&namesnew[i]);
+ 	      fs_give((void **) &namesnew);
+ 	    }
+ 	    maildir_abort(stream);
+ 	    break;
+ 	 }
+ 	 for(i = 0L, rescan = 0, newpos = oldpos = 0L; 
+ 		newpos < nfilescur && i < nfilesnew; i++){
+ 	    if(maildir_message_in_list(namesnew[i]->d_name, namescur, oldpos, 
+ 						nfilescur - 1L, &newpos)){
+ 	       oldpos = newpos;
+ 	       snprintf(tmp, sizeof(tmp), "%s/%s", LOCAL->path[New], namesnew[i]->d_name);
+ 	       if(unlink(tmp) < 0)
+ 		 scan_err = -1;
+ 	       rescan++;
+ 	    }
+ 	    else
+ 	      newpos = oldpos;
+ 	 }
+ 	 if(scan_err < 0)
+ 	    maildir_abort(stream);
+ 	 if(rescan == 0)
+ 	   break;
+ 	 else{ /* restart */
+ 	   if(namesnew){
+ 	     for(i = 0L; i < nfilesnew; i++)
+ 		fs_give((void **)&namesnew[i]);
+ 	     fs_give((void **) &namesnew);
+ 	   }
+ 	   nfilesnew = 0L;
+ 	   loop++;
+ 	 }
+       }
+    }
+    if(loop == 10)
+      maildir_abort(stream);
+    if(LOCAL){
+      if(stream->rdonly)
+ 	stream->recent = 0L;
+      total = namescur || stream->rdonly 
+ 		? maildir_parse_dir(stream, 0L, Cur, namescur, 
+ 					      nfilescur, full) : stream->nmsgs;
+      stream->nmsgs = maildir_parse_dir(stream, total, New, namesnew, 
+ 						nfilesnew, full);
+    }
+    if(namesnew){
+      for(i = 0L; i < nfilesnew; i++)
+ 	fs_give((void **)&namesnew[i]);
+      fs_give((void **) &namesnew);
+    }
+    if(namescur){
+      for(i = 0L; i < nfilescur; i++)
+ 	fs_give((void **)&namescur[i]);
+      fs_give((void **) &namescur);
+    }
+    MM_NOCRITICAL(stream);
+ }
+ 
+ int
+ maildir_initial_check (MAILSTREAM *stream, DirNamesType dirtype)
+ {
+    char *tmp;
+    struct stat sbuf;
+ 
+    if (access (LOCAL->path[dirtype], R_OK|W_OK|X_OK) != 0){
+       maildir_abort(stream);
+       return -1;
+    }
+ 
+    if (dirtype != New && 
+ 	(stat(LOCAL->path[Cur], &sbuf) < 0 || sbuf.st_ctime == LOCAL->scantime))
+       return -1;
+    return 0;
+ }
+ 
+ 
+ /* Return the number of messages in the directory, while filling the
+  * elt structure.
+  */
+ 
+ unsigned long
+ maildir_parse_dir(MAILSTREAM *stream, unsigned long nmsgs,
+ 		  DirNamesType dirtype, struct direct **names, 
+ 		  unsigned long nfiles, int full)
+ {
+    char tmp[MAILTMPLEN], file[MAILTMPLEN], newfile[MAILTMPLEN], *mdstr;
+    struct stat sbuf;
+    unsigned long i, new = 0L, l, uid_last;
+    unsigned long recent = stream ? stream->recent : 0L;
+    int d = 0, f = 0, r = 0, s = 0, t = 0;
+    int we_compute, in_list;
+    int silent = stream ? stream->silent : NIL;
+    MESSAGECACHE *elt;
+ 
+    if (dirtype == Cur && !stream->rdonly)
+       for (i = 1L; i <= stream->nmsgs;){
+ 	elt = mail_elt(stream,  i);
+ 	in_list = elt && elt->private.spare.ptr && nfiles > 0L
+ 		  ? (MDPOS(elt) < nfiles 
+ 		    ? same_maildir_file(MDFILE(elt), names[MDPOS(elt)]->d_name)
+ 		    : NIL)
+ 		    || maildir_message_in_list(MDFILE(elt), names, 0L, 
+ 						nfiles - 1L, &MDPOS(elt))
+ 		  : NIL;
+ 	if (!in_list){
+ 	   if (elt->private.spare.ptr)
+ 	      maildir_free_file ((void **) &elt->private.spare.ptr);
+ 
+ 	   if (elt->recent) --recent;
+ 	   mail_expunged(stream,i);
+ 	}
+ 	else i++;
+       }
+ 
+    stream->silent = T;
+    uid_last = 0L;
+    for (we_compute = 0, i = l = 1L; l <= nfiles; l++){
+       unsigned long pos, uid;
+       if (dirtype == New && !stream->rdonly){ /* move new messages to cur */
+ 	pos = l - 1L;
+ 	snprintf (file, sizeof(file), "%s/%s", LOCAL->path[New], names[pos]->d_name);
+ 	if(lstat(file,&sbuf) == 0)
+ 	   switch(sbuf.st_mode & S_IFMT){
+ 	    case S_IFREG:
+ 		strcpy(tmp, names[pos]->d_name);
+ 		if((mdstr = strstr(tmp,MDSEP(3))) 
+ 		   || (mdstr = strstr(tmp,MDSEP(2))))
+ 		   *(mdstr+1) = '2';
+ 		else
+ 		   strcat(tmp, MDSEP(2));
+ 		snprintf(newfile, sizeof(newfile), "%s/%s", LOCAL->path[Cur], tmp);
+ 		if(rename (file, newfile) != 0){
+ 		   mm_log("Unable to read new mail!", WARN);
+ 		   continue;
+ 		}
+ 		unlink (file);
+ 		new++;
+ 	        break;
+ 	    case S_IFLNK:  /* clean up, clean up, everybody, everywhere */
+ 		if(unlink(file) < 0){
+ 		   if(LOCAL->link == NIL){ 
+ 		      mm_log("Unable to remove symbolic link", WARN);
+ 		      LOCAL->link = T;
+ 		   }
+ 		}
+ 		continue;
+ 		break;
+ 	    default: 
+ 		if(LOCAL && LOCAL->link == NIL){
+ 		  mm_log("Unrecognized file or link in folder", WARN);
+ 		  LOCAL->link = T;
+ 		}
+ 		continue;
+ 		break;
+ 	   }
+       }
+       mail_exists(stream, i + nmsgs);
+       elt = mail_elt(stream, i + nmsgs);
+       pos = (elt && elt->private.spare.ptr) ? MDPOS(elt) : l - 1L;
+       if (dirtype == New) elt->recent = T;
+       maildir_getflag(names[pos]->d_name, &d, &f, &r ,&s, &t);
+       if (elt->private.spare.ptr)
+ 	 maildir_free_file_only ((void **)&elt->private.spare.ptr);
+       else{
+ 	 maildir_get_file((MAILDIRFILE **)&elt->private.spare.ptr);
+ 	 we_compute++;
+       }
+       MDFILE(elt) = cpystr(names[pos]->d_name);
+       MDPOS(elt)  = pos;
+       MDLOC(elt)  = dirtype;
+       if (dirtype == Cur){	/* deal with UIDs */
+ 	if(elt->private.uid == 0L)
+ 	  elt->private.uid = maildir_get_uid(MDFILE(elt));
+ 	if(elt->private.uid <= uid_last){
+ 	  uid = (we_compute ? uid_last : stream->uid_last) + 1L;
+ 	  if(LOCAL->candouid)
+ 	    maildir_assign_uid(stream, i + nmsgs, uid);
+ 	  else
+ 	    elt->private.uid = uid;
+ 	}
+ 	else
+ 	  uid = elt->private.uid;
+ 	uid_last = uid;
+ 	if(uid_last > stream->uid_last)
+ 	  stream->uid_last = uid_last;
+       }
+       if(dirtype == New && !stream->rdonly){
+ 	maildir_free_file_only((void **)&elt->private.spare.ptr);
+ 	MDFILE(elt)  = cpystr(tmp);
+ 	MDSIZE(elt)  = sbuf.st_size;
+ 	MDMTIME(elt) = sbuf.st_mtime;
+ 	MDLOC(elt)   = Cur;
+       }
+       if (elt->draft != d || elt->flagged != f || 
+ 	elt->answered != r || elt->seen != s || elt->deleted != t){
+ 	   elt->draft = d; elt->flagged = f; elt->answered = r;
+ 	   elt->seen  = s; elt->deleted = t;
+ 	   if (!we_compute && !stream->rdonly)
+ 	      MM_FLAGS(stream, i+nmsgs);
+       }
+       maildir_get_date(stream, i+nmsgs);
+       elt->valid = T;
+       i++;
+    }
+    stream->silent = silent;
+    if(LOCAL->candouid && dirtype == Cur)
+       maildir_read_uid(stream, NULL, &stream->uid_validity);
+    if (dirtype == New && stream->rdonly)
+       new = nfiles;
+    mail_exists(stream, nmsgs  + ((dirtype == New) ? new : nfiles));
+    mail_recent(stream, recent + ((dirtype == New) ? new : 0L));
+ 
+    return (nmsgs  + (dirtype == New ? new : nfiles));
+ }
+ 
+ long maildir_ping (MAILSTREAM *stream)
+ {
+   maildir_parse_folder(stream, 0);
+   if(stream && LOCAL){
+      if(LOCAL->candouid < 0)
+ 	LOCAL->candouid++;
+      else if(LOCAL->candouid)
+         maildir_uid_renew_tempfile(stream);
+      else	 /* try again to get uids */
+ 	LOCAL->candouid = maildir_can_assign_uid(stream);
+   }
+   return stream && LOCAL ? LONGT : NIL;
+ }
+ 
+ int maildir_select (const struct direct *name)
+ {
+  return (name->d_name[0] != '.');
+ }
+ 
+ /*
+  * Unfortunately, there is no way to sort by arrival in this driver, this
+  * means that opening a folder in this driver using the scandir function
+  * will always make this driver slower than any driver that has a natural
+  * way of sorting by arrival (like a flat file format, "mbox", "mbx", etc).
+  */
+ int maildir_namesort (const struct direct **d1, const struct direct **d2)
+ {
+   const struct direct *e1 = *(const struct direct **) d1;
+   const struct direct *e2 = *(const struct direct **) d2; 
+ 
+   return comp_maildir_file((char *) e1->d_name, (char *) e2->d_name);
+ }
+ 
+ /* Maildir close */
+ 
+ void maildir_close (MAILSTREAM *stream, long options)
+ {
+   MESSAGECACHE *elt;
+   unsigned long i;
+   int silent = stream ? stream->silent : 0;
+   mailcache_t mc = (mailcache_t) mail_parameters (NIL,GET_CACHE,NIL);
+ 
+   if (!stream) return;
+ 
+   for (i = 1L; i <= stream->nmsgs; i++)
+     if((elt = (MESSAGECACHE *) (*mc)(stream,i,CH_ELT)) && elt->private.spare.ptr)
+       maildir_free_file ((void **) &elt->private.spare.ptr);
+   stream->silent = T;
+   if (options & CL_EXPUNGE) maildir_expunge (stream, NIL, NIL);
+   maildir_abort(stream);
+   if (mdfpath) fs_give((void **)&mdfpath);
+   if (mypid) mypid = (pid_t) 0;
+   stream->silent = silent;
+ }
+ 
+ void maildir_check (MAILSTREAM *stream)
+ {
+   if (maildir_ping (stream)) mm_log ("Check completed",(long) NIL);   
+ }
+ 
+ long maildir_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs, long flags)
+ {
+   char tmp[MAILTMPLEN];
+   unsigned long i;
+   MESSAGECACHE *elt;
+   char *s;
+                                 /* UID call "impossible" */
+   if (flags & FT_UID || !LOCAL) return NIL;
+   elt = mail_elt (stream, msgno);
+ 
+   if (!(flags & FT_PEEK) && !elt->seen){
+     elt->seen = T;
+     maildir_flagmsg (stream, elt);
+     MM_FLAGS(stream, elt->msgno);
+   }
+ 
+   MSGPATH(tmp, LOCAL->dir, MDFILE(elt), MDLOC(elt));
+   if (LOCAL->fd < 0)	/* if file closed ? */
+      LOCAL->fd = open(tmp,O_RDONLY,NIL);
+ 
+   if (LOCAL->fd < 0 && (errno == EACCES || errno == ENOENT)){
+      INIT (bs, mail_string, "", 0);
+      elt->rfc822_size = 0L;
+      return NIL;
+   }
+ 
+   s = maildir_text_work(stream, elt, &i, flags);
+   INIT (bs, mail_string, s, i);
+   return LONGT;
+ }
+ 
+ char *maildir_text_work (MAILSTREAM *stream,MESSAGECACHE *elt,
+                       unsigned long *length,long flags)
+ {
+   FDDATA d;
+   STRING bs;
+   char *s,tmp[CHUNK];
+   unsigned long msgno = elt->msgno;
+   static int try = 0;
+ 
+   if (length)
+      *length = 0L;
+   LOCAL->buf[0] = '\0';
+ 
+   MSGPATH(tmp, LOCAL->dir, MDFILE(elt), MDLOC(elt));
+   if (LOCAL->fd < 0)	/* if file closed ? */
+      LOCAL->fd = open(tmp,O_RDONLY,NIL);
+ 
+   if (LOCAL->fd < 0){		/* flag change? */
+       if (try < 5){
+ 	try++;
+ 	if (maildir_update_elt_maildirp(stream, msgno) > 0)
+ 	  try = 0;
+ 	return maildir_text_work(stream, mail_elt(stream, msgno),length, flags);
+       }
+       try = 0;
+       return NULL;
+   }
+ 
+   lseek (LOCAL->fd, elt->private.msg.text.offset,L_SET);
+ 
+   if (flags & FT_INTERNAL) {    /* initial data OK? */
+     if (elt->private.msg.text.text.size > LOCAL->buflen) {
+       fs_give ((void **) &LOCAL->buf);
+       LOCAL->buf = (char *) fs_get ((LOCAL->buflen =
+                                      elt->private.msg.text.text.size) + 1);
+     }
+     read (LOCAL->fd,LOCAL->buf,elt->private.msg.text.text.size);
+     LOCAL->buf[*length = elt->private.msg.text.text.size] = '\0';
+   }
+   else {
+     if (elt->rfc822_size > LOCAL->buflen) {
+       fs_give ((void **) &LOCAL->buf);
+       LOCAL->buf = (char *) fs_get ((LOCAL->buflen = elt->rfc822_size) + 1);
+     }
+     d.fd = LOCAL->fd;           /* yes, set up file descriptor */
+     d.pos = elt->private.msg.text.offset;
+     d.chunk = tmp;              /* initial buffer chunk */
+     d.chunksize = CHUNK;
+     INIT (&bs,fd_string,&d,elt->private.msg.text.text.size);
+     for (s = LOCAL->buf; SIZE (&bs);) switch (CHR (&bs)) {
+     case '\r':                  /* carriage return seen */
+       *s++ = SNX (&bs);         /* copy it and any succeeding LF */
+       if (SIZE (&bs) && (CHR (&bs) == '\n')) *s++ = SNX (&bs);
+       break;
+     case '\n':
+       *s++ = '\r';              /* insert a CR */
+     default:
+       *s++ = SNX (&bs);         /* copy characters */
+     }
+     *s = '\0';                  /* tie off buffer */
+     *length = s - (char *) LOCAL->buf;   /* calculate length */
+   }
+   close(LOCAL->fd); LOCAL->fd = -1;
+   return LOCAL->buf;
+ }
+ 
+ /* maildir parse, fill the elt structure... well not all of it... */
+ unsigned long maildir_parse_message(MAILSTREAM *stream, unsigned long msgno,
+ 				    DirNamesType dirtype)
+ {
+   char *b, *s, *t, c;
+   char tmp[MAILTMPLEN];
+   struct stat sbuf;
+   unsigned long i, len;
+   int d, f, r, se, dt;
+   MESSAGECACHE *elt;
+ 
+   elt = mail_elt (stream,msgno);
+   MSGPATH(tmp, LOCAL->dir, MDFILE(elt), dirtype);
+   if(stat(tmp, &sbuf) == 0)
+      MDSIZE(elt) = sbuf.st_size;
+ 
+   maildir_get_date(stream, msgno);
+   maildir_getflag(MDFILE(elt), &d, &f, &r ,&se, &dt);
+   elt->draft = d; elt->flagged = f; elt->answered = r; elt->seen = se;
+   elt->deleted = dt; elt->valid  = T;
+   if (LOCAL->fd < 0)	/* if file closed ? */
+      LOCAL->fd = open(tmp,O_RDONLY,NIL);
+ 
+   if (LOCAL->fd >= 0){
+ 	s = (char *) fs_get (MDSIZE(elt) + 1);
+ 	read (LOCAL->fd,s,MDSIZE(elt));
+ 	s[MDSIZE(elt)] = '\0';
+ 	t = s + strlen(s);	/* make t point to the end of s */
+ 	for (i = 0L, b = s; b < t && !(i && (*b == '\n')); i = (*b++ == '\n'));
+ 	len = (*b ? ++b : b) - s;
+ 	elt->private.msg.header.text.size = 
+ 		elt->private.msg.text.offset = len;
+ 	elt->private.msg.text.text.size = MDSIZE(elt) - len;
+ 	for (i = 0L, b = s, c = *b; b &&
+ 	    ((c < '\016' && ((c == '\012' && ++i) 
+ 			 ||(c == '\015' && *(b+1) == '\012' && ++b && (i +=2))))
+ 	    || b < t); i++, c= *++b);
+ 	elt->rfc822_size = i;
+ 	fs_give ((void **) &s);
+ 	close(LOCAL->fd); LOCAL->fd = -1;
+   }
+   return elt->rfc822_size;
+ }
+ 
+ int
+ maildir_update_elt_maildirp(MAILSTREAM *stream, unsigned long msgno)
+ {
+      struct direct **names = NIL;
+      unsigned long i, nfiles, pos;
+      int d = 0, f = 0 , r = 0, s = 0, t = 0, in_list, scan_err;
+      MESSAGECACHE *elt;
+ 
+      maildir_scandir (LOCAL->path[Cur], &names, &nfiles, &scan_err, CCLIENT);
+ 
+      elt = mail_elt (stream,msgno);
+ 
+      in_list = nfiles > 0L
+ 	    ? maildir_message_in_list(MDFILE(elt), names, 0L, nfiles - 1L, &pos)
+ 	    : NIL;
+ 
+      if (in_list && pos >= 0L && pos < nfiles
+ 	 && !strcmp(MDFILE(elt), names[pos]->d_name)){
+ 	in_list = NIL;
+ 	maildir_abort(stream);
+      }
+ 
+      if (in_list && pos >= 0L && pos < nfiles){
+ 	maildir_free_file_only((void **)&elt->private.spare.ptr);
+ 	MDFILE(elt) = cpystr(names[pos]->d_name);
+ 	maildir_getflag(MDFILE(elt), &d, &f, &r ,&s, &t);
+ 	if (elt->draft != d || elt->flagged != f || 
+ 	   elt->answered != r || elt->seen != s || elt->deleted != t){
+ 	   elt->draft = d; elt->flagged = f; elt->answered = r;
+ 	   elt->seen  = s; elt->deleted = t;
+ 	   MM_FLAGS(stream, msgno);
+         }
+      }
+      for (i = 0L; i < nfiles; i++)
+ 	fs_give((void **) &names[i]);
+      if (names)
+ 	fs_give((void **) &names);
+      return in_list ? 1 : -1;
+ }
+ 
+ /* Maildir fetch message header */
+ 
+ char *maildir_header (MAILSTREAM *stream,unsigned long msgno,
+ 		unsigned long *length, long flags)
+ {
+   char tmp[MAILTMPLEN], *s;
+   MESSAGECACHE *elt;
+   static int try = 0;
+ 
+   if (length) *length = 0;
+   if (flags & FT_UID || !LOCAL) return "";	/* UID call "impossible" */
+   elt = mail_elt (stream,msgno);
+   if(elt->private.msg.header.text.size == 0)
+      maildir_parse_message(stream, msgno, MDLOC(elt));
+ 
+   MSGPATH(tmp, LOCAL->dir, MDFILE(elt), MDLOC(elt));
+   if (LOCAL->fd < 0)
+      LOCAL->fd = open (tmp,O_RDONLY,NIL);
+ 
+   if (LOCAL->fd < 0 && errno == EACCES){
+      mm_log ("Message exists but can not be read. Envelope and body lost!",ERROR);
+      return NULL;
+   }
+ 
+   if (LOCAL->fd < 0){			/* flag change? */
+       if (try < 5){
+ 	try++;
+ 	if (maildir_update_elt_maildirp(stream, msgno) > 0)
+ 	  try = 0;
+ 	return maildir_header(stream, msgno, length, flags);
+       }
+       try = 0;
+       return NULL;
+   }
+ 
+   if (flags & FT_INTERNAL){
+      if(elt->private.msg.header.text.size > LOCAL->buflen){
+          fs_give ((void **) &LOCAL->buf);
+          LOCAL->buf = (char *) fs_get ((LOCAL->buflen =
+                                  elt->private.msg.header.text.size) + 1);
+      }
+      read (LOCAL->fd, (void *)LOCAL->buf, elt->private.msg.header.text.size);
+      LOCAL->buf[*length = elt->private.msg.header.text.size] = '\0';
+   }
+   else{
+       s = (char *) fs_get(elt->private.msg.header.text.size+1);
+       read (LOCAL->fd, (void *)s, elt->private.msg.header.text.size);
+       s[elt->private.msg.header.text.size] = '\0';
+       *length = strcrlfcpy (&LOCAL->buf,&LOCAL->buflen,s,
+                        elt->private.msg.header.text.size);
+       fs_give ((void **) &s);
+   }
+   elt->private.msg.text.offset = elt->private.msg.header.text.size;
+   elt->private.msg.text.text.size = MDSIZE(elt) - elt->private.msg.text.offset;
+   close(LOCAL->fd); LOCAL->fd = -1;
+   return LOCAL->buf;
+ }
+ 
+ /* Maildir find list of subscribed mailboxes
+  * Accepts: mail stream
+  *	    pattern to search
+  */
+ 
+ void maildir_list (MAILSTREAM *stream,char *ref, char *pat)
+ {
+   char *s,test[MAILTMPLEN],file[MAILTMPLEN];
+   long i = 0L;
+ 
+   if((!pat || !*pat) && maildir_canonicalize (test,ref,"*")
+ 	&& maildir_valid_name(test)){	/* there is a #md/ leading here */
+     for (i = 3L; test[i] && test[i] != '/'; i++);
+     if ((s = strchr (test+i+1,'/')) != NULL) *++s = '\0';
+     else test[0] = '\0';
+     mm_list (stream,'/',test, LATT_NOSELECT);
+   }
+   else if (maildir_canonicalize (test,ref,pat)) {
+     if (test[3] == '/') {       /* looking down levels? */
+                                 /* yes, found any wildcards? */
+       if ((s = strpbrk (test,"%*")) != NULL){
+                                 /* yes, copy name up to that point */
+         strncpy (file,test+4,i = s - (test+4));
+         file[i] = '\0';         /* tie off */
+       }
+       else strcpy (file,test+4);/* use just that name then */
+                                 /* find directory name */
+       if ((s = strrchr (file, '/')) != NULL){
+         *s = '\0';              /* found, tie off at that point */
+         s = file;
+       }
+                                 /* do the work */
+       if(IS_COURIER(test))
+ 	courier_list_work (stream,s,test,0);
+       else
+ 	maildir_list_work (stream,s,test,0);
+     }
+                                 /* always an INBOX */
+     if (!compare_cstring (test,"#MD/INBOX"))
+       mm_list (stream,NIL,"#MD/INBOX",LATT_NOINFERIORS);
+     if (!compare_cstring (test,"#MC/INBOX"))
+       mm_list (stream,NIL,"#MC/INBOX",LATT_NOINFERIORS);
+   }
+ }
+ 
+ void courier_list (MAILSTREAM *stream,char *ref, char *pat)
+ {
+ /* I am too lazy to do anything. Do you care to ask maildir list, please?
+    The real reason why this is a dummy function is because we do not want to
+    see the same folder listed twice. 
+ */
+ }
+ 
+ /* For those that want to hide things, we give them a chance to do so */
+ void *maildir_parameters (long function, void *value)
+ {
+   void *ret = NIL;
+   switch ((int) function) {
+   case SET_MDINBOXPATH:
+     if(strlen((char *) value ) > 49)
+        strcpy(myMdInboxDir, "Maildir");
+     else
+        strcpy(myMdInboxDir, (char *) value);
+   case GET_MDINBOXPATH:
+     if (myMdInboxDir[0] == '\0') strcpy(myMdInboxDir,"Maildir");
+     ret = (void *) myMdInboxDir;
+     break;
+   case SET_COURIERSTYLE:
+     CourierStyle = (long) value;
+   case GET_COURIERSTYLE:
+     ret = (void *) CourierStyle;
+     break;
+   case GET_DIRFMTTEST:
+     ret = (void *) maildir_dirfmttest;
+     break;
+   default:
+     break;
+   }
+   return ret;
+ }
+ 
+ int maildir_create_folder(char *mailbox)
+ {
+   char tmp[MAILTMPLEN], err[MAILTMPLEN];
+   DirNamesType i;
+ 
+   for (i = Cur; i != EndDir; i++){
+ 	MDFLD(tmp, mailbox, i);
+ 	if (mkdir(tmp, 0700) && errno != EEXIST){ /* try to make new dir */
+ 	    snprintf (err, sizeof(err), "Can't create %s: %s", tmp, strerror(errno));
+ 	    mm_log (err,ERROR);
+ 	    return NIL;
+ 	}
+   }
+   return T;
+ }
+ 
+ int maildir_create_work(char *mailbox, int loop)
+ {
+   char *s, c, err[MAILTMPLEN], tmp[MAILTMPLEN], tmp2[MAILTMPLEN], mbx[MAILTMPLEN];
+   int fnlen, create_dir = 0, courier, mv;
+   struct stat sbuf;
+   long style = (long) maildir_parameters(GET_COURIERSTYLE, NIL);
+ 
+   courier = IS_COURIER(mailbox);
+   strcpy(mbx, mailbox);
+   mv = maildir_valid(mbx) ? 1 : 0;
+   maildir_file_path(mailbox, tmp, sizeof(tmp));
+   if (mailbox[strlen(mailbox) - 1] == MDSEPARATOR(courier)){
+       create_dir++;
+       mailbox[strlen(mailbox) - 1] = '\0';
+   }
+ 
+   if(!loop && courier){
+     if(mv){
+        if(create_dir){
+ 	  if(style == CCLIENT)
+ 	   strcpy (err,"Can not create directory: folder exists. Create subfolder");
+ 	  else
+ 	   strcpy(err,"Folder and Directory already exist");
+        }
+        else
+           strcpy (err, "Can't create mailbox: mailbox already exists");
+     }
+     else{
+ 	if(create_dir)
+ 	   strcpy(err, "Can not create directory. Cread folder instead");
+ 	else
+ 	  err[0] = '\0';
+     }
+     if(err[0]){
+        mm_log (err,ERROR);
+        return NIL;
+     }
+   }
+ 
+   fnlen = strlen(tmp);
+   if ((s = strrchr(mailbox,MDSEPARATOR(courier))) != NULL){
+      c = *++s;
+     *s = '\0';
+     if ((stat(tmp,&sbuf) || ((sbuf.st_mode & S_IFMT) != S_IFDIR)) &&
+         !maildir_create_work (mailbox, ++loop))
+       return NIL;
+     *s = c;
+   }
+   tmp[fnlen] = '\0';
+ 
+   if (mkdir(tmp,0700) && errno != EEXIST)
+      return NIL;
+ 
+   if (create_dir)
+      mailbox[fnlen] = '/';
+ 
+   if (create_dir){
+      if(style == CCLIENT){
+ 	if(!courier){
+ 	   FILE *fp = NULL;
+ 	   snprintf(tmp2, sizeof(tmp2), "%s%s", tmp, MDDIR);
+ 	   if ((fp = fopen(tmp2,"w")) == NULL){
+ 	      snprintf (err, sizeof(err), "Problem creating %s: %s", tmp2, strerror(errno));
+               mm_log (err,ERROR);
+               return NIL;
+ 	   }
+ 	   fclose(fp);
+ 	}
+      }
+      return T;
+   }
+   else
+      return maildir_create_folder(tmp);
+ }
+ 
+ long maildir_create (MAILSTREAM *stream,char *mailbox)
+ {
+   char tmp[MAILTMPLEN], err[MAILTMPLEN];
+   int rv, create_dir;
+ 
+   create_dir = mailbox ? 
+ 		(mailbox[strlen(mailbox) - 1] == 
+ 					MDSEPARATOR(IS_COURIER(mailbox))) : 0;
+   maildir_file_path(mailbox, tmp, sizeof(tmp));
+   strcpy(tmp, mailbox);
+   rv = maildir_create_work(mailbox, 0);
+   strcpy(mailbox, tmp);
+   if (rv == 0){
+      snprintf (err, sizeof(err), "Can't create %s %s",
+ 		   (create_dir ? "directory" : "mailbox"), mailbox);
+      mm_log (err,ERROR);
+   }
+   return rv ? LONGT : NIL;
+ }
+ 
+ #define MAXTRY 10000
+ void maildir_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt)
+ {
+   char oldfile[MAILTMPLEN],newfile[MAILTMPLEN],fn[MAILTMPLEN];
+   char *s;
+   int ren, try = 0;
+ 
+   if (elt->valid){
+      for (try = 1; try > 0 && try < MAXTRY; try++){
+                                 /* build the new filename */
+ 	snprintf (oldfile, sizeof(oldfile), "%s/%s",LOCAL->path[Cur], MDFILE(elt));
+ 	fn[0] = '\0';
+ 	if ((ren = maildir_message_exists(stream, MDFILE(elt), fn)) == 0){
+ 	    errno = ENOENT;
+ 	    try = MAXTRY;
+ 	}
+ 	if (*fn)	/* new oldfile! */
+ 	   snprintf (oldfile,sizeof(oldfile),"%s/%s", LOCAL->path[Cur], fn);
+         if ((s = strrchr (MDFILE(elt), FLAGSEP))) *s = '\0';
+ 	snprintf (fn, sizeof(fn), "%s%s%s%s%s%s%s", MDFILE(elt), MDSEP(2),
+ 		MDFLAG(Draft, elt->draft), MDFLAG(Flagged, elt->flagged),
+ 		MDFLAG(Replied, elt->answered), MDFLAG(Seen, elt->seen),
+ 		MDFLAG(Trashed, elt->deleted));
+ 	snprintf (newfile, sizeof(newfile), "%s/%s",LOCAL->path[Cur],fn);
+         if (ren != 0 && rename (oldfile,newfile) >= 0)
+ 	    try = -1;
+      }
+ 
+      if (try > 0){
+        snprintf(oldfile, sizeof(oldfile), "Unable to write flags to disk: %s",
+ 		(errno == ENOENT) ? "message is gone!" : strerror (errno));
+        mm_log(oldfile,ERROR);
+        return;
+      }
+ #ifdef __CYGWIN__
+      utime(LOCAL->path[Cur], NIL);	/* make sure next scan will catch the change */
+ #endif
+      maildir_free_file_only ((void **) &elt->private.spare.ptr);
+      MDFILE(elt) = cpystr (fn);
+   }
+ }
+ 
+ long maildir_expunge (MAILSTREAM *stream, char *sequence, long options)
+ {
+   long ret;
+   MESSAGECACHE *elt;
+   unsigned long i, n = 0L;
+   unsigned long recent = stream->recent;
+   char tmp[MAILTMPLEN];
+ 
+   mm_critical (stream);               /* go critical */
+   ret = sequence ? ((options & EX_UID) ?
+                          mail_uid_sequence (stream,sequence) :
+                          mail_sequence (stream,sequence)) : LONGT;
+   if(ret == 0L)
+      return 0L;
+   for (i = 1L; i <= stream->nmsgs;){
+     elt = mail_elt (stream,i);
+     if (elt->deleted && (sequence ? elt->sequence : T)){
+       snprintf (tmp, sizeof(tmp), "%s/%s", LOCAL->path[Cur], MDFILE(elt));
+       if (unlink (tmp) < 0) {/* try to delete the message */
+       snprintf (tmp, sizeof(tmp), "Expunge of message %ld failed, aborted: %s",i,
+               strerror (errno));
+       if (!stream->silent)
+          mm_log (tmp,WARN);
+       break;
+       }
+       if (elt->private.spare.ptr)
+        maildir_free_file ((void **) &elt->private.spare.ptr);
+       if (elt->recent) --recent;/* if recent, note one less recent message */
+       mail_expunged (stream,i);       /* notify upper levels */
+        n++;                    /* count up one more expunged message */
+     }
+     else i++;
+   }
+   if(n){                      /* output the news if any expunged */
+     snprintf (tmp, sizeof(tmp), "Expunged %ld messages", n);
+     if (!stream->silent)
+        mm_log (tmp,(long) NIL);
+   }
+   else
+     if (!stream->silent)
+       mm_log ("No messages deleted, so no update needed",(long) NIL);
+   mm_nocritical (stream);     /* release critical */
+                             /* notify upper level of new mailbox size */
+   mail_exists (stream, stream->nmsgs);
+   mail_recent (stream, recent);
+   return ret;
+ }
+ 
+ long maildir_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options)
+ {
+   STRING st;
+   MESSAGECACHE *elt;
+   unsigned long len;
+   int fd;
+   unsigned long i;
+   struct stat sbuf;
+   char tmp[MAILTMPLEN], flags[MAILTMPLEN], path[MAILTMPLEN], *s;
+ 				/* copy the messages */
+   if ((options & CP_UID) ? mail_uid_sequence (stream, sequence) : 
+   	mail_sequence (stream,sequence)) 
+   for (i = 1L; i <= stream->nmsgs; i++)
+     if ((elt = mail_elt (stream,i))->sequence){
+       MSGPATH(path, LOCAL->dir, MDFILE(elt), MDLOC(elt));
+       if (((fd = open (path,O_RDONLY,NIL)) < 0)	 
+ 	  ||((!elt->rfc822_size && 
+ 		((stat(path, &sbuf) < 0) || !S_ISREG (sbuf.st_mode)))))
+ 	return NIL;
+ 	if(!elt->rfc822_size)
+ 	  MDSIZE(elt) = sbuf.st_size;
+         s = (char *) fs_get(MDSIZE(elt) + 1);
+         read (fd,s,MDSIZE(elt));
+         s[MDSIZE(elt)] = '\0';
+         close (fd);
+ 	len = strcrlfcpy (&LOCAL->buf,&LOCAL->buflen, s, MDSIZE(elt));
+         INIT (&st,mail_string, LOCAL->buf, len);
+ 	elt->rfc822_size = len;
+ 	fs_give ((void **)&s);
+ 
+       flags[0] = flags[1] = '\0';
+       if (elt->seen) strcat (flags," \\Seen");
+       if (elt->draft) strcat (flags," \\Draft");
+       if (elt->deleted) strcat (flags," \\Deleted");
+       if (elt->flagged) strcat (flags," \\Flagged");
+       if (elt->answered) strcat (flags," \\Answered");
+       flags[0] = '(';		/* open list */
+       strcat (flags,")");	/* close list */
+       mail_date (tmp,elt);	/* generate internal date */
+       if (!mail_append_full (NIL, mailbox, flags, tmp, &st))
+         return NIL;
+       if (options & CP_MOVE) elt->deleted = T;
+     }
+   return LONGT;			/* return success */
+ }
+ 
+ long maildir_append (MAILSTREAM *stream,char *mailbox,append_t af,void *data)
+ {
+   int fd, k;
+   STRING *message;
+   char c,*s, *flags, *date;
+   char tmp[MAILTMPLEN],file[MAILTMPLEN],path1[MAILTMPLEN],path2[MAILTMPLEN];
+   MESSAGECACHE elt;
+   long i, size = 0L, ret = LONGT, f;
+   unsigned long uf, ti;
+   static unsigned int transact = 0;
+ 
+   if (!maildir_valid(mailbox)) {
+     snprintf (tmp, sizeof(tmp), "Not a valid Maildir mailbox: %s", mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 
+  if (!*mdlocaldomain)
+      md_domain_name();    /* get domain name for maildir files in mdlocaldomain now! */
+ 
+  if (mypid == (pid_t) 0)
+     mypid = getpid();
+ 
+  if (!stream){
+     stream = &maildirproto;
+   
+     for (k = 0; k < NUSERFLAGS && stream->user_flags[k]; ++k)
+        fs_give ((void **) &stream->user_flags[k]);
+  }
+ 
+   if (!(*af)(stream, data, &flags, &date, &message)) return NIL;
+ 
+   mm_critical (stream);		/* go critical */
+   /* call time(0) only once, use transact to distinguish instead */
+   ti = time(0);
+   do {
+     if (!SIZE (message)) {      /* guard against zero-length */
+       mm_log ("Append of zero-length message",ERROR);
+       ret = NIL;
+       break;
+     }
+     if (date && !mail_parse_date(&elt,date)){
+         snprintf (tmp, sizeof(tmp), "Bad date in append: %.80s",date);
+         mm_log (tmp,ERROR);
+         ret = NIL;
+         break;
+     }
+     f = mail_parse_flags (stream,flags,&uf);
+ 				/* build file name we will use */
+     snprintf (file, sizeof(file), "%lu.%d_%09u.%s%s%s%s%s%s",
+ 		ti, mypid, transact++, mdlocaldomain, (f ? MDSEP(2) : ""),
+ 		MDFLAG(Draft, f&fDRAFT), MDFLAG(Flagged, f&fFLAGGED),
+ 		MDFLAG(Replied, f&fANSWERED), MDFLAG(Seen, f&fSEEN));
+ 				/* build tmp file name */
+     if (maildir_file_path(mailbox, tmp, sizeof(tmp)))
+        MSGPATH(path1, tmp, file, Tmp);
+ 
+     if ((fd = open (path1,O_WRONLY|O_CREAT|O_EXCL,S_IREAD|S_IWRITE)) < 0) {
+        snprintf (tmp, sizeof(tmp), "Can't open append mailbox: %s", strerror (errno));
+        mm_log (tmp, ERROR);
+        return NIL;
+     }
+     for (size = 0,i = SIZE (message),s = (char *) fs_get (i + 1); i; --i)
+       if ((c = SNX (message)) != '\015') s[size++] = c;
+     if ((write (fd, s, size) < 0) || fsync (fd)) {
+ 	unlink (path1);		/* delete message */
+ 	snprintf (tmp, sizeof(tmp), "Message append failed: %s", strerror (errno));
+ 	mm_log (tmp, ERROR);
+ 	ret = NIL;
+     }
+     fs_give ((void **) &s);	/* flush the buffer */
+     close (fd);			/* close the file */
+ 				/* build final filename to use */
+     if (maildir_file_path(mailbox, tmp, sizeof(tmp)))
+ 	MSGPATH(path2, tmp, file, New);
+     if (rename (path1,path2) < 0) {
+        snprintf (tmp, sizeof(tmp), "Message append failed: %s", strerror (errno));
+        mm_log (tmp, ERROR);
+        ret = NIL;
+     }
+     unlink (path1);
+ 
+     if (ret)
+      if (!(*af) (stream,data,&flags,&date,&message)) ret = NIL;
+ 
+   } while (ret && message);	/* write the data */
+   mm_nocritical (stream);	/* release critical */
+   return ret;
+ }
+ 
+ long maildir_delete (MAILSTREAM *stream,char *mailbox)
+ {
+   DIR *dirp;
+   struct direct *d;
+   int i, remove_dir = 0, mddir = 0, rv, error = 0;
+   char tmp[MAILTMPLEN],tmp2[MAILTMPLEN], realname[MAILTMPLEN];
+   struct stat sbuf;
+   int courier = IS_COURIER(mailbox);
+ 
+   if (mailbox[strlen(mailbox) - 1] == MDSEPARATOR(courier)){
+       remove_dir++;
+       mailbox[strlen(mailbox) -1] = '\0';
+   }
+ 
+   if (!maildir_valid(mailbox)){
+       maildir_file_path(mailbox, tmp, sizeof(tmp));
+       if (stat(tmp, &sbuf) < 0 || !S_ISDIR(sbuf.st_mode)){
+         snprintf(tmp, sizeof(tmp), "Can not remove %s", mailbox);
+ 	error++;
+       }
+   }
+ 
+   if (!error && remove_dir && !maildir_dir_is_empty(mailbox)){
+      snprintf(tmp, sizeof(tmp), "Can not remove directory %s/: directory not empty", mailbox);
+      error++;
+   }
+ 
+   if(error){
+      mm_log (tmp,ERROR);
+      return NIL;
+   }
+ 
+   maildir_close(stream,0);	/* even if stream was NULL */
+ 
+   maildir_file_path(mailbox, realname, sizeof(realname));
+ 
+   if (remove_dir){
+      snprintf(tmp, sizeof(tmp), "%s/%s", realname, MDDIR);
+      if ((rv = stat (tmp,&sbuf)) == 0 && S_ISREG(sbuf.st_mode))
+ 	rv = unlink(tmp);
+      else if (errno == ENOENT)
+ 	rv = 0;
+      if (rv != 0){
+ 	snprintf(tmp, sizeof(tmp), "Can not remove %s/%s: %s", tmp2, MDDIR, strerror(errno));
+ 	mm_log (tmp,ERROR);
+ 	return NIL;
+      }
+      if (!maildir_valid(realname) && rmdir(realname) != 0){
+ 	snprintf(tmp, sizeof(tmp), "Can not remove %s/: %s", mailbox, strerror(errno));
+ 	mm_log (tmp, ERROR);
+ 	return NIL;
+      }
+      return LONGT;
+   }
+   /* else remove just the folder. Remove all hidden files, except MDDIR */
+   for (i = Cur; i != EndDir; i++){
+       MDFLD(tmp, realname, i);
+ 
+       if (!(dirp = opendir (tmp))){
+ 	  snprintf(tmp, sizeof(tmp), "Can not read %s/: %s", mailbox, strerror(errno));
+ 	  mm_log (tmp, ERROR);
+ 	  return NIL;
+       }
+ 
+       while ((d = readdir(dirp)) != NULL){
+ 	 if (strcmp(d->d_name, ".") && strcmp(d->d_name,"..")){
+ 	    snprintf(tmp2, sizeof(tmp2), "%s/%s", tmp, d->d_name);
+ 	    if (unlink(tmp2) != 0){
+ 	       snprintf(tmp2, sizeof(tmp2), "Can not remove %s: %s", mailbox, strerror(errno));
+ 	       mm_log (tmp2, ERROR);
+ 	       return NIL;
+ 	    }
+ 	 }
+       }
+       closedir(dirp);
+       if (rmdir(tmp) != 0){
+ 	 snprintf(tmp, sizeof(tmp), "Can not remove %s: %s", mailbox, strerror(errno));
+ 	 mm_log (tmp, ERROR);
+ 	 return NIL;
+       }
+   }
+   /* 
+    * ok we have removed all subdirectories of the folder mailbox, Remove the
+    * hidden files.
+    */
+ 
+   if(!(dirp = opendir (realname))){
+     snprintf(tmp, sizeof(tmp), "Can not read %s/: %s", realname, strerror(errno));
+     mm_log (tmp, ERROR);
+     return NIL;
+   }
+ 
+   while ((d = readdir(dirp)) != NULL){
+ 	if (strcmp(d->d_name, ".") && strcmp(d->d_name,"..")
+ 		&& (!strcmp(d->d_name, MDDIR)
+ 			|| !strncmp(d->d_name, MDUIDLAST, strlen(MDUIDLAST))
+ 			|| !strncmp(d->d_name, MDUIDTEMP, strlen(MDUIDTEMP)))){
+ 	   if(strcmp(d->d_name, MDDIR) == 0)
+ 	      mddir++;
+ 	   snprintf(tmp, sizeof(tmp), "%s/%s", realname, d->d_name);
+ 	   if (unlink(tmp) != 0)
+ 	      error++;
+ 	}
+   }
+   closedir(dirp);
+   if (error || 
+ 	 (maildir_dir_is_empty(mailbox) && mddir == 0 && rmdir(realname) < 0)){
+         snprintf(tmp, sizeof(tmp), "Can not remove folder %s: %s", mailbox, strerror(errno));
+         mm_log (tmp, ERROR);
+         return NIL;
+   }
+   return LONGT;
+ }
+ 
+ long maildir_rename (MAILSTREAM *stream, char *old, char *new)
+ {
+   char tmp[MAILTMPLEN], tmpnew[MAILTMPLEN], realold[MAILTMPLEN];
+   char realnew[MAILTMPLEN];
+   int courier = IS_COURIER(old) && IS_COURIER(new);
+   int i;
+   long rv = LONGT;
+   COURIER_S *cdir;
+ 
+   if((IS_COURIER(old) || IS_COURIER(new)) && !courier){
+     snprintf (tmp, sizeof(tmp), "Can't rename mailbox %s to %s", old, new);
+     mm_log (tmp, ERROR);
+     return NIL;
+   }
+ 
+   if (!maildir_valid(old)){
+     snprintf (tmp, sizeof(tmp), "Can't rename mailbox %s: folder not in maildir format",old);
+     mm_log (tmp, ERROR);
+     return NIL;
+   }
+   maildir_file_path(old, realold, sizeof(realold));
+   if (!maildir_valid_name(new) && new[0] == '#'){
+     snprintf (tmp, sizeof(tmp), "Cannot rename mailbox %s: folder not in maildir format", new);
+     mm_log (tmp, ERROR);
+     return NIL;
+   }
+   maildir_file_path(new, realnew, sizeof(realnew));
+   if (access(tmpnew,F_OK) == 0){ 	/* new mailbox name must not exist */
+     snprintf (tmp, sizeof(tmp), "Cannot rename to mailbox %s: destination already exists", new);
+     mm_log (tmp, ERROR);
+     return NIL;
+   }
+ 
+   if(!courier){
+     if (rename(realold, realnew)){	/* try to rename the directory */
+        snprintf(tmp, sizeof(tmp), "Can't rename mailbox %s to %s: %s", old, new,
+ 							strerror(errno));
+        mm_log(tmp,ERROR);
+        return NIL;
+     }
+     return LONGT;	/* return success */
+   }
+ 
+   cdir = courier_list_dir(old);
+   for (i = 0; cdir && i < cdir->total; i++){
+       if(strstr(cdir->data[i]->name, old)){
+ 	snprintf(tmp, sizeof(tmp), "%s%s", new, cdir->data[i]->name+strlen(old));
+ 	maildir_file_path(cdir->data[i]->name, realold, sizeof(realold));
+ 	maildir_file_path(tmp, realnew, sizeof(realnew));
+ 	if (rename(realold, realnew)){
+ 	   snprintf (tmp, sizeof(tmp), "Can't rename mailbox %s to %s: %s", old, new,
+ 							strerror(errno));
+ 	   mm_log(tmp,ERROR);
+ 	   rv = NIL;
+ 	}
+     }
+   }
+   courier_free_cdir(&cdir);
+   return rv;
+ }
+ 
+ long maildir_sub(MAILSTREAM *stream,char *mailbox)
+ {
+   return sm_subscribe(mailbox);
+ }
+ 
+ long maildir_unsub(MAILSTREAM *stream,char *mailbox)
+ {
+   return sm_unsubscribe(mailbox);
+ }
+ 
+ void maildir_lsub (MAILSTREAM *stream,char *ref,char *pat)
+ {
+   void *sdb = NIL;
+   char *s, test[MAILTMPLEN];
+                                 /* get canonical form of name */
+   if (maildir_canonicalize (test, ref, pat) && (s = sm_read (&sdb))) {
+     do if (pmatch_full (s, test, '/')) mm_lsub (stream, '/', s, NIL);
+     while ((s = sm_read (&sdb)) != NULL); /* until no more subscriptions */
+   }
+ }
+ 
+ long maildir_canonicalize (char *pattern,char *ref,char *pat)
+ {
+   if (ref && *ref) {            /* have a reference */
+     strcpy (pattern,ref);       /* copy reference to pattern */
+                                 /* # overrides mailbox field in reference */
+     if (*pat == '#') strcpy (pattern,pat);
+                                 /* pattern starts, reference ends, with / */
+     else if ((*pat == '/') && (pattern[strlen (pattern) - 1] == '/'))
+       strcat (pattern,pat + 1); /* append, omitting one of the period */
+                                                                                 
+     else strcat (pattern,pat);  /* anything else is just appended */
+   }
+   else strcpy (pattern,pat);    /* just have basic name */
+   return maildir_valid_name(pattern) ? LONGT : NIL;
+ }
+ 
+ void maildir_list_work (MAILSTREAM *stream,char *dir,char *pat,long level)
+ {
+   DIR *dp;
+   struct direct *d;
+   struct stat sbuf;
+   char curdir[MAILTMPLEN],name[MAILTMPLEN], tmp[MAILTMPLEN];
+   char realpat[MAILTMPLEN];
+   long i;
+   char *maildirpath = mdirpath();
+ 
+   snprintf(curdir, sizeof(curdir), "%s/%s/", myrootdir(pat), dir ? dir : maildirpath);
+   if ((dp = opendir (curdir)) != NULL){ 
+      if (dir) snprintf (name, sizeof(name), "%s%s/",MDPREFIX(CCLIENT),dir);
+      else strcpy (name, pat);
+ 
+      if (level == 0 && !strpbrk(pat,"%*")){
+ 	if(maildir_valid(pat)){
+ 	  i =  maildir_contains_folder(pat, NULL)
+ 		? LATT_HASCHILDREN
+ 		: (maildir_is_dir(pat, NULL)
+ 			     ? LATT_HASNOCHILDREN : LATT_NOINFERIORS);
+ 	  maildir_file_path(pat, realpat, sizeof(realpat));
+ 	  i +=  maildir_any_new_msgs(realpat) 
+ 			? LATT_MARKED : LATT_UNMARKED;
+ 	  mm_list (stream,'/', pat, i);
+ 	}
+ 	else
+ 	   if(pat[strlen(pat) - 1] == '/')
+ 	     mm_list (stream,'/', pat, LATT_NOSELECT);
+      }
+ 
+      while ((d = readdir (dp)) != NULL)
+ 	if(strcmp(d->d_name, ".") && strcmp(d->d_name,"..")
+ 		&& strcmp(d->d_name, MDNAME(Cur)) 
+ 		&& strcmp(d->d_name, MDNAME(Tmp)) 
+ 		&& strcmp(d->d_name, MDNAME(New))){
+ 
+ 	  if (dir) snprintf (tmp, sizeof(tmp), "%s%s", name,d->d_name);
+ 	  else strcpy(tmp, d->d_name);
+ 
+ 	  if(pmatch_full (tmp, pat,'/')){
+ 	     snprintf(tmp, sizeof(tmp), "%s/%s/%s", myrootdir(d->d_name), 
+ 				(dir ? dir : maildirpath), d->d_name);
+ 	     if(stat (tmp,&sbuf) == 0 
+ 		   && ((sbuf.st_mode & S_IFMT) == S_IFDIR)){
+ 	       if (dir) snprintf (tmp, sizeof(tmp), "%s%s", name,d->d_name);
+ 	       else strcpy(tmp, d->d_name);
+                i = maildir_valid(tmp)
+ 			? (maildir_contains_folder(dir, d->d_name)
+ 			  ? LATT_HASCHILDREN
+ 			  : (maildir_is_dir(dir, d->d_name)
+ 			     ? LATT_HASNOCHILDREN : LATT_NOINFERIORS))
+ 			: LATT_NOSELECT;
+ 	       i +=  maildir_any_new_msgs(tmp)
+ 			    ? LATT_MARKED : LATT_UNMARKED;
+ 	       mm_list (stream,'/',tmp, i);
+ 	       strcat (tmp, "/");
+ 	       if(dmatch (tmp, pat,'/') &&
+                  (level < (long) mail_parameters (NIL,GET_LISTMAXLEVEL,NIL))){
+ 		   snprintf(tmp, sizeof(tmp), "%s/%s",dir,d->d_name);
+  		   maildir_list_work (stream,tmp,pat,level+1);
+ 	       }
+ 	     }
+ 	  }
+        }
+      closedir (dp);
+   }
+ }
+ 
+ void courier_list_work (MAILSTREAM *stream, char *dir, char *pat, long level)
+ {
+   char c, curdir[MAILTMPLEN], tmp[MAILTMPLEN];
+   char realname[MAILTMPLEN], realpat[MAILTMPLEN] = {'\0'};
+   int i, found;
+   long style = (long) maildir_parameters(GET_COURIERSTYLE, NIL), j;
+   char *maildirpath = mdirpath();
+   COURIER_S *cdir;
+ 
+   if(!strpbrk(pat,"%*")){	/* a mailbox */
+      maildir_file_path(pat, curdir, sizeof(curdir));
+      i = strlen(curdir) - 1;
+      if(curdir[i] == '/')
+        curdir[i] = '\0';
+      cdir = courier_list_dir(curdir);
+      if(cdir){
+ 	found = 0; j = 0L;
+ 	if(maildir_valid_name(pat)){
+ 	  for(i = 0; !found && i < cdir->total; i++)
+ 	     if(strstr(curdir, cdir->data[i]->name)){
+ 		if(strlen(curdir) < strlen(cdir->data[i]->name))
+ 		  found += 2;
+ 		else if(strlen(curdir) == strlen(cdir->data[i]->name))
+ 		  found -= 1;
+ 	     }
+ 	  if(found > 0)
+             j = LATT_HASCHILDREN;
+           else if(found == 0)
+ 	    j = (style == COURIER) ? LATT_HASNOCHILDREN : LATT_NOINFERIORS;
+ 	}
+ 	else
+ 	   j = LATT_NOSELECT;
+         j += maildir_any_new_msgs(curdir) ? LATT_MARKED : LATT_UNMARKED;
+ 	if (found)
+ 	   mm_list (stream, '.', pat, j);
+         courier_free_cdir(&cdir);
+      }
+      return;
+   }
+ 
+   strcpy(tmp,pat + 4);	/* a directory */
+   j = strlen(pat) - 1;
+   maildir_file_path(pat, realpat, sizeof(realpat));
+   c = pat[j];
+   pat[j] = '\0';
+   realname[0] = '\0';
+   if(dir)
+     maildir_file_path(dir, realname, sizeof(realname));
+   snprintf(curdir, sizeof(curdir), "%s%s%s/%s", (dir ? "" : myrootdir(pat)), (dir ? "" : "/"),
+ 		(dir ? realname : maildirpath),	(dir ? "" : "."));
+   snprintf(tmp, sizeof(tmp), "%s%s/.", MDPREFIX(COURIER), dir ? dir : maildirpath);
+   if (level == 0 && tmp && pmatch_full (tmp, realpat, '.'))
+      mm_list (stream,'.', tmp, LATT_NOSELECT);
+ 
+   cdir = courier_list_dir(pat);
+   pat[j] = c;
+   for (i = 0; cdir && i < cdir->total; i++)
+    if(pmatch_full (cdir->data[i]->name, pat, '.')){
+       snprintf(tmp, sizeof(tmp), "%s.", cdir->data[i]->name);
+       courier_list_info(&cdir, tmp, i);
+       mm_list (stream,'.',cdir->data[i]->name, cdir->data[i]->attribute);
+    }
+   courier_free_cdir(&cdir);
+ }
+ 
+ int 
+ same_maildir_file(char *name1, char *name2)
+ {
+  char tmp1[MAILTMPLEN], tmp2[MAILTMPLEN];
+  char *s;
+ 
+  strcpy(tmp1, name1 ? name1 : "");
+  strcpy(tmp2, name2 ? name2 : "");
+  if ((s = strrchr(tmp1, FLAGSEP)) != NULL)
+    *s = '\0';
+  if (((s = strrchr(tmp1, SIZESEP)) != NULL) && (strchr(s,'.') == NULL))
+    *s = '\0';
+  if ((s = strrchr(tmp2, FLAGSEP)) != NULL)
+    *s = '\0';
+  if (((s = strrchr(tmp2, SIZESEP)) != NULL) && (strchr(s,'.') == NULL))
+    *s = '\0';
+ 
+  return !strcmp(tmp1, tmp2);
+ }
+ 
+ unsigned long antoul(char *seed)
+ {
+   int i, error = 0;
+   unsigned long val = 0L, rv1 = 0L, t;
+   char c, *p;
+  if(!seed)
+    return 0L;
+  t = strtoul(seed, &p, 10);
+  if(p && (*p == '.' || *p == '_'))
+    return t;
+  /* else */
+  if((p = strchr(seed,'.')) != NULL)
+    *p = '\0';
+  error = (strlen(seed) > 6); /* too long */
+  for(i= strlen(seed)-1; error == 0 && i >= 0; i--){
+     c = seed[i];
+     if (c >= 'A' && c <= 'Z') val = c - 'A';
+     else if (c >= 'a' && c <= 'z') val = c - 'a' + 26;
+     else if (c >= '0' && c <= '9') val = c - '0' + 26 + 26; 
+     else if (c == '-') val = c - '-' + 26 + 26 + 10;
+     else if (c == '_') val = c - '_' + 26 + 26 + 10 + 1;
+     else error++;
+     rv1 = val + (rv1 << 6);
+  }
+  if(p)
+    *p = '.';
+   return error ? 0L : rv1;
+ }
+ 
+ unsigned long mdfntoul (char *name)
+ {
+   unsigned long t;
+   char *r, last;
+ 
+   if((*name == '_') && ((r = strpbrk(name,".,%+")) != NULL)){ /* Grrr!!! */
+     last = *r;
+     *r = '\0';
+      t = antoul(r+1);
+     *r = last;
+   }
+   else
+     t = antoul(name);
+   return t;
+ }
+ 
+ int comp_maildir_file(char *name1, char *name2)
+ {
+   int uset1 = 1, uset2 = 1, i, j, cmp;
+   unsigned long t1, t2;
+   char *s1, *s2;
+ 
+   if (!(name1 && *name1))
+      return (name2 && *name2) ? (*name2 == FLAGSEP ? 0 : -1) : 0;
+ 
+   if (!(name2 && *name2))
+      return (name1 && *name1) ? (*name1 == FLAGSEP ? 0 : 1) : 0;
+ 
+    if((cmp = strcmp(name1,name2)) == 0)
+       return 0;
+ 
+   t1 = strtoul(name1, &s1, 10);
+   t2 = strtoul(name2, &s2, 10);
+ 
+   if(!s1 || *s1 != '.')
+     uset1 = 0;
+ 
+   if(!s2 || *s2 != '.')
+     uset2 = 0;
+ 
+   if(uset1 && uset2)	/* normal sort order */
+     return (t1 < t2) ? -1 : (t1 > t2 ? 1 : (cmp < 0 ? -1 : 1));
+ 
+   /* If we make it here we say Grrrr.... first, then we try to figure out
+    * how to sort this mess.
+    * These are the rules.
+    * If there is a number at the beginning it is bigger than anything else.
+    * If there are digits, then the number of digits decides which one is bigger.
+    */
+ 
+   for(i = 0; isdigit(name1[i]); i++);
+   for(j = 0; isdigit(name2[j]); j++);
+ 
+   return(uset1 ? 1 
+ 	       : (uset2 ? -1 
+ 			: (i < j ? -1 : (i > j ? 1 : (cmp < 0 ? -1 : 1)))));
+ }
+ 
+ void
+ maildir_getflag(char *name, int *d, int *f, int *r ,int *s, int *t)
+ {
+   char tmp[MAILTMPLEN], *b;
+   int offset = 0;
+   int tmpd, tmpf, tmpr, tmps, tmpt;
+ 
+   if(d) *d = 0;
+   if(f) *f = 0;
+   if(r) *r = 0;
+   if(s) *s = 0;
+   if(t) *t = 0;
+ 
+   tmpd = tmpf = tmpr = tmps = tmpt = NIL; /* no flags set by default */
+   strcpy(tmp,name);
+   while ((b = strrchr(tmp+offset, FLAGSEP)) != NULL){
+     char flag,last;
+     int  k;
+     if (!++b) break;
+     switch (*b){
+ 	case '1':
+ 	case '2':
+ 	case '3': flag = *b; b += 2;
+ 		  for (k = 0; b[k] && b[k] != FLAGSEP && b[k] != ','; k++);
+ 		  last = b[k];
+ 		  b[k] = '\0';
+ 		  if (flag == '2' || flag == '3'){
+ 		     tmpd = strchr (b, MDFLAGC(Draft))   ? T : NIL;
+ 		     tmpf = strchr (b, MDFLAGC(Flagged)) ? T : NIL;
+ 		     tmpr = strchr (b, MDFLAGC(Replied)) ? T : NIL;
+ 		     tmps = strchr (b, MDFLAGC(Seen))    ? T : NIL;
+ 		     tmpt = strchr (b, MDFLAGC(Trashed)) ? T : NIL;
+ 		  }
+ 		  b[k] = last;
+ 		  b += k;
+ 		  for (; tmp[offset] && tmp[offset] != FLAGSEP; offset++);
+ 		  offset++;
+ 		break;
+ 	default: break;	/* Should we crash?... Nahhh */
+     }
+   }
+   if(d) *d = tmpd;
+   if(f) *f = tmpf;
+   if(r) *r = tmpr;
+   if(s) *s = tmps;
+   if(t) *t = tmpt;
+ }
+ 
+ int
+ maildir_message_in_list(char *msgname, struct direct **names, 
+ 		unsigned long bottom, unsigned long top, unsigned long *pos)
+ {
+   unsigned long middle = (bottom + top)/2;
+   int test;
+ 
+   if (!msgname)
+      return NIL;
+ 
+   if (pos) *pos = middle;
+ 
+   if (same_maildir_file(msgname, names[middle]->d_name))
+      return T;
+ 
+   if (middle == bottom){	 /* 0 <= 0 < 1 */
+      int rv = NIL;
+      if (same_maildir_file(msgname, names[middle]->d_name)){
+ 	rv = T;
+ 	if (pos) *pos = middle;
+      }
+      else
+        if (same_maildir_file(msgname, names[top]->d_name)){
+ 	rv = T;
+ 	if (pos) *pos = top;
+        }
+      return rv;
+   }
+ 
+   test = comp_maildir_file(msgname, names[middle]->d_name);
+ 
+   if (top <= bottom)
+       return test ? NIL : T;
+ 
+   if (test < 0 ) /* bottom <  msgname < middle */
+      return maildir_message_in_list(msgname, names, bottom, middle, pos);
+   else if (test > 0)  /* middle < msgname < top */
+      return maildir_message_in_list(msgname, names, middle, top, pos);
+   else return T;
+ }
+ 
+ void
+ maildir_abort(MAILSTREAM *stream)
+ {
+   if (LOCAL){
+     DirNamesType i;
+ 
+     if(LOCAL->candouid)
+       maildir_read_uid(stream, NULL, &stream->uid_validity);
+     if (LOCAL->dir) fs_give ((void **) &LOCAL->dir);
+     for (i = Cur; i < EndDir; i++)
+       if(LOCAL->path[i]) fs_give ((void **) &LOCAL->path[i]);
+     fs_give ((void **) &LOCAL->path);
+     if (LOCAL->buf) fs_give ((void **) &LOCAL->buf);
+     if(LOCAL->uidtempfile){
+       unlink(LOCAL->uidtempfile);
+       fs_give ((void **) &LOCAL->uidtempfile);
+     }
+     fs_give ((void **) &stream->local);
+   }
+   if (mdfpath) fs_give((void **)&mdfpath);
+   stream->dtb = NIL;
+ }
+ 
+ int
+ maildir_contains_folder(char *dirname, char *name)
+ {
+   char tmp[MAILTMPLEN], tmp2[MAILTMPLEN];
+   int rv = 0;
+   DIR *dir;
+   struct direct *d;
+ 
+   maildir_file_path(dirname, tmp2, sizeof(tmp2));
+   if(name){
+     strcat(tmp2,"/");
+     strcat(tmp2, name);
+   }
+ 
+   if (!(dir = opendir (tmp2)))
+      return NIL;
+ 
+   while ((d = readdir(dir)) != NULL){
+     if (strcmp(d->d_name, ".") && strcmp(d->d_name,"..")
+ 	&& strcmp(d->d_name, MDNAME(Cur)) 
+ 	&& strcmp(d->d_name, MDNAME(Tmp)) 
+ 	&& strcmp(d->d_name, MDNAME(New))){
+ 
+        snprintf(tmp, sizeof(tmp), "%s/%s", tmp2, d->d_name);
+        if(maildir_valid(tmp)){
+ 	  rv++;
+ 	  break;
+        }
+     }
+   }
+   closedir(dir);
+   return rv;
+ }
+ 
+ int
+ maildir_is_dir(char *dirname, char *name)
+ {
+   char tmp[MAILTMPLEN];
+   struct stat sbuf;
+ 
+   maildir_file_path(dirname, tmp, sizeof(tmp));
+   if(name){
+     strcat(tmp, "/");
+     strcat(tmp, name);
+   }
+   strcat(tmp, "/");
+   strcat(tmp, MDDIR);
+ 
+   return ((stat(tmp, &sbuf) == 0) && S_ISREG (sbuf.st_mode)) ? 1 : 0;
+ }
+ 
+ int
+ maildir_dir_is_empty(char *mailbox)
+ {
+   char tmp[MAILTMPLEN], tmp2[MAILTMPLEN], tmp3[MAILTMPLEN],*s;
+   int rv = 1, courier = IS_COURIER(mailbox);
+   DIR *dir;
+   struct direct *d;
+   struct stat sbuf;
+ 
+   maildir_file_path(mailbox, tmp2, sizeof(tmp2));
+ 
+   if(courier){
+      strcpy(tmp3, tmp2);
+      if(s = strrchr(tmp2, '/'))
+ 	*s = '\0';
+   }
+ 
+   if (!(dir = opendir (tmp2)))
+      return rv;
+ 
+   if(courier){
+      while((d = readdir(dir)) != NULL){
+         snprintf(tmp, sizeof(tmp), "%s/%s", tmp2, d->d_name);
+ 	if(!strncmp(tmp, tmp3, strlen(tmp3)) 
+ 	   && tmp[strlen(tmp3)] == '.'){
+ 	   rv = 0;
+ 	   break;
+ 	}
+      }
+   }
+   else
+     while ((d = readdir(dir)) != NULL){
+       snprintf(tmp, sizeof(tmp), "%s/%s", tmp2, d->d_name);
+       if (strcmp(d->d_name, ".") 
+ 	&& strcmp(d->d_name,"..")
+ 	&& strcmp(d->d_name, MDNAME(Cur)) 
+ 	&& strcmp(d->d_name, MDNAME(Tmp)) 
+ 	&& strcmp(d->d_name, MDNAME(New))
+ 	&& strcmp(d->d_name, MDDIR)
+ 	&& strcmp(d->d_name, MDUIDVALIDITY)
+ 	&& !(d->d_name[0] == '.' 
+ 		&& stat (tmp,&sbuf) == 0 
+ 		&& S_ISREG(sbuf.st_mode))){
+ 	   rv = 0;
+ 	   break;
+        }
+     }
+   closedir(dir);
+   return rv;
+ }
+ 
+ void
+ maildir_get_file (MAILDIRFILE **mdfile)
+ {
+   MAILDIRFILE *md;
+ 
+   md = (MAILDIRFILE *) fs_get(sizeof(MAILDIRFILE));
+   memset(md, 0, sizeof(MAILDIRFILE));
+   *mdfile = md;
+ }
+ 
+ void
+ maildir_free_file (void **mdfile)
+ {
+   MAILDIRFILE *md = (mdfile && *mdfile) ? (MAILDIRFILE *) *mdfile : NULL;
+ 
+   if (md){
+      if (md->name) fs_give((void **)&md->name);
+      fs_give((void **)&md);
+   }
+ }
+ 
+ void
+ maildir_free_file_only (void **mdfile)
+ {
+   MAILDIRFILE *md = (mdfile && *mdfile) ? (MAILDIRFILE *) *mdfile : NULL;
+ 
+   if (md && md->name) 
+      fs_give((void **)&md->name);
+ }
+ 
+ int
+ maildir_any_new_msgs(char *mailbox)
+ {
+   char tmp[MAILTMPLEN];
+   int rv = NIL;
+   DIR *dir;
+   struct direct *d;
+ 
+   MDFLD(tmp, mailbox, New);
+ 
+   if (!(dir = opendir (tmp)))
+      return rv;
+ 
+   while ((d = readdir(dir)) != NULL){
+     if (d->d_name[0] == '.')
+ 	continue;
+     rv = T;
+     break;
+   }
+   closedir(dir);
+   return rv;
+ }
+ 
+ 
+ void
+ maildir_get_date(MAILSTREAM *stream, unsigned long msgno)
+ {
+   MESSAGECACHE *elt;
+   struct tm *t;
+   time_t ti;
+   int i,k;
+ 
+   elt = mail_elt (stream,msgno);
+   if(elt && elt->year != 0)
+     return;
+   if ((ti = mdfntoul(MDFILE(elt))) > 0L && (t = gmtime(&ti))){
+      i = t->tm_hour * 60 + t->tm_min;
+      k = t->tm_yday;
+      t = localtime(&ti);
+      i = t->tm_hour * 60 + t->tm_min - i;
+      if((k = t->tm_yday - k) != 0) 
+ 	i += ((k < 0) == (abs (k) == 1)) ? -24*60 : 24*60;
+      k = abs (i);
+      elt->hours = t->tm_hour; 
+      elt->minutes = t->tm_min; 
+      elt->seconds = t->tm_sec;
+      elt->day = t->tm_mday; elt->month = t->tm_mon + 1;
+      elt->year = t->tm_year - (BASEYEAR - 1900);
+      elt->zoccident = (k == i) ? 0 : 1;
+      elt->zhours = k/60;
+      elt->zminutes = k % 60;
+   }
+ }
+ 
+ /* Support for Courier Style directories 
+    When this code is complete there will be two types of support, which 
+    will be configurable. The problem is the following: In Courier style 
+    folder structure, a "folder" may have a subfolder called 
+    "folder.subfolder", which is not natural in the file system in the 
+    sense that I can not stat for "folder.subfolder" wihtout knowing what 
+    "subfolder" is. It needs to be guessed. Because of this I need to look 
+    in the list of folders if there is a folder with a name 
+    "folder.subfolder", before I can say if the folder is dual or not. One 
+    can avoid this annoyance if one ignores the problem by declaring that 
+    every folder is dual. I will however code as the default the more 
+    complicated idea of scaning the containing directory each time it is 
+    modified and search for subfolders, and list the entries it found.
+  */
+ 
+ int courier_dir_select (const struct direct *name)
+ {
+  return name->d_name[0] == '.' && (strlen(name->d_name) > 2
+ 	|| (strlen(name->d_name) == 2 &&  name->d_name[1] != '.'));
+ }
+ 
+ int courier_dir_sort (const struct direct **d1, const struct direct **d2)
+ {
+   const struct direct *e1 = *(const struct direct **) d1;
+   const struct direct *e2 = *(const struct direct **) d2;
+ 
+   return strcmp((char *) e1->d_name, (char *) e2->d_name);
+ }
+ 
+ void courier_free_cdir (COURIER_S **cdir)
+ {
+   int i;
+ 
+   if (!*cdir)
+      return;
+ 
+   if ((*cdir)->path) fs_give((void **)&((*cdir)->path));
+   for (i = 0; i < (*cdir)->total; i++)
+     if((*cdir)->data[i]->name) fs_give((void **)&((*cdir)->data[i]->name));
+   fs_give((void **)&((*cdir)->data));
+   fs_give((void **)&(*cdir));
+ }
+ 
+ COURIER_S *courier_get_cdir (int total)
+ {
+  COURIER_S *cdir;
+ 
+  cdir = (COURIER_S *)fs_get(sizeof(COURIER_S));
+  memset(cdir, 0, sizeof(COURIER_S));
+  cdir->data = (COURIERLOCAL **) fs_get(total*sizeof(COURIERLOCAL *));
+  memset(cdir->data, 0, sizeof(COURIERLOCAL *));
+  cdir->total = total;
+  return cdir;
+ }
+ 
+ int courier_search_list(COURIERLOCAL **data, char *name, int first, int last)
+ {
+   int try = (first + last)/2;
+ 
+   if(!strstr(data[try]->name, name)){
+      if(first == try) /* first == last || first + 1 == last */
+ 	return strstr(data[last]->name, name) ? 1 : 0;
+      if(strcmp(data[try]->name, name) < 0) /*data[try] < name < data[end] */
+ 	return courier_search_list(data, name, try, last);
+      else	/* data[begin] < name < data[try] */
+ 	return courier_search_list(data, name, first, try);
+   }
+   return 1;
+ }
+ 
+ /* Lists all directories that are subdirectories of a given directory */
+ 
+ COURIER_S *courier_list_dir(char *curdir)
+ {
+   struct direct **names = NIL;
+   struct stat sbuf;
+   unsigned long ndir;
+   COURIER_S *cdir = NULL;
+   char tmp[MAILTMPLEN], tmp2[MAILTMPLEN], pathname[MAILTMPLEN], 
+ 	realname[MAILTMPLEN];
+   int i, j, scand, td;
+ 
+   /* There are two cases, either curdir is 
+  	 #mc/INBOX.	 #mc/INBOX.foo
+ 	or
+ 	 #mc/Maildir/. 	 #mc/Maildir/.foo
+    */
+   strcpy(tmp,curdir + 4);
+   if(!strncmp(ucase(tmp), "INBOX", 5))
+     strcpy(tmp, "#mc/INBOX.");
+   else{
+    strcpy(tmp, curdir);
+    for (i = strlen(tmp) - 1; tmp[i] && tmp[i] != '/'; i--);
+    tmp[i+2] = '\0'; 	/* keep the last "." intact */
+   }
+   maildir_file_path(tmp, realname, sizeof(realname));
+   maildir_scandir (realname, &names, &ndir, &scand, COURIER);
+ 
+   if (scand > 0){
+      cdir = courier_get_cdir(ndir);
+      cdir->path = cpystr(realname);
+      for(i = 0, j = 0; i < ndir; i++){
+         td = realname[strlen(realname) - 1] == '.'
+ 		&& *names[i]->d_name == '.';
+ 	snprintf(tmp2, sizeof(tmp2), "%s%s", tmp, names[i]->d_name+1);
+ 	snprintf(pathname, sizeof(pathname), "%s%s", realname, names[i]->d_name + td);
+ 	if(stat(pathname, &sbuf) == 0 && S_ISDIR(sbuf.st_mode)){
+ 	   cdir->data[j] = (COURIERLOCAL *) fs_get(sizeof(COURIERLOCAL));
+ 	   cdir->data[j++]->name = cpystr(tmp2);
+ 	}
+ 	fs_give((void **)&names[i]);
+      }
+      cdir->total = j;
+      if(cdir->total == 0)
+         courier_free_cdir(&cdir);
+   }
+   if(names)
+     fs_give((void **) &names);
+   return cdir;
+ }
+ 
+ void
+ courier_list_info(COURIER_S **cdirp, char *data, int i)
+ {
+    long style = (long) maildir_parameters(GET_COURIERSTYLE, NIL);
+    COURIER_S *cdir = *cdirp;
+ 
+    if(maildir_valid(cdir->data[i]->name)){
+       if(courier_search_list(cdir->data, data, 0, cdir->total - 1))
+ 	 cdir->data[i]->attribute = LATT_HASCHILDREN;
+       else
+ 	 cdir->data[i]->attribute = (style == COURIER)
+ 				? LATT_HASNOCHILDREN : LATT_NOINFERIORS;
+    }
+    else
+       cdir->data[i]->attribute = LATT_NOSELECT;
+       cdir->data[i]->attribute += maildir_any_new_msgs(cdir->data[i]->name) 
+ 					? LATT_MARKED : LATT_UNMARKED;
+ }
+ 
+ /* UID Support */
+ /* Yes, I know I procastinated a lot about this, but here it is finally */
+ 
+ /* return code:
+    bigger than zero: this session can assign uids
+    zero: this session will not assign uid
+    smaller than zero: this session temporarily suspends assigning uids 
+  */
+ int
+ maildir_can_assign_uid (MAILSTREAM *stream)
+ {
+   unsigned int rv = 0;
+   int ownuid, existuid;
+   unsigned long t;
+   char tmp[MAILTMPLEN], tmp2[MAILTMPLEN], *p, *s;
+   DIR *dir;
+   struct direct *d;
+ 
+   if(!stream || stream->rdonly 
+ 	|| !LOCAL || !LOCAL->dir || !(dir = opendir(LOCAL->dir)))
+     return 0;
+ 
+   if(mypid == (pid_t) 0)
+     mypid = getpid();
+ 
+   snprintf(tmp, sizeof(tmp), "%s.%d", MDUIDTEMP, mypid);
+ 
+   ownuid = existuid = 0;
+   s = NULL;
+   while ((d = readdir(dir)) != NULL){
+     if(strncmp(d->d_name, tmp, strlen(tmp)) == 0){
+ 	existuid++; ownuid++;
+ 	if(ownuid > 1){
+ 	  snprintf(tmp2, sizeof(tmp), "%s/%s", LOCAL->dir, d->d_name);
+ 	  unlink(tmp2);
+ 	  if(s){
+ 	     snprintf(tmp2, sizeof(tmp2), "%s/%s", LOCAL->dir, s);
+ 	     unlink(tmp2);
+ 	     fs_give((void **)&s);
+ 	  }
+ 	}
+ 	else
+ 	  s = cpystr(d->d_name);
+     }
+     else if(strncmp(d->d_name, MDUIDTEMP, strlen(MDUIDTEMP)) == 0)
+         existuid++;
+   }
+ 
+   closedir(dir);
+   if(s)
+     fs_give((void **)&s);
+ 
+   if(ownuid == 1 && existuid == 1)
+      rv = 1;
+ 
+   if(ownuid == 0 && existuid == 0){ /* nobody owns the uid? */
+     FILE *fp;
+     snprintf(tmp, sizeof(tmp), "%s/%s.%d.%lu", LOCAL->dir, MDUIDTEMP, mypid, time(0));
+     if(fp = fopen(tmp, "w")){
+       fclose(fp);
+       if(LOCAL->uidtempfile)
+ 	 fs_give((void **)&LOCAL->uidtempfile);
+       LOCAL->uidtempfile = cpystr(tmp);
+     }
+     rv = 1;
+   }
+ 
+   if(ownuid == 0 && existuid > 0) /* someone else owns uid assignment */
+     return 0;
+ 
+   /* if we own the uid, check that we do not own it more than once
+    * or that we share ownership. If any of these situations happens,
+    * give up the ownership until we can recover it
+    */
+ 
+   if(ownuid > 0){
+     if(ownuid > 1)	/* impossible, two lock files for the same session */
+        return (-1)*ownuid;
+ 
+     if(ownuid != existuid){	/* lock files for different sessions */
+       if(LOCAL->uidtempfile){
+ 	 unlink(LOCAL->uidtempfile);
+ 	 fs_give((void **)&LOCAL->uidtempfile);
+       }
+       return (-1)*ownuid;
+     }
+   }
+ 
+   return rv;
+ }
+ 
+ void
+ maildir_read_uid(MAILSTREAM *stream, unsigned long *uid_last, 
+ 			unsigned long *uid_validity)
+ {
+   int createuid, deleteuid = 0;
+   char tmp[MAILTMPLEN], *s = NULL;
+   DIR *dir;
+   struct direct *d;
+ 
+   if(uid_last) *uid_last = 0L;
+   if(uid_last && uid_validity) *uid_validity = time(0);
+   if(!stream || !LOCAL || !LOCAL->dir || !(dir = opendir(LOCAL->dir)))
+     return;
+ 
+   while ((d = readdir(dir)) != NULL){
+       if(!strncmp(d->d_name, MDUIDLAST, strlen(MDUIDLAST)))
+        break;
+   }
+   createuid = d == NULL ? 1 : 0;
+   if(uid_last == NULL)
+     deleteuid++;
+   if(d){
+      if(uid_last){
+ 	s = d->d_name + strlen(MDUIDLAST) + 1;
+ 	*uid_last = strtoul(s, &s, 10);
+ 	if(!s || *s != '.'){
+ 	  deleteuid++;
+ 	  createuid++;
+ 	  *uid_last = 0L;
+ 	}
+      }
+      if(s && *s == '.'){
+         if(uid_validity){
+ 	  s++;
+ 	  *uid_validity = strtoul(s, &s, 10);
+ 	  if(s && *s != '\0'){
+ 	    *uid_validity = time(0);
+ 	    deleteuid++;
+ 	    createuid++;
+ 	  }
+ 	}
+      }
+      else{
+ 	deleteuid++;
+ 	createuid++;
+      }
+   }
+   if(deleteuid){
+      snprintf(tmp, sizeof(tmp), "%s/%s", LOCAL->dir, d->d_name);
+      unlink(tmp);
+   }
+   if(createuid)
+      maildir_write_uid(stream, (uid_last ? *uid_last : stream->uid_last), 
+ 		uid_validity ? *uid_validity : time(0));
+   closedir(dir);
+ }
+ 
+ void
+ maildir_write_uid(MAILSTREAM *stream, unsigned long uid_last, 
+ 			unsigned long uid_validity)
+ {
+   char tmp[MAILTMPLEN];
+   FILE *fp;
+ 
+   if(!stream || stream->rdonly || !LOCAL || !LOCAL->dir)
+     return;
+ 
+   snprintf(tmp, sizeof(tmp), "%s/%s.%010lu.%010lu", LOCAL->dir, MDUIDLAST, 
+ 			uid_last, uid_validity);
+   if(fp = fopen(tmp, "w"))
+      fclose(fp);
+ }
+ 
+ unsigned long 
+ maildir_get_uid(char *name)
+ {
+   char *s;
+   unsigned long rv = 0L;
+ 
+   if(!name || (s = strstr(name,MDUIDSEP)) == NULL)
+     return rv;
+ 
+   s += strlen(MDUIDSEP);
+   rv = strtoul(s, NULL, 10);
+   return rv;
+ }
+ 
+ 
+ void
+ maildir_delete_uid(MAILSTREAM *stream, unsigned long msgno)
+ {
+   char old[MAILTMPLEN], new[MAILTMPLEN], *s, *t;
+   MESSAGECACHE *elt;
+ 
+   elt = mail_elt(stream, msgno);
+   if(!stream || !elt || !elt->private.spare.ptr || !LOCAL || !LOCAL->dir)
+     return;
+ 
+   snprintf(old, sizeof(old), "%s/%s/%s", LOCAL->dir, MDNAME(Cur), MDFILE(elt));
+   t = MDFILE(elt);
+   if(s = strstr(MDFILE(elt), MDUIDSEP)){
+      *s = '\0';
+      s += strlen(MDUIDSEP);
+      strtoul(s, &s, 10);
+      snprintf(new, sizeof(new), "%s/%s/%s%s", LOCAL->dir, MDNAME(Cur), t, s);
+      if(rename(old, new) == 0){
+ 	maildir_free_file_only ((void **)&elt->private.spare.ptr);
+ 	s = strrchr(new, '/');
+ 	MDFILE(elt) = cpystr(s+1);
+      }
+      elt->private.uid = 0L;
+   }
+ }
+ 
+ void
+ maildir_assign_uid(MAILSTREAM *stream, unsigned long msgno, unsigned long uid)
+ {
+   int createuid, deleteuid = 0;
+   char old[MAILTMPLEN], new[MAILTMPLEN], *s, *t;
+   MESSAGECACHE *elt;
+ 
+   elt = mail_elt(stream, msgno);
+   if(!stream || !elt || !elt->private.spare.ptr || !LOCAL || !LOCAL->dir)
+     return;
+ 
+   maildir_delete_uid(stream, msgno);
+   snprintf(old, sizeof(old), "%s/%s/%s", LOCAL->dir, MDNAME(Cur), MDFILE(elt));
+   t = MDFILE(elt);
+   if((s = strrchr(MDFILE(elt),FLAGSEP)) != NULL){
+      *s++ = '\0';
+      snprintf(new, sizeof(new), "%s/%s/%s%s%lu%c%s", 
+ 		LOCAL->dir, MDNAME(Cur), t, MDUIDSEP, uid, FLAGSEP, s);
+      if(rename(old, new) == 0){
+ 	maildir_free_file_only ((void **)&elt->private.spare.ptr);
+ 	s = strrchr(new, '/');
+ 	MDFILE(elt) = cpystr(s+1);
+ 	stream->uid_validity = time(0);
+      }
+      elt->private.uid = uid;
+   }
+ }
+ 
+ void
+ maildir_uid_renew_tempfile(MAILSTREAM *stream)
+ {
+   char tmp[MAILTMPLEN];
+ 
+   if(!stream || stream->rdonly 
+ 	|| !LOCAL || !LOCAL->candouid || !LOCAL->dir || !LOCAL->uidtempfile)
+     return;
+ 
+   if(mypid == (pid_t) 0)
+     mypid = getpid();
+ 
+   snprintf(tmp, sizeof(tmp), "%s/%s.%d.%lu", LOCAL->dir, MDUIDTEMP, mypid, time(0));
+   if(rename(LOCAL->uidtempfile, tmp) == 0){
+       fs_give((void **)&LOCAL->uidtempfile);
+       LOCAL->uidtempfile = cpystr(tmp);
+   }
+ }
diff -rc alpine-2.11/imap/src/osdep/unix/maildir.h alpine-2.11.I.USE/imap/src/osdep/unix/maildir.h
*** alpine-2.11/imap/src/osdep/unix/maildir.h	2013-12-01 16:41:34.000000000 -0700
--- alpine-2.11.I.USE/imap/src/osdep/unix/maildir.h	2013-12-01 16:34:08.000000000 -0700
***************
*** 0 ****
--- 1,226 ----
+ /* 
+  * A few definitions that try to make this module portable to other
+  * platforms (e.g. Cygwin). This module is based on the information from
+  * http://cr.yp.to/proto/maildir.html
+  */
+ 
+ /* First we deal with the separator character */
+ #ifndef FLAGSEP
+ #define FLAGSEP ':'
+ #endif
+ #define SIZESEP ','
+ 
+ const char sep1[] = {FLAGSEP, '1', ',', '\0'}; /* experimental semantics*/
+ const char sep2[] = {FLAGSEP, '2', ',', '\0'}; /* Flags Information	*/
+ const char sep3[] = {FLAGSEP, '3', ',', '\0'}; /* Grrrr....		*/
+ 
+ const char *sep[] = { sep1, sep2, sep3, NULL};
+ 
+ #define MDSEP(i)  sep[((i) - 1)]
+ 
+ /* Now we deal with flags. Woohoo! */
+ typedef enum  {Draft, Flagged, Passed, Replied, Seen, Trashed, 
+ 	       EmptyFlag, EndFlags} MdFlagNamesType;
+ const int mdimapflags[] = {Draft, Flagged, Replied, Seen, Trashed, EmptyFlag, EndFlags};
+ const int mdkwdflags[]  = {Passed, EmptyFlag, EndFlags};
+ 
+ /* this array lists the codes for mdflgnms (maildir flag names) above */
+ const char *mdflags[] = { "D", "F", "P", "R", "S", "T", "", NULL};
+ /* and as characters too */
+ const char cmdflags[] = { 'D', 'F', 'P', 'R', 'S', 'T', '0', '\0'};
+ 
+ /* MDFLAG(Seen, elt->seen) */
+ #define MDFLAG(i,j) mdflags[j ? (i) : EmptyFlag]
+ /* MDFLAGC(Seen) */
+ #define MDFLAGC(i) cmdflags[(i)]
+ 
+ /* Now we deal with the directory structure */
+ typedef enum {Cur, Tmp, New, EndDir} DirNamesType;
+ char *mdstruct[] = {"cur", "tmp", "new", NULL};
+ #define MDNAME(i) mdstruct[(i)]
+ #define MDFLD(tmp, dir, i) sprintf((tmp),"%s/%s", (dir), mdstruct[(i)])
+ #define MSGPATH(tmp, dir, msg,i) sprintf((tmp),"%s/%s/%s", (dir), mdstruct[(i)],(msg))
+ 
+ /* Files associated to a maildir directory */
+ 
+ #define MDUIDVALIDITY	".uidvalidity"	/* support for old maildirs    */
+ #define MDDIR		".mdir"		/* this folder is a directory  */
+ #define MDUIDLAST	".uidlast"	/* last assigned uid	       */
+ #define MDUIDTEMP	".uidtemp"	/* We assign uid's no one else */
+ 
+ 
+ 
+ /* Support of Courier Structure */
+ #define CCLIENT 0
+ #define COURIER 1
+ #define IS_CCLIENT(t) \
+ 		(((t) && (t)[0] == '#' && ((t)[1] == 'm' || (t)[1] == 'M')\
+ 		&& ((t)[2] == 'd' || (t)[2] == 'D')\
+ 		&& (t)[3] == '/'  && (t)[4] != '\0') ? 1 : 0)
+ 
+ #define IS_COURIER(t) \
+ 		(((t) && (t)[0] == '#' && ((t)[1] == 'm' || (t)[1] == 'M')\
+ 		&& ((t)[2] == 'c' || (t)[2] == 'C')\
+ 		&& (t)[3] == '/'  && (t)[4] != '\0') ? 1 : 0)
+ #define MDPREFIX(s) ((s) ? "#mc/" : "#md/")
+ #define MDSEPARATOR(s) ((s) ? '.' : '/')
+ 
+ /* UID Support */
+ 
+ #define MAXTEMPUID (unsigned long) 180L
+ const char mduid[] = {',','u','=','\0'};
+ #define MDUIDSEP mduid
+ 
+ 
+ /* Now we deal with messages filenames */
+ char mdlocaldomain[MAILTMPLEN+1] = {'\0'};
+ pid_t mypid = (pid_t) 0;
+ static char *mdfpath = NULL;
+ static char myMdInboxDir[50] = { '\0' };/* Location of the Maildir INBOX */
+ static long CourierStyle = CCLIENT;
+ 
+ #define CHUNK	16384	/* from unix.h */
+ 
+ typedef struct courier_local {
+   char *name;		/* name of directory/folder */
+   int attribute;	/* attributes (children/marked/etc) */
+ } COURIERLOCAL;
+ 
+ typedef struct courier {
+   char *path;			/* Path to collection */
+   time_t scantime;		/* time at which information was generated */
+   int total;			/* total number of elements in data */
+   COURIERLOCAL **data;
+ } COURIER_S;
+ 
+ /* In gdb this is the  *(struct maildir_local *)stream->local structure */
+ typedef struct maildir_local {
+   unsigned int dirty : 1;	/* diskcopy needs updating 		*/
+   unsigned int courier : 1;	/* It is Courier style file system	*/
+   unsigned int link : 1;	/* There is a symbolic link		*/
+   int candouid;			/* we can assign uids and no one else	*/
+   char *uidtempfile;		/* path to uid temp file		*/
+   int fd;			/* fd of open message			*/
+   char *dir;			/* mail directory name			*/
+   char **path;			/* path to directories cur, new and tmp	*/
+   unsigned char *buf;		/* temporary buffer 			*/
+   unsigned long buflen;		/* current size of temporary buffer 	*/
+   time_t scantime;		/* last time directory scanned 		*/
+ } MAILDIRLOCAL;
+ 
+ /* Convenient access to local data */
+ #define LOCAL ((MAILDIRLOCAL *) stream->local)
+ 
+ typedef struct maildir_file_info {
+    char *name;		/* name of the file			   */
+    DirNamesType loc;	/* location of this file		   */
+    unsigned long pos;	/* place in list where this file is listed */
+    off_t size;		/* size in bytes, on disk */
+    time_t atime;	/* last access time */
+    time_t mtime;	/* last modified time */
+    time_t ctime;	/* last changed time */
+ } MAILDIRFILE;
+ 
+ #define MDFILE(F) (((MAILDIRFILE *)((F)->private.spare.ptr))->name)
+ #define MDLOC(F)  (((MAILDIRFILE *)((F)->private.spare.ptr))->loc)
+ #define MDPOS(F)  (((MAILDIRFILE *)((F)->private.spare.ptr))->pos)
+ #define MDSIZE(F)  (((MAILDIRFILE *)((F)->private.spare.ptr))->size)
+ #define MDATIME(F)  (((MAILDIRFILE *)((F)->private.spare.ptr))->atime)
+ #define MDMTIME(F)  (((MAILDIRFILE *)((F)->private.spare.ptr))->mtime)
+ #define MDCTIME(F)  (((MAILDIRFILE *)((F)->private.spare.ptr))->ctime)
+ 
+ /* Function prototypes */
+ 
+ DRIVER *maildir_valid (char *name);
+ MAILSTREAM *maildir_open (MAILSTREAM *stream);
+ void maildir_close (MAILSTREAM *stream, long options);
+ long maildir_ping (MAILSTREAM *stream);
+ void maildir_check (MAILSTREAM *stream);
+ long maildir_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags);
+ char *maildir_header (MAILSTREAM *stream,unsigned long msgno,
+ 		unsigned long *length, long flags);
+ void maildir_list (MAILSTREAM *stream,char *ref,char *pat);
+ void *maildir_parameters (long function,void *value);
+ int maildir_create_folder (char *mailbox);
+ long maildir_create (MAILSTREAM *stream,char *mailbox);
+ void maildir_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt); /*check */
+ long maildir_expunge (MAILSTREAM *stream, char *sequence, long options);
+ long maildir_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options);
+ long maildir_append (MAILSTREAM *stream,char *mailbox, append_t af, void *data);
+ long maildir_delete (MAILSTREAM *stream,char *mailbox);
+ long maildir_rename (MAILSTREAM *stream,char *old,char *new);
+ long maildir_sub (MAILSTREAM *stream,char *mailbox);
+ long maildir_unsub (MAILSTREAM *stream,char *mailbox);
+ void maildir_lsub (MAILSTREAM *stream,char *ref,char *pat);
+ void courier_list (MAILSTREAM *stream,char *ref, char *pat);
+ 
+ /* utility functions */
+ void courier_realname (char *name, char *realname);
+ long maildir_dirfmttest (char *name);
+ char *maildir_file (char *dst,char *name);
+ int maildir_select (const struct direct *name);
+ int maildir_namesort (const struct direct **d1, const struct direct **d2);
+ unsigned long antoul (char *seed);
+ unsigned long mdfntoul (char *name);
+ int courier_dir_select (const struct direct *name);
+ int courier_dir_sort (const struct direct **d1, const struct direct **d2);
+ long maildir_canonicalize (char *pattern,char *ref,char *pat);
+ void maildir_list_work (MAILSTREAM *stream,char *subdir,char *pat,long level);
+ void courier_list_work (MAILSTREAM *stream,char *subdir,char *pat,long level);
+ int maildir_file_path(char *name, char *tmp, size_t sizeoftmp);
+ int maildir_valid_name (char *name);
+ int maildir_valid_dir (char *name);
+ int is_valid_maildir (char **name);
+ int maildir_message_exists(MAILSTREAM *stream,char *name, char *tmp);
+ char *maildir_remove_root(char *name);
+ char *maildir_text_work (MAILSTREAM *stream,MESSAGECACHE *elt, unsigned long *length,long flags);
+ unsigned long  maildir_parse_message(MAILSTREAM *stream, unsigned long msgno, 
+ 						DirNamesType dirtype);
+ int maildir_eliminate_duplicate (char *name, struct direct ***flist, 
+ 					unsigned long *nfiles);
+ int maildir_doscandir (char *name, struct direct ***flist, int flag);
+ unsigned long maildir_scandir (char *name, struct direct ***flist,
+ 			unsigned long *nfiles, int *scand, int flag);
+ void maildir_parse_folder (MAILSTREAM *stream, int full);
+ void  md_domain_name (void);
+ char  *myrootdir (char *name);
+ char  *mdirpath (void);
+ int   maildir_initial_check (MAILSTREAM *stream, DirNamesType dirtype);
+ unsigned long  maildir_parse_dir(MAILSTREAM *stream, unsigned long nmsgs, 
+    DirNamesType dirtype, struct direct **names, unsigned long nfiles, int full);
+ int same_maildir_file(char *name1, char *name2);
+ int comp_maildir_file(char *name1, char *name2);
+ int maildir_message_in_list(char *msgname, struct direct **names,
+ 		unsigned long bottom, unsigned long top, unsigned long *pos);
+ void maildir_getflag(char *name, int *d, int *f, int *r ,int *s, int *t);
+ int maildir_update_elt_maildirp(MAILSTREAM *stream, unsigned long msgno);
+ void maildir_abort (MAILSTREAM *stream);
+ int maildir_contains_folder(char *dirname, char *name);
+ int maildir_is_dir(char *dirname, char *name);
+ int maildir_dir_is_empty(char *mailbox);
+ int maildir_create_work (char *mailbox, int loop);
+ void maildir_get_file (MAILDIRFILE **mdfile);
+ void maildir_free_file (void **mdfile);
+ void maildir_free_file_only (void **mdfile);
+ int maildir_any_new_msgs(char *mailbox);
+ void maildir_get_date(MAILSTREAM *stream, unsigned long msgno);
+ void maildir_fast (MAILSTREAM *stream,char *sequence,long flags);
+ 
+ /* Courier server support */
+ void courier_free_cdir (COURIER_S **cdir);
+ COURIER_S *courier_get_cdir (int total);
+ int courier_search_list(COURIERLOCAL **data, char *name, int first, int last);
+ COURIER_S *courier_list_dir(char *curdir);
+ void courier_list_info(COURIER_S **cdirp, char *data, int i);
+ 
+ /* UID Support */
+ int maildir_can_assign_uid (MAILSTREAM *stream);
+ void maildir_read_uid(MAILSTREAM *stream, unsigned long *uid_last, 
+      			                   unsigned long *uid_validity);
+ void maildir_write_uid(MAILSTREAM *stream, unsigned long uid_last, 
+      			                   unsigned long uid_validity);
+ unsigned long maildir_get_uid(char *name);
+ void maildir_delete_uid(MAILSTREAM *stream, unsigned long msgno);
+ void maildir_assign_uid(MAILSTREAM *stream, unsigned long msgno, unsigned long uid);
+ void maildir_uid_renew_tempfile(MAILSTREAM *stream);
+ 
diff -rc alpine-2.11/imap/src/osdep/unix/Makefile alpine-2.11.I.USE/imap/src/osdep/unix/Makefile
*** alpine-2.11/imap/src/osdep/unix/Makefile	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/imap/src/osdep/unix/Makefile	2013-12-01 16:34:08.000000000 -0700
***************
*** 144,150 ****
  # However, mh needs to be before any sysinbox formats (such as mmdf or unix)
  # since otherwise INBOX won't work correctly when mh_allow_inbox is set.
  #
! DEFAULTDRIVERS=imap nntp pop3 mix mx mbx tenex mtx mh mmdf unix news phile
  CHUNKSIZE=65536
  
  # Normally no need to change any of these
--- 144,150 ----
  # However, mh needs to be before any sysinbox formats (such as mmdf or unix)
  # since otherwise INBOX won't work correctly when mh_allow_inbox is set.
  #
! DEFAULTDRIVERS=maildir courier imap nntp pop3 mix mx mbx tenex mtx mh mmdf unix news phile
  CHUNKSIZE=65536
  
  # Normally no need to change any of these
***************
*** 153,159 ****
  BINARIES=osdep.o mail.o misc.o newsrc.o smanager.o utf8.o utf8aux.o siglocal.o \
   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
!  unix.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o mix.o
  CFLAGS=-g
  
  CAT=cat
--- 153,159 ----
  BINARIES=osdep.o mail.o misc.o newsrc.o smanager.o utf8.o utf8aux.o siglocal.o \
   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
!  unix.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o mix.o maildir.o
  CFLAGS=-g
  
  CAT=cat
***************
*** 290,296 ****
  
  cyg:	# Cygwin - note that most local file drivers don't work!!
  	$(BUILD) `$(CAT) SPECIALS` OS=$@ \
! 	DEFAULTDRIVERS="imap nntp pop3 mbx unix phile" \
  	SIGTYPE=psx CHECKPW=cyg LOGINPW=cyg CRXTYPE=std \
  	SPOOLDIR=/var \
  	ACTIVEFILE=/usr/local/news/lib/active \
--- 290,296 ----
  
  cyg:	# Cygwin - note that most local file drivers don't work!!
  	$(BUILD) `$(CAT) SPECIALS` OS=$@ \
! 	DEFAULTDRIVERS="imap nntp pop3 mbx unix maildir phile" \
  	SIGTYPE=psx CHECKPW=cyg LOGINPW=cyg CRXTYPE=std \
  	SPOOLDIR=/var \
  	ACTIVEFILE=/usr/local/news/lib/active \
***************
*** 900,906 ****
  unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
  utf8.o: mail.h misc.h osdep.h utf8.h tmap.c widths.c
  utf8aux.o: mail.h misc.h osdep.h utf8.h
! 
  
  # OS-dependent
  
--- 900,906 ----
  unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
  utf8.o: mail.h misc.h osdep.h utf8.h tmap.c widths.c
  utf8aux.o: mail.h misc.h osdep.h utf8.h
! maildir.o: mail.h misc.h osdep.h maildir.h dummy.h
  
  # OS-dependent
  
diff -rc alpine-2.11/imap/src/osdep/unix/os_cyg.h alpine-2.11.I.USE/imap/src/osdep/unix/os_cyg.h
*** alpine-2.11/imap/src/osdep/unix/os_cyg.h	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/imap/src/osdep/unix/os_cyg.h	2013-12-01 16:34:08.000000000 -0700
***************
*** 47,52 ****
--- 47,53 ----
  #define setpgrp setpgid
  
  #define SYSTEMUID 18		/* Cygwin returns this for SYSTEM */
+ #define FLAGSEP ';'
  #define geteuid Geteuid
  uid_t Geteuid (void);
  
diff -rc alpine-2.11/patchlevel alpine-2.11.I.USE/patchlevel
*** alpine-2.11/patchlevel	2013-12-01 16:41:34.000000000 -0700
--- alpine-2.11.I.USE/patchlevel	2013-12-01 16:41:34.000000000 -0700
***************
*** 0 ****
--- 1 ----
+ char plevstamp[]="VERSION=22 created on Sun Dec  1 16:41:34 MST 2013";
diff -rc alpine-2.11/pico/basic.c alpine-2.11.I.USE/pico/basic.c
*** alpine-2.11/pico/basic.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/basic.c	2013-12-01 16:38:46.000000000 -0700
***************
*** 26,34 ****
   * framing, are hard.
   */
  #include        "headers.h"
! 
  #include "osdep/terminal.h"
  
  
  /*
   * Move the cursor to the
--- 26,35 ----
   * framing, are hard.
   */
  #include        "headers.h"
! #include	"../pith/osdep/color.h"
  #include "osdep/terminal.h"
  
+ int	indent_match(char **, LINE *, char *, int, int);
  
  /*
   * Move the cursor to the
***************
*** 285,291 ****
  gotobop(int f, int n)
  {
      int quoted, qlen;
!     UCS qstr[NLINE], qstr2[NLINE];
  
      if (n < 0)	/* the other way...*/
        return(gotoeop(f, -n));
--- 286,292 ----
  gotobop(int f, int n)
  {
      int quoted, qlen;
!     char qstr[NLINE], qstr2[NLINE], ind_str[NLINE], pqstr[NLINE];;
  
      if (n < 0)	/* the other way...*/
        return(gotoeop(f, -n));
***************
*** 297,302 ****
--- 298,311 ----
  	    curwp->w_dotp = lback(curwp->w_dotp);
  	    curwp->w_doto = 0;
  	}
+ 
+ 	if (indent_match(default_qstr(glo_quote_str, 1), curwp->w_dotp,ind_str, NLINE, 0)){
+ 	   if (n){ /* look for another paragraph ? */
+ 	      curwp->w_dotp = lback(curwp->w_dotp);
+ 	      continue;
+ 	   }
+ 	   break;
+ 	}
  	
  	/* scan line by line until we come to a line ending with
  	 * a <NL><NL> or <NL><TAB> or <NL><SPACE>
***************
*** 304,323 ****
  	 * PLUS: if there's a quote string, a quoted-to-non-quoted
  	 *	 line transition.
  	 */
! 	quoted = glo_quote_str ? quote_match(glo_quote_str, curwp->w_dotp, qstr, NLINE) : 0;
! 	qlen   = quoted ? ucs4_strlen(qstr) : 0;
  	while(lback(curwp->w_dotp) != curbp->b_linep
  	      && llength(lback(curwp->w_dotp)) > qlen
! 	      && (glo_quote_str
! 		  ? (quoted == quote_match(glo_quote_str,
! 					   lback(curwp->w_dotp),
! 					   qstr2, NLINE)
! 		     && !ucs4_strcmp(qstr, qstr2))
! 		  : 1)
! 	      && lgetc(curwp->w_dotp, qlen).c != TAB
! 	      && lgetc(curwp->w_dotp, qlen).c != ' ')
  	  curwp->w_dotp = lback(curwp->w_dotp);
  
  	if(n){
  	    /* keep looking */
  	    if(lback(curwp->w_dotp) == curbp->b_linep)
--- 313,370 ----
  	 * PLUS: if there's a quote string, a quoted-to-non-quoted
  	 *	 line transition.
  	 */
! 	quoted = quote_match(default_qstr(glo_quote_str, 1), curwp->w_dotp, qstr, NLINE, 0);
! 	qlen   = quoted ? strlen(qstr) : 0;
  	while(lback(curwp->w_dotp) != curbp->b_linep
  	      && llength(lback(curwp->w_dotp)) > qlen
! 	      && (quoted == quote_match(default_qstr(glo_quote_str, 1),
! 			lback(curwp->w_dotp), qstr2, NLINE, 0))
! 	      && !strcmp(qstr, qstr2)   /* processed string */
! 	      && (quoted == quote_match(default_qstr(glo_quote_str, 1),
! 			lback(curwp->w_dotp), qstr2, NLINE, 1))
! 	      && !strcmp(qstr, qstr2)   /* raw string */
! 	      && !indent_match(default_qstr(glo_quote_str, 1),
! 			lback(curwp->w_dotp),ind_str, NLINE, 0)
! 	      && !ISspace(lgetc(curwp->w_dotp, qlen).c))
  	  curwp->w_dotp = lback(curwp->w_dotp);
  
+ 	 /*
+ 	  * Ok, we made it here and we assume that we are at the begining
+ 	  * of the paragraph. Let's double check this now. In order to do
+ 	  * so we shell check if the first line was indented in a special
+ 	  * way.
+ 	  */
+ 	if(lback(curwp->w_dotp) == curbp->b_linep)
+ 	    break;
+ 	else{
+ 	     int i, j;
+ 
+ 	   /*
+ 	    * First we test if the preceding line is indented.
+ 	    * for the following test we need to have the raw values,
+ 	    * not the processed values
+ 	    */
+ 	   quote_match(default_qstr(glo_quote_str, 1), curwp->w_dotp, qstr, NLINE, 1);
+ 	   quote_match(default_qstr(glo_quote_str, 1), lback(curwp->w_dotp), qstr2, NLINE, 1);
+ 	   for (i = 0, j = 0;
+ 	        qstr[i] && qstr2[i] && (qstr[i] == qstr2[i]); i++, j++);
+ 	   for (; ISspace(qstr2[i]); i++);
+ 	   for (; ISspace(qstr[j]); j++);
+ 	   if ((indent_match(default_qstr(glo_quote_str, 1), lback(curwp->w_dotp),
+ 						ind_str, NLINE, 1)
+ 	       && (strlenis(qstr2) 
+ 			+ strlenis(ind_str) >= strlenis(qstr)))
+ 	      || (lback(curwp->w_dotp) != curbp->b_linep
+ 	         && llength(lback(curwp->w_dotp)) > qlen
+ 	         && (quoted == quote_match(default_qstr(glo_quote_str, 1),
+ 				lback(curwp->w_dotp), pqstr, NLINE, 0))
+ 		 && !strcmp(qstr, pqstr)
+ 		 && !ISspace(lgetc(curwp->w_dotp, qlen).c)
+ 		 && (strlenis(qstr2) > strlenis(qstr)))
+ 	         && !qstr2[i] && !qstr[j])
+ 		curwp->w_dotp = lback(curwp->w_dotp);
+ 	}
+ 
  	if(n){
  	    /* keep looking */
  	    if(lback(curwp->w_dotp) == curbp->b_linep)
***************
*** 330,336 ****
  	else{
  	  /* leave cursor on first word in para */
  	    curwp->w_doto = 0;
! 	    while(ucs4_isspace(lgetc(curwp->w_dotp, curwp->w_doto).c))
  	      if(++curwp->w_doto >= llength(curwp->w_dotp)){
  		  curwp->w_doto = 0;
  		  curwp->w_dotp = lforw(curwp->w_dotp);
--- 377,383 ----
  	else{
  	  /* leave cursor on first word in para */
  	    curwp->w_doto = 0;
! 	    while(ISspace(lgetc(curwp->w_dotp, curwp->w_doto).c))
  	      if(++curwp->w_doto >= llength(curwp->w_dotp)){
  		  curwp->w_doto = 0;
  		  curwp->w_dotp = lforw(curwp->w_dotp);
***************
*** 344,349 ****
--- 391,579 ----
      return(TRUE);
  }
  
+ unsigned char GetAccent()
+ {
+   UCS c,d;
+     c = GetKey();
+     if ((c == '?') || (c == '!')) {
+         d = c;
+         c = '\\';
+     }
+     else
+       if ((c == 's') || (c == 'S')){
+ 	 c =  d = 's';
+       }
+       else 
+ 	if ((c == 'l') || (c == 'L')){
+ 	   c =  d = 'l';
+ 	}
+ 	else
+           d = GetKey();
+ 	return accent(c,d);
+ }
+ 
+ int pineaccent(f,n)
+   int f,n;
+ { unsigned char e;
+    
+        if (e = GetAccent())
+           execute(e, 0, 1);
+        return 1;
+ }
+ 
+ unsigned char accent(f,n)
+ UCS f,n;
+ {  UCS c,d;
+ 
+        c =  f;
+        d =  n;
+        switch(c){
+         case '~' :  
+                    switch(d){
+                                case 'a' : return '\343';
+                                case 'n' : return '\361';
+                                case 'o' : return '\365';
+                                case 'A' : return '\303';
+                                case 'N' : return '\321';
+                                case 'O' : return '\325';
+                             }
+                        break;
+         case '\047' :
+                        switch(d){
+                                case 'a' : return '\341';
+                                case 'e' : return '\351';
+                                case 'i' : return '\355';
+                                case 'o' : return '\363';
+                                case 'u' : return '\372';
+                                case 'y' : return '\375';
+                                case 'A' : return '\301';
+                                case 'E' : return '\311';
+                                case 'I' : return '\315';
+                                case 'O' : return '\323';
+                                case 'U' : return '\332';
+                                case 'Y' : return '\335';
+                                     }
+                        break;
+         case '"' :
+                        switch(d){
+                                case 'a' : return '\344';
+                                case 'e' : return '\353';
+                                case 'i' : return '\357';
+                                case 'o' : return '\366';
+                                case 'u' : return '\374';
+                                case 'y' : return '\377';
+                                case 'A' : return '\304';
+                                case 'E' : return '\313';
+                                case 'I' : return '\317';
+                                case 'O' : return '\326';
+                                case 'U' : return '\334';
+                                     }
+                        break;
+         case '^' :
+                        switch(d){
+                                case 'a' : return '\342';
+                                case 'e' : return '\352';
+                                case 'i' : return '\356';
+                                case 'o' : return '\364';
+                                case 'u' : return '\373';
+                                case 'A' : return '\302';
+                                case 'E' : return '\312';
+                                case 'I' : return '\316';
+                                case 'O' : return '\324';
+                                case 'U' : return '\333';
+ 			       case '0' : return '\260';
+ 			       case '1' : return '\271';
+ 			       case '2' : return '\262';
+ 			       case '3' : return '\263';
+                                     }
+                        break;
+         case '`' :
+                        switch(d){
+                                case 'a' : return '\340';
+                                case 'e' : return '\350';
+                                case 'i' : return '\354';
+                                case 'o' : return '\362';
+                                case 'u' : return '\371';
+                                case 'A' : return '\300';
+                                case 'E' : return '\310';
+                                case 'I' : return '\314';
+                                case 'O' : return '\322';
+                                case 'U' : return '\331';
+                                     }
+                        break;
+         case 'o' :
+                        switch(d){
+                                case 'a' : return '\345';
+                                case 'A' : return '\305';
+ 			       case '/' : return '\370';
+ 			       case 'r' : return '\256';
+ 			       case 'R' : return '\256';
+ 			       case 'c' : return '\251';
+ 			       case 'C' : return '\251';
+ 				}
+                        break;
+ 	case '-' :
+ 		       switch(d){
+ 			       case 'o' : return '\272';
+ 			       case 'O' : return '\272';
+ 			       case '0' : return '\272';
+ 			       case 'a' : return '\252';
+ 			       case 'A' : return '\252';
+ 			       case 'l' : return '\243';
+ 			       case 'L' : return '\243';
+ 				}
+ 		       break;
+ 	case 'O' :
+ 		       switch(d){
+ 			       case '/' : return '\330';
+ 			       case 'r' : return '\256';
+ 			       case 'R' : return '\256';
+ 			       case 'c' : return '\251';
+ 			       case 'C' : return '\251';
+ 				}
+         case '/' :
+                        switch(d){
+                                case 'o' : return '\370';
+                                case 'O' : return '\330';
+ 				}
+                        break;
+         case 'a' :
+                        switch(d){
+                                case 'e' : return '\346';
+                                case 'E' : return '\346';
+ 				}
+                        break;
+         case 'A' :
+                        switch(d){
+                                 case 'E' : return '\306';
+                                case 'e' : return '\306';
+ 				}
+                        break;
+         case ',' :
+                        switch(d){
+                                case 'c' : return '\347';
+                                case 'C' : return '\307';
+                                     }
+                        break;
+         case '\\' :
+                        switch(d){
+                                case '?' : return '\277';
+                                case '!' : return '\241';
+                                     }
+                        break;
+        case 's' :
+                         switch(d){
+                                 case 's' : return '\337';
+                                      }
+ 			break;
+        case 'l' :
+                         switch(d){
+                                 case 'l' : return '\243';
+                                  }
+ 		break;
+        }
+        return '\0';
+ }
  
  /* 
   * go forword to the end of the current paragraph
***************
*** 353,360 ****
  int
  gotoeop(int f, int n)
  {
!     int quoted, qlen;
!     UCS qstr[NLINE], qstr2[NLINE];
  
      if (n < 0)	/* the other way...*/
        return(gotobop(f, -n));
--- 583,591 ----
  int
  gotoeop(int f, int n)
  {
!     int quoted, qlen, indented, changeqstr = 0;
!     int i,j, fli = 0; /* fli = first line indented a boolean variable */
!     char qstr[NLINE], qstr2[NLINE], ind_str[NLINE];
  
      if (n < 0)	/* the other way...*/
        return(gotobop(f, -n));
***************
*** 367,393 ****
  	      break;
  	}
  
  	/* scan line by line until we come to a line ending with
  	 * a <NL><NL> or <NL><TAB> or <NL><SPACE>
  	 *
  	 * PLUS: if there's a quote string, a quoted-to-non-quoted
  	 *	 line transition.
  	 */
! 	quoted = glo_quote_str
! 	  ? quote_match(glo_quote_str,
! 			curwp->w_dotp, qstr, NLINE) : 0;
! 	qlen   = quoted ? ucs4_strlen(qstr) : 0;
  	
  	while(curwp->w_dotp != curbp->b_linep
  	      && llength(lforw(curwp->w_dotp)) > qlen
! 	      && (glo_quote_str
! 		  ? (quoted == quote_match(glo_quote_str,
! 					   lforw(curwp->w_dotp),
! 					   qstr2, NLINE)
! 		     && !ucs4_strcmp(qstr, qstr2))
! 		  : 1)
! 	      && lgetc(lforw(curwp->w_dotp), qlen).c != TAB
! 	      && lgetc(lforw(curwp->w_dotp), qlen).c != ' ')
  	  curwp->w_dotp = lforw(curwp->w_dotp);
  
  	curwp->w_doto = llength(curwp->w_dotp);
--- 598,667 ----
  	      break;
  	}
  
+ 	/*
+ 	 * We need to figure out if this line is the first line of
+ 	 * a paragraph that has been indented in a special way. If this
+ 	 * is the case, we advance one more line before we use the
+ 	 * algorithm below
+ 	 */
+ 
+ 	if(curwp->w_dotp != curbp->b_linep){
+ 	   quote_match(default_qstr(glo_quote_str, 1), curwp->w_dotp, qstr, NLINE, 1);
+ 	   quote_match(default_qstr(glo_quote_str, 1), lforw(curwp->w_dotp), qstr2, NLINE, 1);
+ 	   indented = indent_match(default_qstr(glo_quote_str, 1), curwp->w_dotp, ind_str,
+ 							NLINE, 1);
+ 	   if (strlenis(qstr) 
+ 		+ strlenis(ind_str) < strlenis(qstr2)){
+ 		curwp->w_doto = llength(curwp->w_dotp);
+ 		if(n){    /* this line is a paragraph by itself */
+ 		   curwp->w_dotp = lforw(curwp->w_dotp);
+ 		   continue;
+ 		}
+ 		break;
+ 	   }
+ 	   for (i=0,j=0; qstr[i] && qstr2[i] && (qstr[i] == qstr2[i]);i++,j++);
+ 	   for (; ISspace(qstr[i]); i++);
+ 	   for (; ISspace(qstr2[j]); j++);
+ 	   if (!qstr[i] && !qstr2[j] && indented){
+ 		fli++;
+ 		if (indent_match(default_qstr(glo_quote_str, 1), lforw(curwp->w_dotp),
+ 					ind_str, NLINE, 0)){
+ 		    if (n){ /* look for another paragraph ? */
+ 		      curwp->w_dotp = lforw(curwp->w_dotp);
+ 		      continue;
+ 		    }
+ 		}
+ 		else{
+ 		  if (!lisblank(lforw(curwp->w_dotp)))
+ 		     curwp->w_dotp = lforw(curwp->w_dotp);
+ 		}
+ 	   }
+ 	}
+ 
  	/* scan line by line until we come to a line ending with
  	 * a <NL><NL> or <NL><TAB> or <NL><SPACE>
  	 *
  	 * PLUS: if there's a quote string, a quoted-to-non-quoted
  	 *	 line transition.
  	 */
! 	/* if the first line is indented (fli == 1), then the test below
! 	   is on the second line, and in that case we will need the raw
! 	   string, not the processed string
! 	 */
! 	quoted = quote_match(default_qstr(glo_quote_str, 1), curwp->w_dotp, qstr, NLINE, fli);
! 	qlen   = quoted ? strlen(qstr) : 0;
  	
  	while(curwp->w_dotp != curbp->b_linep
  	      && llength(lforw(curwp->w_dotp)) > qlen
! 	      && (quoted == quote_match(default_qstr(glo_quote_str, 1),
! 				lforw(curwp->w_dotp), qstr2, NLINE, fli))
! 	      && !strcmp(qstr, qstr2)
! 	      && (quoted == quote_match(default_qstr(glo_quote_str, 1),
! 				lforw(curwp->w_dotp), qstr2, NLINE, 1))
! 	      && !strcmp(qstr, qstr2)
! 	      && !indent_match(default_qstr(glo_quote_str, 1),
! 				lforw(curwp->w_dotp), ind_str, NLINE, 0)
! 	      && !ISspace(lgetc(lforw(curwp->w_dotp), qlen).c))
  	  curwp->w_dotp = lforw(curwp->w_dotp);
  
  	curwp->w_doto = llength(curwp->w_dotp);
***************
*** 684,690 ****
--- 958,1014 ----
      return (scrollforw (1, FALSE));
  }
  
+ /* deltext deletes from the specified position until the end of the file
+  * or until the signature (when called from Pine), whichever comes first.
+  */
  
+ int
+ deltext (f,n)
+ int f,n;
+ {               
+   LINE *currline = curwp->w_dotp;
+   static int firsttime = 0;
+ 
+   if ((lastflag&CFKILL) == 0)
+      kdelete();
+   
+   curwp->w_markp = curwp->w_dotp;
+   curwp->w_marko = curwp->w_doto;
+   
+   while (curwp->w_dotp != curbp->b_linep){
+      if ((Pmaster) 
+     	&& (llength(curwp->w_dotp) == 3) 
+ 	&& (lgetc(curwp->w_dotp, 0).c == '-') 
+ 	&& (lgetc(curwp->w_dotp, 1).c == '-') 
+ 	&& (lgetc(curwp->w_dotp, 2).c == ' ')){
+ 	  if (curwp->w_dotp == currline){
+ 	     if (curwp->w_doto)
+ 		curwp->w_dotp = lforw(curwp->w_dotp);
+ 	     else
+ 	   	break;
+      	  }
+      	  else{
+ 	     curwp->w_dotp = lback(curwp->w_dotp);
+ 	     curwp->w_doto = llength(curwp->w_dotp);
+ 	     break;
+           }
+      }
+      else{
+ 	if(lforw(curwp->w_dotp) != curbp->b_linep)
+ 	 curwp->w_dotp = lforw(curwp->w_dotp);
+ 	else{
+ 	 curwp->w_doto = llength(curwp->w_dotp);
+ 	 break;
+ 	}
+      }
+   }         
+   killregion(FALSE,1);
+   lastflag |= CFKILL;
+   if(firsttime == 0)
+      emlwrite("Deleted text can be recovered with the ^U command", NULL);
+   firsttime = 1;
+   return TRUE;
+ }
  
  /*
   * Scroll to a position.
diff -rc alpine-2.11/pico/blddate.c alpine-2.11.I.USE/pico/blddate.c
*** alpine-2.11/pico/blddate.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/blddate.c	2013-12-01 16:41:02.000000000 -0700
***************
*** 19,25 ****
      char **argv;
  {
      struct tm *t;
!     FILE      *outfile=stdout;
      time_t     ltime;
  
      if(argc > 1 && (outfile = fopen(argv[1], "w")) == NULL){
--- 19,25 ----
      char **argv;
  {
      struct tm *t;
!     FILE      *outfile=stdout, *infile;
      time_t     ltime;
  
      if(argc > 1 && (outfile = fopen(argv[1], "w")) == NULL){
***************
*** 46,51 ****
--- 46,57 ----
  	    1900 + t->tm_year);
  
      fprintf(outfile, "char hoststamp[]=\"random-pc\";\n");
+     if((infile = fopen("../patchlevel", "r")) != NULL){
+ 	int c;
+ 	while ((c = getc(infile)) != EOF) putc(c, outfile);
+ 	fclose(infile);
+     }
+     else fprintf(outfile, "char plevstamp[]=\"No information available\";\n");
  
      fclose(outfile);
  
diff -rc alpine-2.11/pico/composer.c alpine-2.11.I.USE/pico/composer.c
*** alpine-2.11/pico/composer.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/composer.c	2013-12-01 16:36:49.000000000 -0700
***************
*** 1872,1877 ****
--- 1872,1879 ----
      }
  
      UpdateHeader(0);
+     if(sendnow)
+ 	return(status !=0);
      PaintHeader(COMPOSER_TOP_LINE, status != 0);
      PaintBody(1);
      return(status != 0);
***************
*** 2015,2021 ****
  	tbufp = &strng[ods.p_len];
  
  	if(VALID_KEY(ch)){			/* char input */
!             /*
               * if we are allowing editing, insert the new char
               * end up leaving tbufp pointing to newly
               * inserted character in string, and offset to the
--- 2017,2023 ----
  	tbufp = &strng[ods.p_len];
  
  	if(VALID_KEY(ch)){			/* char input */
! insert_char:/*
               * if we are allowing editing, insert the new char
               * end up leaving tbufp pointing to newly
               * inserted character in string, and offset to the
***************
*** 2095,2100 ****
--- 2097,2109 ----
          }
          else {					/* interpret ch as a command */
              switch (ch = normalize_cmd(ch, ckm, 2)) {
+ 	      case (CTRL|'\\') :
+ 		if (ch = GetAccent())
+ 		  goto insert_char;
+ 		else
+ 		  clearcursor();
+ 	      break;
+ 
                case (CTRL|KEY_LEFT):     /* word skip left */
                  if(ods.p_ind > 0)       /* Scoot one char left if possible */
                    ods.p_ind--;
***************
*** 3362,3367 ****
--- 3371,3379 ----
  {
      UCS    *bufp, *buf;
  
+     if (sendnow)
+ 	return;
+ 
      if(ComposerTopLine - 1 >= BOTTOM())		/* silently forget it */
        return;
  
***************
*** 3418,3423 ****
--- 3430,3438 ----
      UCS *end;
      int  i;
  
+     if (sendnow)
+       return(TRUE);
+ 
      buf = utf8_to_ucs4_cpystr(headents[entry].prompt);	/* fresh prompt paint */
      if(!buf)
        return(-1);
***************
*** 4373,4378 ****
--- 4388,4396 ----
  void
  ShowPrompt(void)
  {
+     if (sendnow)
+ 	return;
+ 
      if(headents[ods.cur_e].key_label){
  	menu_header[TO_KEY].name  = "^T";
  	menu_header[TO_KEY].label = headents[ods.cur_e].key_label;
diff -rc alpine-2.11/pico/display.c alpine-2.11.I.USE/pico/display.c
*** alpine-2.11/pico/display.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/display.c	2013-12-01 16:38:56.000000000 -0700
***************
*** 387,392 ****
--- 387,395 ----
      int     scroll = 0;
      CELL	     c;
  
+     if (sendnow)
+ 	return;
+ 
  #if	TYPEAH
      if (typahead())
  	return;
***************
*** 916,922 ****
      int   nbflag;		/* non-blanks to the right flag? */
      int   cleartoeol = 0;
  
!     if(row < 0 || row > term.t_nrow)
        return;
  
      /* set up pointers to virtual and physical lines */
--- 919,925 ----
      int   nbflag;		/* non-blanks to the right flag? */
      int   cleartoeol = 0;
  
!     if(row < 0 || row > term.t_nrow || sendnow)
        return;
  
      /* set up pointers to virtual and physical lines */
***************
*** 1285,1291 ****
  void
  mlerase(void)
  {
!     if (term.t_nrow < term.t_mrow)
        return;
  
      movecursor(term.t_nrow - term.t_mrow, 0);
--- 1288,1294 ----
  void
  mlerase(void)
  {
!     if (term.t_nrow < term.t_mrow || sendnow)
        return;
  
      movecursor(term.t_nrow - term.t_mrow, 0);
***************
*** 1360,1365 ****
--- 1363,1372 ----
      menu_yesno[6].label = N_("Cancel");
      menu_yesno[7].name  = "N";
      menu_yesno[7].label = (dflt == FALSE) ? "[" N_("No") "]" : N_("No");
+     if(Pmaster && Pmaster->onctrlc){
+       menu_yesno[8].name  = "T";
+       menu_yesno[8].label = N_("counT");
+     }
      wkeyhelp(menu_yesno);		/* paint generic menu */
      sgarbk = TRUE;			/* mark menu dirty */
      if(Pmaster && curwp)
***************
*** 1438,1443 ****
--- 1445,1458 ----
  		km_popped++;
  		break;
  	    }
+ 
+ 	  case 'T':
+ 	  case 't':
+ 	    if(Pmaster && Pmaster->onctrlc){
+ 	      pputs_utf8(_("counT"), 1);
+ 	      rv = COUNT;
+ 	      break;
+ 	    }
  	    /* else fall through */
  
  	  default:
***************
*** 1751,1756 ****
--- 1766,1776 ----
  	    b = &buf[ucs4_strlen(buf)];
  	    continue;
  
+           case (CTRL|'\\'):
+            if (c = GetAccent())
+              goto text;
+           continue;
+ 
  	  case (CTRL|'F') :			/* CTRL-F forward a char*/
  	  case KEY_RIGHT :
  	    if(*b == '\0')
***************
*** 1760,1765 ****
--- 1780,1797 ----
  
  	    continue;
  
+ 	  case (CTRL|'N'):			/* Insert pattern */
+ 	   if (pat[0] != '\0'){
+ 		ucs4_strncpy(buf+ucs4_strlen(buf), pat, NPAT);
+ 		pputs(pat,1);
+ 		b = &buf[ucs4_strlen(buf)];
+ 		dline.vused += ucs4_strlen(pat);
+ 		changed = TRUE;
+ 		}
+ 	   else
+ 		(*term.t_beep)();
+ 	  continue;
+ 
  	  case (CTRL|'G') :			/* CTRL-G help		*/
  	    if(term.t_mrow == 0 && km_popped == 0){
  		movecursor(term.t_nrow-2, 0);
***************
*** 1869,1875 ****
  #endif
  
  	  default : 
! 
  	    /* look for match in extra_v */
  	    for(i = 0; i < 12; i++)
  	      if(c && c == extra_v[i]){
--- 1901,1907 ----
  #endif
  
  	  default : 
! text:
  	    /* look for match in extra_v */
  	    for(i = 0; i < 12; i++)
  	      if(c && c == extra_v[i]){
***************
*** 1963,1969 ****
  
      mlerase();
  
!     if(!(message && *message) || term.t_nrow < 2)	
        return;    /* nothing to write or no space to write, bag it */
  
      bufp = message;
--- 1995,2001 ----
  
      mlerase();
  
!     if(!(message && *message) || term.t_nrow < 2 || sendnow)	
        return;    /* nothing to write or no space to write, bag it */
  
      bufp = message;
***************
*** 2152,2159 ****
      }
  
      ret = ttcol;
!     while(ttcol < term.t_ncol)
!       pputc(' ', 0);
  
      movecursor(term.t_nrow - term.t_mrow, ret);
  
--- 2184,2192 ----
      }
  
      ret = ttcol;
!     if(sendnow == 0)
!       while(ttcol < term.t_ncol)
!         pputc(' ', 0);
  
      movecursor(term.t_nrow - term.t_mrow, ret);
  
***************
*** 2632,2637 ****
--- 2665,2672 ----
  {
      int ind, width, printable_ascii = 0;
  
+     if(sendnow)
+ 	return;
      /*
       * This is necessary but not sufficient to allow us to draw. Note that
       * ttrow runs from 0 to t_nrow (so total number of rows is t_nrow+1)
***************
*** 2686,2691 ****
--- 2721,2728 ----
  pputs(UCS *s,				/* string to write */
        int a)				/* and its attribute */
  {
+     if(sendnow)
+ 	return;
      while (*s != '\0')
        pputc(*s++, a);
  }
***************
*** 2696,2701 ****
--- 2733,2740 ----
  {
      UCS *ucsstr = NULL;
  
+     if(sendnow)
+ 	return;
      if(s && *s){
  	ucsstr = utf8_to_ucs4_cpystr(s);
  	if(ucsstr){
***************
*** 2996,3001 ****
--- 3035,3043 ----
      char  nbuf[NLINE];
  #endif
  
+     if(sendnow)
+ 	return;
+ 
  #ifdef _WINDOWS
      pico_config_menu_items (keymenu);
  #endif
diff -rc alpine-2.11/pico/ebind.h alpine-2.11.I.USE/pico/ebind.h
*** alpine-2.11/pico/ebind.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/ebind.h	2013-12-01 16:36:49.000000000 -0700
***************
*** 61,67 ****
  #ifdef	MOUSE
  	{KEY_MOUSE,		mousepress},
  #ifndef _WINDOWS
! 	{CTRL|'\\',		toggle_xterm_mouse},
  #endif
  #endif
  	{CTRL|'A',		gotobol},
--- 61,67 ----
  #ifdef	MOUSE
  	{KEY_MOUSE,		mousepress},
  #ifndef _WINDOWS
! 	{CTRL|'|',		toggle_xterm_mouse},
  #endif
  #endif
  	{CTRL|'A',		gotobol},
***************
*** 100,106 ****
  	{CTRL|KEY_HOME,	gotobob},
  	{CTRL|KEY_END,	gotoeob},
  	{0x7F,			backdel},
! 	{0,			NULL}
  };
  
  
--- 100,108 ----
  	{CTRL|KEY_HOME,	gotobob},
  	{CTRL|KEY_END,	gotoeob},
  	{0x7F,			backdel},
!         {CTRL|'\\',             pineaccent},
! 	{0,
! NULL}
  };
  
  
***************
*** 123,129 ****
  #ifdef	MOUSE
  	{KEY_MOUSE,		mousepress},
  #ifndef _WINDOWS
! 	{CTRL|'\\',		toggle_xterm_mouse},
  #endif
  #endif
  	{CTRL|'A',		gotobol},
--- 125,131 ----
  #ifdef	MOUSE
  	{KEY_MOUSE,		mousepress},
  #ifndef _WINDOWS
! 	{CTRL|'|',		toggle_xterm_mouse},
  #endif
  #endif
  	{CTRL|'A',		gotobol},
diff -rc alpine-2.11/pico/edef.h alpine-2.11.I.USE/pico/edef.h
*** alpine-2.11/pico/edef.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/edef.h	2013-12-01 16:35:25.000000000 -0700
***************
*** 32,37 ****
--- 32,38 ----
  
  /* initialized global definitions */
  
+ int	sendnow = 0;			/* should we send now		*/
  int     fillcol = 72;                   /* Current fill column          */
  int     userfillcol = -1;               /* Fillcol set from cmd line    */
  UCS     pat[NPAT];                      /* Search pattern		*/
***************
*** 84,89 ****
--- 85,91 ----
  
  /* initialized global external declarations */
  
+ extern	int	sendnow;		/* should we send now		*/
  extern  int     fillcol;                /* Fill column                  */
  extern  int     userfillcol;            /* Fillcol set from cmd line    */
  extern  UCS     pat[];                  /* Search pattern               */
diff -rc alpine-2.11/pico/efunc.h alpine-2.11.I.USE/pico/efunc.h
*** alpine-2.11/pico/efunc.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/efunc.h	2013-12-01 16:38:46.000000000 -0700
***************
*** 54,61 ****
--- 54,65 ----
  extern	int backline(int, int);
  extern	int gotobop(int, int);
  extern	int gotoeop(int, int);
+ extern  int pineaccent(int, int);
+ extern  unsigned char accent(UCS, UCS);
+ extern  unsigned char GetAccent(void);
  extern	int forwpage(int, int);
  extern	int backpage(int, int);
+ extern  int deltext (int, int);
  extern  int scrollupline(int, int);
  extern  int scrolldownline(int, int);
  extern  int scrollto(int, int);
***************
*** 249,258 ****
  extern	int fillpara(int, int);
  extern	int fillbuf(int, int);
  extern	int inword(void);
! extern	int quote_match(UCS *, LINE *, UCS *, size_t);
  extern	int ucs4_isalnum(UCS);
  extern	int ucs4_isalpha(UCS);
  extern	int ucs4_isspace(UCS);
  extern	int ucs4_ispunct(UCS);
  
  #endif	/* EFUNC_H */
--- 253,268 ----
  extern	int fillpara(int, int);
  extern	int fillbuf(int, int);
  extern	int inword(void);
! extern	int quote_match(char **, LINE *, char *, size_t, int);
! extern	void flatten_qstring(QSTRING_S *, char *, int);
! extern	void free_qs(QSTRING_S **);
! extern	QSTRING_S *do_quote_match (char **, char *, char *, char *, char *, int, int);
! extern	QSTRING_S *do_raw_quote_match(char **, char *, char *, char *, QSTRING_S **, QSTRING_S **);
! extern  int indent_match(char **, LINE *, char *, int, int);
  extern	int ucs4_isalnum(UCS);
  extern	int ucs4_isalpha(UCS);
  extern	int ucs4_isspace(UCS);
  extern	int ucs4_ispunct(UCS);
  
  #endif	/* EFUNC_H */
+ 
diff -rc alpine-2.11/pico/fileio.c alpine-2.11.I.USE/pico/fileio.c
*** alpine-2.11/pico/fileio.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/fileio.c	2013-12-01 16:40:37.000000000 -0700
***************
*** 95,100 ****
--- 95,101 ----
  {
      size_t i;
      UCS    ucs;
+     static int shown = 0;
  
      if(charsreturned)
        *charsreturned = 0;
***************
*** 121,128 ****
  	    if(charsreturned)
  	      *charsreturned = nbuf - 1;
  
! 	    if(msg)
  	      emlwrite("File has long line", NULL);
  
  	    return FIOLNG;
          }
--- 122,131 ----
  	    if(charsreturned)
  	      *charsreturned = nbuf - 1;
  
! 	    if(msg && !shown){
! 	      shown = 1;
  	      emlwrite("File has long line", NULL);
+ 	    }
  
  	    return FIOLNG;
          }
***************
*** 131,136 ****
--- 134,140 ----
      }
  
      if(ucs == CCONV_EOF){
+ 	shown = 0;	/* warn the next time, again, only once */
          if(ferror(g_pico_fio.fp)){
              emlwrite("File read error", NULL);
  	    if(charsreturned)
diff -rc alpine-2.11/pico/line.c alpine-2.11.I.USE/pico/line.c
*** alpine-2.11/pico/line.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/line.c	2013-12-01 16:36:01.000000000 -0700
***************
*** 608,621 ****
  lisblank(LINE *line)
  {
      int n = 0;
!     UCS qstr[NLINE];
  
!     n = (glo_quote_str
! 	 && quote_match(glo_quote_str, line, qstr, NLINE))
! 	  ? ucs4_strlen(qstr) : 0;
  
      for(; n < llength(line); n++)
!       if(!ucs4_isspace(lgetc(line, n).c))
  	return(FALSE);
  
      return(TRUE);
--- 608,619 ----
  lisblank(LINE *line)
  {
      int n = 0;
!     char qstr[NLINE];
  
!     n = quote_match(default_qstr(glo_quote_str, 1), line, qstr, NLINE, 1);
  
      for(; n < llength(line); n++)
!       if(!ISspace(lgetc(line, n).c))
  	return(FALSE);
  
      return(TRUE);
diff -rc alpine-2.11/pico/main.c alpine-2.11.I.USE/pico/main.c
*** alpine-2.11/pico/main.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/main.c	2013-12-01 16:38:06.000000000 -0700
***************
*** 163,168 ****
--- 163,169 ----
      char    *file_to_edit = NULL;
      char    *display_charmap = NULL, *dc;
      char    *keyboard_charmap = NULL;
+     int	     line_information_on = FALSE;
      int      use_system = 0;
      char    *err = NULL;
  
***************
*** 416,421 ****
--- 417,428 ----
  	      emlwrite(_("You may possibly have new mail."), NULL);
  	}
  
+          if (c == (CTRL|'\\')){
+            c = GetAccent();
+ 	   if (!c)
+ 	     c = NODATA;
+ 	 }
+ 
  	if(km_popped)
  	  switch(c){
  	    case NODATA:
***************
*** 437,450 ****
  	      mlerase();
  	}
  
! 	f = FALSE;
  	n = 1;
  
  #ifdef	MOUSE
  	clear_mfunc(mouse_in_content);
  #endif
  					/* Do it.               */
  	execute(normalize_cmd(c, fkm, 1), f, n);
      }
  }
  
--- 444,472 ----
  	      mlerase();
  	}
  
! 	f = (c == (CTRL|'J'));
  	n = 1;
+ 	if (!line_information_on)
+ 	   line_information_on = (c == (CTRL|'C'));
+ 	else
+ 	   line_information_on = ((c == KEY_DOWN) || (c == KEY_UP) ||
+ 				  (c == KEY_RIGHT) || (c == KEY_LEFT) ||
+ 			          (c == (CTRL|'V')) || (c == (CTRL|'Y')) ||
+ 			          (c == (CTRL|'D')) || (c == (CTRL|'F')) ||
+ 				  (c == (CTRL|'B')) || (c == (CTRL|'N')) ||
+ 				  (c == (CTRL|'P')) || (c == (CTRL|'A')) || 
+ 				  (c == (CTRL|'E')) || (c == (CTRL|'U'))) 
+ 				&& (c != (CTRL|'C'));
  
  #ifdef	MOUSE
  	clear_mfunc(mouse_in_content);
  #endif
  					/* Do it.               */
  	execute(normalize_cmd(c, fkm, 1), f, n);
+ 	if (line_information_on){
+ 	   c = (CTRL|'C');
+ 	   execute(normalize_cmd(c, fkm, 1), f, n);
+ 	}
      }
  }
  
diff -rc alpine-2.11/pico/osdep/color.h alpine-2.11.I.USE/pico/osdep/color.h
*** alpine-2.11/pico/osdep/color.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/osdep/color.h	2013-12-01 16:36:01.000000000 -0700
***************
*** 33,38 ****
--- 33,39 ----
  void	 pico_toggle_color(int);
  void	 pico_set_nfg_color(void);
  void	 pico_set_nbg_color(void);
+ char	 **default_qstr(void *, int);
  
  
  #endif /* PICO_OSDEP_COLOR_INCLUDED */
diff -rc alpine-2.11/pico/osdep/getkey.c alpine-2.11.I.USE/pico/osdep/getkey.c
*** alpine-2.11/pico/osdep/getkey.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/osdep/getkey.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 131,136 ****
--- 131,146 ----
  {
      UCS ch, status, cc;
  
+     if(sendnow){
+ 	ch = Pmaster && Pmaster->auto_cmds && *Pmaster->auto_cmds 
+ 		? *Pmaster->auto_cmds++ : NODATA;
+ 
+ 	if (ch >= 0x00 && ch <= 0x1F)
+ 	      ch = CTRL | (ch+'@');
+ 
+         return(ch);
+     }
+ 
      if(!ReadyForKey(FUDGE-5))
        return(NODATA);
  
diff -rc alpine-2.11/pico/osdep/terminal.c alpine-2.11.I.USE/pico/osdep/terminal.c
*** alpine-2.11/pico/osdep/terminal.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/osdep/terminal.c	2013-12-01 16:35:25.000000000 -0700
***************
*** 26,31 ****
--- 26,32 ----
  #include "../keydefs.h"
  #include "../pico.h"
  #include "../mode.h"
+ #include "../edef.h"
  
  #include "raw.h"
  #include "color.h"
***************
*** 478,483 ****
--- 479,490 ----
  {
      int     row, col;
  
+     if (sendnow){
+       term.t_nrow = 23;
+       term.t_ncol = 80;
+       return 0;
+     }
+ 
      /*
       * determine the terminal's communication speed and decide
       * if we need to do optimization ...
***************
*** 1253,1258 ****
--- 1260,1271 ----
  {
      int     row, col;
  
+     if (sendnow){
+       term.t_nrow = 23;
+       term.t_ncol = 80;
+       return 0;
+     }
+ 
      /*
       * determine the terminal's communication speed and decide
       * if we need to do optimization ...
diff -rc alpine-2.11/pico/pico.c alpine-2.11.I.USE/pico/pico.c
*** alpine-2.11/pico/pico.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/pico.c	2013-12-01 16:38:56.000000000 -0700
***************
*** 138,143 ****
--- 138,152 ----
      pico_all_done = 0;
      km_popped     = 0;
  
+     if (pm->auto_cmds){
+        int i;
+ #define CTRL_X 24
+       for (i = 0;  pm->auto_cmds[i]; i++);
+       if ((i > 1) && (pm->auto_cmds[i - 2] == CTRL_X) && 
+ 		((pm->auto_cmds[i - 1] == 'y') || (pm->auto_cmds[i-1] == 'Y')))
+       sendnow++;
+     }
+ 
      if(!vtinit())			/* Init Displays.      */
        return(COMP_CANCEL);
  
***************
*** 638,649 ****
      result = "";
  
      Pmaster->arm_winch_cleanup++;
      if(Pmaster->canceltest){
          if(((Pmaster->pine_flags & MDHDRONLY) && !any_header_changes())
  	  || (result = (*Pmaster->canceltest)(redraw_pico_for_callback))){
- 	    pico_all_done = COMP_CANCEL;
  	    emlwrite(result, NULL);
  	    Pmaster->arm_winch_cleanup--;
  	    return(TRUE);
  	}
  	else{
--- 647,665 ----
      result = "";
  
      Pmaster->arm_winch_cleanup++;
+     Pmaster->onctrlc++;
      if(Pmaster->canceltest){
          if(((Pmaster->pine_flags & MDHDRONLY) && !any_header_changes())
  	  || (result = (*Pmaster->canceltest)(redraw_pico_for_callback))){
  	    emlwrite(result, NULL);
  	    Pmaster->arm_winch_cleanup--;
+ 	    if(Pmaster->curpos[0]){
+ 	       curwp->w_flag |= WFMODE;		/* and modeline so we  */
+ 	       sgarbk = TRUE;			/* redraw the keymenu  */
+ 	       pclear(term.t_nrow - 1, term.t_nrow + 1);
+ 	       return(FALSE);
+ 	    }
+ 	    pico_all_done = COMP_CANCEL;
  	    return(TRUE);
  	}
  	else{
***************
*** 672,677 ****
--- 688,699 ----
  	emlwrite(_("\007Cancel Cancelled"), NULL);
  	break;
  
+       case COUNT:
+ 	showcpos(1,0);
+ 	emlwrite(Pmaster->curpos, NULL);
+ 	Pmaster->onctrlc--;
+ 	break;
+ 
        default:
  	mlerase();
      }
***************
*** 714,719 ****
--- 736,754 ----
  	    return(FALSE);
  	}
  
+  	/* When we send a message using the command line we are going to
+  	   ignore if the user wants to spell check, we assume he already
+  	   did */
+  	if (sendnow){
+  	    ret = (*Pmaster->exittest)(Pmaster->headents,
+ 					redraw_pico_for_callback, 
+ 					Pmaster->allow_flowed_text,
+ 					&result);
+  	    if (!ret)
+  		pico_all_done = COMP_EXIT;
+  	    return(result ? FALSE : TRUE);
+  	}
+ 
  #ifdef	SPELLER
  	if(Pmaster->always_spell_check)
  	  if(spell(0, 0) == -1)
diff -rc alpine-2.11/pico/pico.h alpine-2.11.I.USE/pico/pico.h
*** alpine-2.11/pico/pico.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/pico.h	2013-12-01 16:38:56.000000000 -0700
***************
*** 199,209 ****
--- 199,211 ----
      PCOLORS *colors;                    /* colors for titlebar and keymenu */
      void  *input_cs;			/* passed to mbtow() via kbseq() */
      long   pine_flags;			/* entry mode flags */
+     char  curpos[80];			/* where are we now? */
      /* The next few bits are features that don't fit in pine_flags      */
      /* If we had this to do over, it would probably be one giant bitmap */
      unsigned always_spell_check:1;      /* always spell-checking upon quit */
      unsigned strip_ws_before_send:1;    /* don't default strip bc of flowed */
      unsigned allow_flowed_text:1;    /* clean text when done to keep flowed */
+     unsigned onctrlc;			/* are we on ctrl-c command? */
      int   (*helper)();			/* Pine's help function  */
      int   (*showmsg)();			/* Pine's display_message */
      UCS   (*suspend)();			/* Pine's suspend */
***************
*** 222,227 ****
--- 224,230 ----
      void  (*winch_cleanup)();		/* callback handling screen resize */
      void  (*newthread)();		/* callback to create new thread   */
      int    arm_winch_cleanup;		/* do the winch_cleanup if resized */
+     int   *auto_cmds;			/* Initial keystroke commands */
      HELP_T search_help;
      HELP_T ins_help;
      HELP_T ins_m_help;
diff -rc alpine-2.11/pico/random.c alpine-2.11.I.USE/pico/random.c
*** alpine-2.11/pico/random.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/random.c	2013-12-01 16:38:56.000000000 -0700
***************
*** 74,80 ****
  	    thisline+1, lines+1, (int)((100L*(thisline+1))/(lines+1)),
  	    nbc, nch, (nch) ? (int)((100L*nbc)/nch) : 0);
  
!     emlwrite(buffer, NULL);
      return (TRUE);
  }
  
--- 74,83 ----
  	    thisline+1, lines+1, (int)((100L*(thisline+1))/(lines+1)),
  	    nbc, nch, (nch) ? (int)((100L*nbc)/nch) : 0);
  
!     if(Pmaster)
!       strcpy(Pmaster->curpos, buffer);
!     else
!       emlwrite(buffer, NULL);
      return (TRUE);
  }
  
diff -rc alpine-2.11/pico/search.c alpine-2.11.I.USE/pico/search.c
*** alpine-2.11/pico/search.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/search.c	2013-12-01 16:41:34.000000000 -0700
***************
*** 36,42 ****
  int     readpattern(char *, int);
  int     replace_pat(UCS *, int *);
  int     replace_all(UCS *, UCS *);
! 
  
  #define	FWS_RETURN(RV)	{				\
  			    thisflag |= CFSRCH;		\
--- 36,42 ----
  int     readpattern(char *, int);
  int     replace_pat(UCS *, int *);
  int     replace_all(UCS *, UCS *);
! int	deletepara(int, int);
  
  #define	FWS_RETURN(RV)	{				\
  			    thisflag |= CFSRCH;		\
***************
*** 76,81 ****
--- 76,85 ----
  N_("~        Hitting only ~R~e~t~u~r~n or at the prompt will cause the"),
  N_("        search to be made with the default value."),
  "  ",
+ N_("~        Hitting ~^~N will reinsert the last string you searched for"),
+ N_("        so that you can edit it (in case you made a mistake entering the"),
+ N_("        search pattern the first time)."),
+ "  ",
  N_("        The text search is not case sensitive, and will examine the"),
  N_("        entire message."),
  "  ",
***************
*** 232,241 ****
--- 236,254 ----
  	    mlerase();
  	    FWS_RETURN(TRUE);
  
+ 	  case (CTRL|'P'):
+ 	    deletepara(0, 1);
+ 	    mlerase();
+ 	    FWS_RETURN(TRUE);
+ 
  	  case  (CTRL|'R'):        /* toggle replacement option */
  	    repl_mode = !repl_mode;
  	    break;
  
+ 	  case (CTRL|'X'):
+ 	    deltext(f,n);
+ 	    FWS_RETURN(TRUE);
+ 
  	  default:
  	    if(status == ABORT)
  	      emlwrite(_("Search Cancelled"), NULL);
***************
*** 274,280 ****
  	}
  
  	if(status + curwp->w_doto >= llength(curwp->w_dotp) ||
! 	   !eq(defpat[status],lgetc(curwp->w_dotp, curwp->w_doto + status).c))
  	  break;		/* do nothing! */
  	status++;
      }
--- 287,293 ----
  	}
  
  	if(status + curwp->w_doto >= llength(curwp->w_dotp) ||
! 	   !eq((unsigned char)defpat[status],lgetc(curwp->w_dotp, curwp->w_doto + status).c))
  	  break;		/* do nothing! */
  	status++;
      }
***************
*** 600,606 ****
  	UCS         *b;
  	UCS	     prompt[NPMT];
  	UCS         *promptp;
! 	EXTRAKEYS    menu_pat[8];
  
  	menu_pat[i = 0].name = "^Y";
  	menu_pat[i].label    = N_("FirstLine");
--- 613,619 ----
  	UCS         *b;
  	UCS	     prompt[NPMT];
  	UCS         *promptp;
! 	EXTRAKEYS    menu_pat[10];
  
  	menu_pat[i = 0].name = "^Y";
  	menu_pat[i].label    = N_("FirstLine");
***************
*** 618,623 ****
--- 631,641 ----
  	KS_OSDATASET(&menu_pat[i], KS_NONE);
  
  	if(!repl_mode){
+ 	    menu_pat[++i].name = "^X";     
+ 	    menu_pat[i].label  = N_("DelEnd");
+ 	    menu_pat[i].key    = (CTRL|'X');    
+ 	    KS_OSDATASET(&menu_pat[i], KS_NONE);
+ 
  	    menu_pat[++i].name = "^T";
  	    menu_pat[i].label  = N_("LineNumber");
  	    menu_pat[i].key    = (CTRL|'T');
***************
*** 634,639 ****
--- 652,662 ----
  	    menu_pat[i].key    = (CTRL|'O');
  	    KS_OSDATASET(&menu_pat[i], KS_NONE);
  
+ 	    menu_pat[++i].name = "^P";
+ 	    menu_pat[i].label  = N_("Delete Para");
+ 	    menu_pat[i].key    = (CTRL|'P');
+ 	    KS_OSDATASET(&menu_pat[i], KS_NONE);
+ 
  	    menu_pat[++i].name = "^U";
  	    /* TRANSLATORS: Instead of justifying (formatting) just a
  	       single paragraph, Full Justify justifies the entire
***************
*** 769,775 ****
  	UCS         *b;
  	UCS	     tpat[NPAT+20];
  	UCS         *tpatp;
! 	EXTRAKEYS    menu_pat[7];
  
  	menu_pat[i = 0].name = "^Y";
  	menu_pat[i].label    = N_("FirstLine");
--- 792,798 ----
  	UCS         *b;
  	UCS	     tpat[NPAT+20];
  	UCS         *tpatp;
! 	EXTRAKEYS    menu_pat[9];
  
  	menu_pat[i = 0].name = "^Y";
  	menu_pat[i].label    = N_("FirstLine");
***************
*** 782,787 ****
--- 805,815 ----
  	KS_OSDATASET(&menu_pat[i], KS_NONE);
  
  	if(text_mode){
+ 	    menu_pat[++i].name = "^X";     
+ 	    menu_pat[i].label  = N_("DelEnd");
+ 	    menu_pat[i].key    = (CTRL|'X');    
+ 	    KS_OSDATASET(&menu_pat[i], KS_NONE);
+ 
  	    menu_pat[++i].name = "^T";
  	    menu_pat[i].label  = N_("LineNumber");
  	    menu_pat[i].key    = (CTRL|'T');
***************
*** 797,802 ****
--- 825,835 ----
  	    menu_pat[i].key    = (CTRL|'O');
  	    KS_OSDATASET(&menu_pat[i], KS_NONE);
  
+ 	    menu_pat[++i].name = "^P";
+ 	    menu_pat[i].label  = N_("Delete Para");
+ 	    menu_pat[i].key    = (CTRL|'P');
+ 	    KS_OSDATASET(&menu_pat[i], KS_NONE);
+ 
  	    menu_pat[++i].name = "^U";
  	    menu_pat[i].label  = N_("FullJustify");
  	    menu_pat[i].key    = (CTRL|'U');
***************
*** 927,933 ****
  	  c = lgetc(curline, curoff++).c;	/* get the char */
  
  	/* test it against first char in pattern */
! 	if (eq(c, patrn[0]) != FALSE) {	/* if we find it..*/
  	    /* setup match pointers */
  	    matchline = curline;
  	    matchoff = curoff;
--- 960,966 ----
  	  c = lgetc(curline, curoff++).c;	/* get the char */
  
  	/* test it against first char in pattern */
! 	if (eq(c, (unsigned char)patrn[0]) != FALSE) {	/* if we find it..*/
  	    /* setup match pointers */
  	    matchline = curline;
  	    matchoff = curoff;
***************
*** 948,954 ****
  		  return(FALSE);
  
  		/* and test it against the pattern */
! 		if (eq(*patptr, c) == FALSE)
  		  goto fail;
  	    }
  
--- 981,987 ----
  		  return(FALSE);
  
  		/* and test it against the pattern */
! 		if (eq((unsigned char) *patptr, c) == FALSE)
  		  goto fail;
  	    }
  
***************
*** 1035,1037 ****
--- 1068,1092 ----
  
      curwp->w_flag |= WFEDIT;
  }
+ 
+ int
+ deletepara(int f, int n) /* Delete the current paragraph */
+ {
+    if(curbp->b_mode&MDVIEW)           /* don't allow this command if  */ 
+      return(rdonly());               /* we are in read only mode     */
+    
+    if(!lisblank(curwp->w_dotp))
+      gotobop(FALSE, 1);
+ 
+    curwp->w_markp = curwp->w_dotp;
+    curwp->w_marko = 0;
+ 
+    gotoeop(FALSE, 1);
+    if (curwp->w_dotp != curbp->b_linep){ /* if we are not at the end of buffer */
+      curwp->w_dotp = lforw(curwp->w_dotp); /* get one more line */
+        curwp->w_doto = 0; /* but only the beginning */
+    }
+    killregion(f,n);
+    return(TRUE);
+ }
+ 
diff -rc alpine-2.11/pico/word.c alpine-2.11.I.USE/pico/word.c
*** alpine-2.11/pico/word.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pico/word.c	2013-12-01 16:36:01.000000000 -0700
***************
*** 25,34 ****
   */
  
  #include	"headers.h"
! 
  
  int fpnewline(UCS *quote);
! int fillregion(UCS *qstr, REGION *addedregion);
  int setquotelevelinregion(int quotelevel, REGION *addedregion);
  int is_user_separator(UCS c);
  
--- 25,34 ----
   */
  
  #include	"headers.h"
! #include	"../pith/osdep/color.h"
  
  int fpnewline(UCS *quote);
! int fillregion(UCS *qstr, UCS *istr, REGION *addedregion);
  int setquotelevelinregion(int quotelevel, REGION *addedregion);
  int is_user_separator(UCS c);
  
***************
*** 431,555 ****
      return 0;
  }
  
! void
! do_quote_match(UCS *q, LINE *l, UCS *buf, size_t buflen)
! {
!     register int i, j, qb;
!     int qstart, qend, k;
! 
!     /* 
!      * The method for determining the quote string is:
!      * 1) strip leading and trailing whitespace from q 
!      * 2) add all leading whitespace to buf
!      * 3) check for q
!      * 4) if q, append q to buf and any trailing whitespace
!      * 5) repeat steps 3 and 4 as necessary
!      *
!      * q in the future could be made to be an array of (UCS *)'s
!      *    (">" and whatever the user's quote_string is)
!      */
! 
!     *buf = '\0';
  
!     if(l == NULL)
!       return;
  
!     /* count leading whitespace as part of the quote */
!     for(j = 0; j <= llength(l) && lgetc(l, j).c == ' ' && j+1 < buflen; j++)
!         buf[j] = lgetc(l, j).c;
!     buf[j] = '\0';   
! 
!     if(q == NULL || *q == '\0')
!       return;
! 
!     /* pare down q so it contains no leading or trailing whitespace */
!     for(i = 0; q[i] == ' '; i++);
!     qstart = i;
!     for(i = ucs4_strlen(q); i > 0 && q[i-1] == ' '; i--);
!     qend = i;
! 
!     /* for quote strings that are blanks, chop buf to the length of q */
!     if(qend <= qstart){
!       if(ucs4_strlen(q) < buflen)
! 	buf[ucs4_strlen(q)] = '\0';
!       return;
!     }
!           
!     while(j <= llength(l)){
!         for(i = qstart; j <= llength(l) && i < qend; i++, j++)
!           if(q[i] != lgetc(l, j).c)
!             return;
!     
!         if(i >= qend){
!             if(ucs4_strlen(buf) + qend - qstart < (buflen - 1))
!               ucs4_strncat(buf, q + qstart, qend - qstart);
!         } 
!     
!         /*
!          * if we're this far along, we've matched a quote string,
!          * and should now add the following white space.
!          */
!         for(k = ucs4_strlen(buf);
! 		j <= llength(l) && lgetc(l,j).c == ' ' && (k + 1 < buflen);
!             j++, k++){
!             buf[k] = lgetc(l,j).c;
!         }
!         buf[k] = '\0';
!         
!         if(j > llength(l))
!           return;
!     }
  }
  
  /*
   * Return number of quotes if whatever starts the line matches the quote string
   */
  int
! quote_match(UCS *q, LINE *gl, UCS *bufl, size_t buflen)
  {
!     LINE *nl = gl != curbp->b_linep ? lforw(gl) : NULL;
!     LINE *pl = lback(gl) != curbp->b_linep ? lback(gl) : NULL;
!     UCS bufp[NSTRING], bufn[NSTRING];
!     int i, j, qstart, qend;
!     int quoted_line = 0;
! 
!     do_quote_match(q, pl, bufp, sizeof(bufp));	/* previous line */
!     do_quote_match(q, gl, bufl, buflen);	/* given line	 */
!     do_quote_match(q, nl, bufn, sizeof(bufn));	/* next line	 */
! 
!     if(!ucs4_strcmp(bufp, bufl) || !ucs4_strcmp(bufl, bufn))
!       return ucs4_strlen(bufl);
! 
!     /* is this line quoted? */
!     if(q && *q){
!       /* pare down q so it contains no leading or trailing whitespace */
!       for(i = 0; q[i] == ' '; i++);
!       qstart = i;
!       for(i = ucs4_strlen(q); i > 0 && q[i-1] == ' '; i--);
!       qend = i;
!       for(i = 0; i < llength(gl) 
! 		 && i + qstart < qend 
! 		 && lgetc(gl, i).c == q[i+qstart]; i++);
!       if(i + qstart == qend)
!          quoted_line = 1;
!     }
! 
!     /* compare bufl and bufn */
!     for(i = 0; bufl[i] && bufn[i] && bufl[i] == bufn[i]; i++);
! 
!     /* go back to last non-space character */
!     for(; i > 0 && bufl[i-1] == ' '; i--);
! 
!     /* do bufl and bufn differ only in spaces? */
!     for(j = i; bufl[j] && bufl[j] == ' '; j++);
! 
!     /* if they differ only on trailing spaces, chop bufl to agree with bufn */
!     if (!bufl[j] )
!        bufl[Pmaster && quoted_line ? (j > i ? i+1 : i) :  i] = '\0';
  
!     return ucs4_strlen(bufl);
  }
  
  
  /* Justify the entire buffer instead of just a paragraph */
  int
--- 431,586 ----
      return 0;
  }
  
! /* Support of indentation of paragraphs */
! #define is_indent_char(c)  (((c) == '.' || (c) == '}' || (c) == RPAREN || \
! 			     (c) == '*' || (c) == '+' || is_a_digit(c) || \
! 			     ISspace(c) || (c) == '-' || \
! 			     (c) == ']') ? 1 : 0)
! #define allowed_after_digit(c,word,k)  ((((c) == '.' && \
! 			     allowed_after_period(next((word),(k))))  ||\
! 				(c) == RPAREN || (c) == '}' || (c) == ']' ||\
! 				  ISspace(c) ||  is_a_digit(c) || \
! 				  ((c) == '-' ) && \
! 				    allowed_after_dash(next((word),(k)))) \
! 				? 1 : 0)
! #define allowed_after_period(c)	 (((c) == RPAREN || (c) == '}' || (c) == ']' ||\
! 				   ISspace(c) || (c) == '-' || \
! 				   is_a_digit(c)) ? 1 : 0)
! #define allowed_after_parenth(c)  (ISspace(c) ? 1 : 0)
! #define allowed_after_space(c)	  (ISspace(c) ? 1 : 0)
! #define allowed_after_braces(c)	  (ISspace(c) ? 1 : 0)
! #define allowed_after_star(c)	 ((ISspace(c) || (c) == RPAREN ||\
!                                        (c) == ']' || (c) == '}') ? 1 : 0)
! #define allowed_after_dash(c)	  ((ISspace(c) || is_a_digit(c)) ? 1 : 0)
! #define EOLchar(c)		  (((c) == '.' || (c) == ':' || (c) == '?' ||\
! 					(c) == '!') ? 1 : 0)
! 
! int indent_match(char **, LINE *, char *, int, int);
! 
! /* Extended justification support */
! #define is_cquote(c) ((c) == '>' || (c) == '|' || (c) == ']' || (c) == ':')
! #define is_cword(c)  ((((c) >= 'a') && ((c) <= 'z')) ||  \
!                      (((c) >= 'A') && ((c) <= 'Z')) || \
!                      (((c) >= '0') && ((c) <= '9')) || \
!                       ((c) == ' ') || ((c) == '?') || \
!                       ((c) == '@') || ((c) == '.') || \
!                       ((c) == '!') || ((c) == '\'') || \
!                       ((c) == ',') || ((c) == '\"') ? 1 : 0)
! #define isaquote(c)   ((c) == '\"' || (c) == '\'')
! #define is8bit(c)     ((((int) (c)) & 0x80) ? 1 : 0)
! #define iscontrol(c)  (iscntrl(((int) (c)) & 0x7f) ? 1 : 0)
! #define forbidden(c)  (((c) == '\"') || ((c) == '\'') || ((c) == '$') ||\
!                        ((c) == ',')  || ((c) == '.')  || ((c) == '-') ||\
!                        ((c) == LPAREN) || ((c) == '/')|| ((c) == '`') ||\
!                        ((c) == '{') || ((c) == '\\') || (iscontrol((c))) ||\
!                        (((c) >= '0')  && ((c) <= '9')) || ((c) == '?'))
! #define is_cletter(c)  ((((c) >= 'a') && ((c) <= 'z'))) ||\
!                        ((((c) >= 'A') && ((c) <= 'Z'))||\
!                       is8bit(c))
! #define is_cnumber(c) ((c) >= '0' && (c) <= '9')
! #define allwd_after_word(c) (((c) == ' ') || ((c) == '>') || is_cletter(c))
! #define allwd_after_qsword(c)  (((c) != '\\') && ((c) != RPAREN))
! #define before(word,i) (((i) > 0) ? (word)[(i) - 1] : 0)
! #define next(w,i) ((((w)[(i)]) != 0) ? ((w)[(i) + 1]) : 0)
! #define now(w,i)  ((w)[(i)])
! #define is_qsword(c)  (((c) == ':') || ((c) == RPAREN) ? 1 : 0)
! #define is_colon(c)   (((c) == ':') ? 1 : 0)
! #define is_rarrow(c)  (((c) == '>') ? 1 : 0)
! #define is_tilde(c)   (((c) == '~') ? 1 : 0)
! #define is_dash(c)    (((c) == '-') ? 1 : 0)
! #define is_pound(c)   (((c) == '#') ? 1 : 0)
! #define is_a_digit(c) ((((c) >= '0') && ((c) <= '9')) ? 1 : 0)
! #define is_allowed(c)  (is_cquote(c) || is_cword(c) || is_dash(c) || \
!                        is_pound(c))
! #define qs_allowed(a)  (((a)->qstype != qsGdb) && ((a)->qstype != qsProg))
! 
! /* Internal justification functions */
! QSTRING_S *qs_quote_match(char **, LINE *, char *, int);
! int      ucs4_strlenis(UCS *);
! void     linencpy(char *, LINE *, int);
  
! void
! linencpy(word, l, buflen)
!  char word[NSTRING];
!  LINE *l;
!  int buflen;
! {
!   int i;
!   UCS ucs_word[NSTRING];
!   char *utf_word;
! 
!   word[0] = '\0';
!   if(l){
!     for (i = 0; i < buflen && i < llength(l)
!                && (ucs_word[i] = lgetc(l,i).c); i++);
!     ucs_word[i == buflen ? i-1 : i] = '\0';
!     utf_word = ucs4_to_utf8_cpystr(ucs_word);
!     strncpy(word, utf_word, (NSTRING < buflen ? NSTRING : buflen));
!     word[NSTRING-1] = '\0';
!     if(utf_word) fs_give((void **)&utf_word);
!   }
! }
! 
!  /*
!   * This function returns the quote string as a structure. In this way we
!   * have two ways to get the quote string: as a char * or as a QSTRING_S *
!   * directly.
!   */
! QSTRING_S *
! qs_quote_match(char **q, LINE *l, char *rqstr, int rqstrlen)
! {
!     char GLine[NSTRING], NLine[NSTRING], PLine[NSTRING];
!     LINE *nl = l != curbp->b_linep ? lforw(l) : NULL;
!     LINE *pl = lback(l) != curbp->b_linep ? lback(l) : NULL;
!     int plb = 1;
! 
!    linencpy(GLine, l, NSTRING);
!    linencpy(NLine, nl, NSTRING);
! 
!    if (pl){
!       linencpy(PLine, pl, NSTRING);
!       if(lback(pl) != curbp->b_linep){
! 	char PPLine[NSTRING];
  
! 	linencpy(PPLine, lback(pl), NSTRING);
! 	plb = line_isblank(q, PLine, GLine, PPLine, NSTRING);
!       }
!    }
!    return do_quote_match(q, GLine, NLine, PLine, rqstr, rqstrlen, plb);
  }
  
  /*
   * Return number of quotes if whatever starts the line matches the quote string
+  * rqstr is a pointer to raw qstring; buf points to processed qstring
   */
  int
! quote_match(char **q, LINE *l, char *buf, size_t buflen, int raw)
  {
!     QSTRING_S *qs;
!     char rqstr[NSTRING];
! 
!     qs = qs_quote_match(q, l, rqstr, NSTRING);
!     if(qs)
! 	record_quote_string(qs);
!     flatten_qstring(qs, buf, buflen);
!     if (qs) free_qs(&qs);
! 
!     if(raw){
!       strncpy(buf, rqstr, buflen < NSTRING ? buflen : NSTRING);
!       buf[buflen-1] = '\0';
!     }
  
!     return  buf && buf[0] ? strlen(buf) : 0;
  }
  
+ int ucs4_strlenis(UCS *ucs_qstr)
+ {
+   char *str = ucs4_to_utf8_cpystr(ucs_qstr);
+   int i = (int) strlenis(str);
+ 
+   if(str) fs_give((void **)&str);
+   return i;
+ }
  
  /* Justify the entire buffer instead of just a paragraph */
  int
***************
*** 804,809 ****
--- 835,841 ----
      }
  
      if(action == 'R' && curwp->w_markp){
+ 	char qstrfl[NSTRING];
  	/* let yank() know that it may be restoring a paragraph */
  	thisflag |= CFFILL;
  
***************
*** 816,836 ****
  
  	/* determine if we're justifying quoted text or not */
  	qstr = (glo_quote_str
! 		&& quote_match(glo_quote_str, 
! 			       curwp->w_doto > 0 ? curwp->w_dotp->l_fp : curwp->w_dotp,
! 			       qstr2, NSTRING)
! 		&& *qstr2) ? qstr2 : NULL;
! 
  
  	/*
  	 * Fillregion moves dot to the end of the filled region.
  	 */
! 	if(!fillregion(qstr, &addedregion))
  	  return(FALSE);
  
  	set_last_region_added(&addedregion);
      }
      else if(action == 'P'){
  
  	/*
  	 * Justfiy the current paragraph.
--- 848,872 ----
  
  	/* determine if we're justifying quoted text or not */
  	qstr = (glo_quote_str
! 		&& quote_match(default_qstr(glo_quote_str, 1), 
! 			       (curwp->w_doto > 0 ? curwp->w_dotp->l_fp : curwp->w_dotp),
! 			       qstrfl, NSTRING, 0)
! 		&& *qstrfl) ? utf8_to_ucs4_cpystr(qstrfl) : NULL;
  
  	/*
  	 * Fillregion moves dot to the end of the filled region.
  	 */
! 	if(!fillregion(qstr, NULL, &addedregion))
  	  return(FALSE);
  
  	set_last_region_added(&addedregion);
+ 
+ 	if(qstr)
+ 	  fs_give((void **)&qstr);
      }
      else if(action == 'P'){
+ 	char ind_str[NSTRING], qstrfl[NSTRING];
+ 	UCS *istr;
  
  	/*
  	 * Justfiy the current paragraph.
***************
*** 842,858 ****
  	if(gotoeop(FALSE, 1) == FALSE)
  	  return(FALSE);
  
- 	/* determine if we're justifying quoted text or not */
- 	qstr = (glo_quote_str
- 		&& quote_match(glo_quote_str, 
- 			       curwp->w_dotp, qstr2, NSTRING)
- 		&& *qstr2) ? qstr2 : NULL;
- 
  	setmark(0,0);			/* mark last line of para */
  
  	/* jump back to the beginning of the paragraph */
  	gotobop(FALSE, 1);
  
  	/* let yank() know that it may be restoring a paragraph */
  	thisflag |= (CFFILL | CFFLPA);
  
--- 878,893 ----
  	if(gotoeop(FALSE, 1) == FALSE)
  	  return(FALSE);
  
  	setmark(0,0);			/* mark last line of para */
  
  	/* jump back to the beginning of the paragraph */
  	gotobop(FALSE, 1);
  
+ 	istr = indent_match(default_qstr(glo_quote_str, 1), curwp->w_dotp, ind_str, NSTRING, 0)
+ 	   && *ind_str  ? utf8_to_ucs4_cpystr(ind_str) : NULL;
+ 	qstr = (quote_match(default_qstr(glo_quote_str, 1), curwp->w_dotp, qstrfl, NSTRING, 0)
+             && *qstrfl) ? utf8_to_ucs4_cpystr(qstrfl) : NULL;
+ 
  	/* let yank() know that it may be restoring a paragraph */
  	thisflag |= (CFFILL | CFFLPA);
  
***************
*** 866,874 ****
  	/*
  	 * Fillregion moves dot to the end of the filled region.
  	 */
! 	if(!fillregion(qstr, &addedregion))
  	  return(FALSE);
  
  	set_last_region_added(&addedregion);
  
  	/* Leave cursor on first char of first line after justified region */
--- 901,915 ----
  	/*
  	 * Fillregion moves dot to the end of the filled region.
  	 */
! 	if(!fillregion(qstr, istr, &addedregion))
  	  return(FALSE);
  
+ 	if(qstr)
+ 	  fs_give((void **)&qstr);
+ 
+ 	if(istr)
+ 	  fs_give((void **)&istr);
+ 
  	set_last_region_added(&addedregion);
  
  	/* Leave cursor on first char of first line after justified region */
***************
*** 910,925 ****
   * can delete it and restore the saved part.
   */
  int
! fillregion(UCS *qstr, REGION *addedregion)
  {
      long    c, sz, last_char = 0;
!     int	    i, j, qlen, same_word,
  	    spaces, word_len, word_ind, line_len, ww;
      int     starts_midline = 0;
      int     ends_midline = 0;
      int     offset_into_start;
      LINE   *line_before_start, *lp;
!     UCS     line_last, word[NSTRING];
      REGION  region;
  
      /* if region starts midline insert a newline */
--- 951,966 ----
   * can delete it and restore the saved part.
   */
  int
! fillregion(UCS *qstr, UCS *istr, REGION *addedregion)
  {
      long    c, sz, last_char = 0;
!     int	    i, j, qlen, same_word, qi, pqi, qlenis,
  	    spaces, word_len, word_ind, line_len, ww;
      int     starts_midline = 0;
      int     ends_midline = 0;
      int     offset_into_start;
      LINE   *line_before_start, *lp;
!     UCS     line_last, word[NSTRING], quoid[NSTRING], qstr2[NSTRING];
      REGION  region;
  
      /* if region starts midline insert a newline */
***************
*** 930,935 ****
--- 971,1005 ----
      if(curwp->w_marko > 0 && curwp->w_marko < llength(curwp->w_markp))
        ends_midline++;
  
+     for (i = 0; (i < NSTRING) && qstr && (quoid[i] = qstr[i]); i++);
+     for (j = 0; ((i + j) < NSTRING) && istr && (quoid[i] = istr[j]); i++,j++);
+     quoid[i] = '\0';
+     qi = ucs4_strlen(quoid);
+     if (istr)			/* strip trailing spaces */
+        for (;ISspace(quoid[qi - 1]); qi--);
+     quoid[qi] = '\0';     /* we have closed quoid at "X" in the first line */
+ 
+     if (ucs4_strlenis(quoid) > fillcol)
+ 	return FALSE;		/* Too wide, we can't justify this! */
+ 
+     if (qstr && istr){
+ 	for (i = ucs4_strlen(qstr) - 1; ISspace(qstr[i]); i--);
+ 	qstr[i + 1] = '\0';	/* qstrfl */
+     }
+     qlen   = ucs4_strlen(qstr);	/* qstrfl*/
+     qlenis = ucs4_strlenis(qstr);
+ 
+     for(i = 0, qstr2[0] = '\0'; qstr && qstr[i] && (qstr2[i] = qstr[i]); i++);
+ 
+     if (istr && ((j = ucs4_strlenis(quoid) - ucs4_strlenis(qstr)) > 0)){
+ 	pqi = ucs4_strlen(qstr);
+ 	for (i = 0; (i < j) && (qstr2[pqi + i] = ' '); i++);
+ 	if (ISspace(istr[ucs4_strlen(istr) - 1]))
+ 	   qstr2[pqi + i++] = ' ';
+ 	qstr2[pqi + i] = '\0';
+ 	qstr = qstr2;
+     }
+ 
      /* cut the paragraph into our fill buffer */
      fdelete();
      if(!getregion(&region, curwp->w_markp, curwp->w_marko))
***************
*** 946,973 ****
  
      /* Now insert it back wrapped */
      spaces = word_len = word_ind = line_len = same_word = 0;
-     qlen = qstr ? ucs4_strlen(qstr) : 0;
  
      /* Beginning with leading quoting... */
!     if(qstr){
! 	i = 0;
! 	while(qstr[i]){
! 	  ww = wcellwidth(qstr[i]);
! 	  line_len += (ww >= 0 ? ww : 1);
! 	  linsert(1, qstr[i++]);
! 	}
  
  	line_last = ' ';			/* no word-flush space! */
      }
  
      /* remove first leading quotes if any */
      if(starts_midline)
        i = 0;
!     else
!       for(i = qlen; (c = fremove(i)) == ' ' || c == TAB; i++){
  	  linsert(1, line_last = (UCS) c);
  	  line_len += ((c == TAB) ? (~line_len & 0x07) + 1 : 1);
        }
  
      /* then digest the rest... */
      while((c = fremove(i++)) >= 0){
--- 1016,1051 ----
  
      /* Now insert it back wrapped */
      spaces = word_len = word_ind = line_len = same_word = 0;
  
      /* Beginning with leading quoting... */
!     if(qstr || istr){
! 	for(i = 0; quoid[i] != '\0' ; i++)
! 	  linsert(1, quoid[i]);
  
  	line_last = ' ';			/* no word-flush space! */
+         line_len = ucs4_strlenis(quoid);         /* we demand a recount! */
      }
  
      /* remove first leading quotes if any */
      if(starts_midline)
        i = 0;
!     else{
!       if(qstr || istr){
!         for (i = 0; (c = fremove(i)) != '\0'; i++){
!                 word[i] = c;
!                 word[i+1] = '\0';
!                 if(ucs4_strlenis(word) >= ucs4_strlenis(quoid))
!                 break;
!         }
! 	i++;
!       }
!       else
! 	i = 0;
!       for(; ISspace(c = fremove(i)); i++){
  	  linsert(1, line_last = (UCS) c);
  	  line_len += ((c == TAB) ? (~line_len & 0x07) + 1 : 1);
        }
+     }
  
      /* then digest the rest... */
      while((c = fremove(i++)) >= 0){
***************
*** 988,1008 ****
  
  	  case TAB :
  	  case ' ' :
  	    spaces++;
  	    break;
  
  	  default :
  	    if(spaces){				/* flush word? */
! 		if((line_len - qlen > 0)
  		   && line_len + word_len + 1 > fillcol
! 		   && ((ucs4_isspace(line_last))
  		       || (linsert(1, ' ')))
  		   && same_word == 0
  		   && (line_len = fpnewline(qstr)))
  		  line_last = ' ';	/* no word-flush space! */
  
  		if(word_len){			/* word to write? */
! 		    if(line_len && !ucs4_isspace(line_last)){
  			linsert(1, ' ');	/* need padding? */
  			line_len++;
  		    }
--- 1066,1087 ----
  
  	  case TAB :
  	  case ' ' :
+ 	  case NBSP:
  	    spaces++;
  	    break;
  
  	  default :
  	    if(spaces){				/* flush word? */
! 		if((line_len - qlenis > 0)
  		   && line_len + word_len + 1 > fillcol
! 		   && ((ISspace(line_last))
  		       || (linsert(1, ' ')))
  		   && same_word == 0
  		   && (line_len = fpnewline(qstr)))
  		  line_last = ' ';	/* no word-flush space! */
  
  		if(word_len){			/* word to write? */
! 		    if(line_len && !ISspace(line_last)){
  			linsert(1, ' ');	/* need padding? */
  			line_len++;
  		    }
***************
*** 1024,1031 ****
  
  	    if(word_ind + 1 >= NSTRING){
  		/* Magic!  Fake that we output a wrapped word */
! 		if((line_len - qlen > 0) && same_word == 0){
! 		    if(!ucs4_isspace(line_last))
  		      linsert(1, ' ');
  		    line_len = fpnewline(qstr);
  		}
--- 1103,1110 ----
  
  	    if(word_ind + 1 >= NSTRING){
  		/* Magic!  Fake that we output a wrapped word */
! 		if((line_len - qlenis > 0) && same_word == 0){
! 		    if(!ISspace(line_last))
  		      linsert(1, ' ');
  		    line_len = fpnewline(qstr);
  		}
***************
*** 1047,1058 ****
      }
  
      if(word_len){
! 	if((line_len - qlen > 0) && (line_len + word_len + 1 > fillcol) && same_word == 0){
! 	    if(!ucs4_isspace(line_last))
  	      linsert(1, ' ');
  	    (void) fpnewline(qstr);
  	}
! 	else if(line_len && !ucs4_isspace(line_last))
  	  linsert(1, ' ');
  
  	for(j = 0; j < word_ind; j++)
--- 1126,1137 ----
      }
  
      if(word_len){
! 	if((line_len - qlenis > 0) && (line_len + word_len + 1 > fillcol) && same_word == 0){
! 	    if(!ISspace(line_last))
  	      linsert(1, ' ');
  	    (void) fpnewline(qstr);
  	}
! 	else if(line_len && !ISspace(line_last))
  	  linsert(1, ' ');
  
  	for(j = 0; j < word_ind; j++)
***************
*** 1110,1120 ****
      int len;
  
      lnewline();
!     for(len = 0; quote && *quote; quote++){
  	int ww;
  
! 	ww = wcellwidth(*quote);
! 	len += (ww >= 0 ? ww : 1);
  	linsert(1, *quote);
      }
  
--- 1189,1199 ----
      int len;
  
      lnewline();
!     for(len = ucs4_strlenis(quote); quote && *quote; quote++){
  	int ww;
  
! /*	ww = wcellwidth(*quote);
! 	len += (ww >= 0 ? ww : 1);*/
  	linsert(1, *quote);
      }
  
***************
*** 1258,1262 ****
--- 1337,1381 ----
  	markregion(1);
      }
  
+     /*
+      * This puts us at the end of the quoted region instead
+      * of on the following line. This makes it convenient
+      * for the user to follow a quotelevel adjustment with
+      * a Justify if desired.
+      */
+     if(backuptoprevline){
+ 	curwp->w_doto = 0;
+ 	backchar(0, 1);
+     }
+ 
+     if(ends_midline){	/* doesn't need fixing otherwise */
+ 	unmarkbuffer();
+ 	markregion(1);
+     }
+ 
      return (TRUE);
  }
+ 
+ /*
+  * If there is an indent string this function returns
+  * its length
+  */ 
+ int
+ indent_match(char **q, LINE *l, char *buf, int buflen, int raw)
+ {
+      char GLine[NSTRING];
+      int  i, k, plb;
+        
+      k = quote_match(q,l, buf, buflen, raw);
+      linencpy(GLine, l, NSTRING);
+      plb = (lback(l) != curbp->b_linep) ? lisblank(lback(l)) : 1;
+      if (!plb){
+         i = llength(lback(l)) - 1;
+         for (; i >= 0 && ISspace(lgetc(lback(l), i).c); i--);
+         if (EOLchar(lgetc(lback(l), i).c))
+           plb++;
+      }      
+     
+      return get_indent_raw_line(q, GLine, buf, buflen, k, plb);
+ }
+ 
diff -rc alpine-2.11/pith/adrbklib.c alpine-2.11.I.USE/pith/adrbklib.c
*** alpine-2.11/pith/adrbklib.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/adrbklib.c	2013-12-01 16:34:45.000000000 -0700
***************
*** 5136,5143 ****
  	    if(as.cur >= as.how_many_personals)
  	      pab->type |= GLOBAL;
  
! 	    pab->access = adrbk_access(pab);
! 
  	    /* global address books are forced readonly */
  	    if(pab->type & GLOBAL && pab->access != NoAccess)
  	      pab->access = ReadOnly;
--- 5136,5149 ----
  	    if(as.cur >= as.how_many_personals)
  	      pab->type |= GLOBAL;
  
! 	    if(ps_global->mail_stream && 
! 		ps_global->mail_stream->lock && (pab->type & REMOTE_VIA_IMAP)){
! 	      as.initialized = 0;
! 	      pab->access = NoAccess;
! 	    }
! 	    else{
! 	      pab->access = adrbk_access(pab);
! 	    }
  	    /* global address books are forced readonly */
  	    if(pab->type & GLOBAL && pab->access != NoAccess)
  	      pab->access = ReadOnly;
diff -rc alpine-2.11/pith/charconv/utf8.c alpine-2.11.I.USE/pith/charconv/utf8.c
*** alpine-2.11/pith/charconv/utf8.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/charconv/utf8.c	2013-12-01 16:36:01.000000000 -0700
***************
*** 1049,1054 ****
--- 1049,1104 ----
  
  
  /*
+  * Returns the screen cells width of the UTF-8 string argument, treating tabs
+  * in a special way.
+  */
+ unsigned
+ utf8_widthis(char *str)
+ {
+     unsigned width = 0;
+     int this_width;
+     UCS ucs;
+     unsigned long remaining_octets;
+     char *readptr;
+ 
+     if(!(str && *str))
+       return(width);
+ 
+     readptr = str;
+     remaining_octets = readptr ? strlen(readptr) : 0;
+ 
+     while(remaining_octets > 0 && *readptr){
+ 
+ 	ucs = (UCS) utf8_get((unsigned char **) &readptr, &remaining_octets);
+ 
+ 	if(ucs & U8G_ERROR){
+ 	    /*
+ 	     * This should not happen, but do something to handle it anyway.
+ 	     * Treat each character as a single width character, which is what should
+ 	     * probably happen when we actually go to write it out.
+ 	     */
+ 	    remaining_octets--;
+ 	    readptr++;
+ 	    this_width = 1;
+ 	}
+ 	else{
+ 	    this_width = (ucs == TAB) ? ((~width & 0x07) + 1) : wcellwidth(ucs);
+ 
+ 	    /*
+ 	     * If this_width is -1 that means we can't print this character
+ 	     * with our current locale. Writechar will print a '?'.
+ 	     */
+ 	    if(this_width < 0)
+ 	      this_width = 1;
+ 	}
+ 
+ 	width += (unsigned) this_width;
+     }
+ 
+     return(width);
+ }
+ 
+ /*
   * Copy UTF-8 characters from src into dst.
   * This is intended to be used if you want to truncate a string at
   * the start instead of the end. For example, you have a long string
diff -rc alpine-2.11/pith/charconv/utf8.h alpine-2.11.I.USE/pith/charconv/utf8.h
*** alpine-2.11/pith/charconv/utf8.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/charconv/utf8.h	2013-12-01 16:36:01.000000000 -0700
***************
*** 81,86 ****
--- 81,87 ----
  UCS           *ucs4_strchr(UCS *s, UCS c);
  UCS           *ucs4_strrchr(UCS *s, UCS c);
  unsigned       utf8_width(char *);
+ unsigned       utf8_widthis(char *);
  size_t         utf8_to_width_rhs(char *, char *, size_t, unsigned);
  int            utf8_snprintf(char *, size_t, char *, ...);
  size_t         utf8_to_width(char *, char *, size_t, unsigned, unsigned *);
diff -rc alpine-2.11/pith/color.c alpine-2.11.I.USE/pith/color.c
*** alpine-2.11/pith/color.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/color.c	2013-12-01 16:36:01.000000000 -0700
***************
*** 21,27 ****
  #include "../pith/state.h"
  #include "../pith/conf.h"
  #include "../pith/filter.h"
! 
  
  char *
  color_embed(char *fg, char *bg)
--- 21,28 ----
  #include "../pith/state.h"
  #include "../pith/conf.h"
  #include "../pith/filter.h"
! #include "../pith/mailview.h"
! #include "../pico/estruct.h"
  
  char *
  color_embed(char *fg, char *bg)
***************
*** 70,92 ****
      struct quote_colors *next;
  };
  
  
  int
  color_a_quote(long int linenum, char *line, LT_INS_S **ins, void *is_flowed_msg)
  {
!     int countem = 0;
      struct variable *vars = ps_global->vars;
!     char *p;
      struct quote_colors *colors = NULL, *cp, *next;
      COLOR_PAIR *col = NULL;
      int is_flowed = is_flowed_msg ? *((int *)is_flowed_msg) : 0;
  
      p = line;
!     if(!is_flowed)
!       while(isspace((unsigned char)*p))
! 	p++;
  
!     if(p[0] == '>'){
  	struct quote_colors *c;
  
  	/*
--- 71,180 ----
      struct quote_colors *next;
  };
  
+ int
+ is_word (buf, i, j)
+  char buf[NSTRING];
+  int i, j;
+ {
+  return i <= j && is_letter(buf[i]) ?
+          (i < j ? is_word(buf,i+1,j) : 1) : 0;
+ }
+ 
+ int
+ is_mailbox(buf,i,j)
+ char buf[NSTRING];
+  int i, j;
+ {
+   return i <= j && (is_letter(buf[i]) || is_digit(buf[i]) || buf[i] == '.')
+          ? (i < j ? is_mailbox(buf,i+1,j) : 1) : 0;
+ }
+ 
+ int
+ next_level_quote(buf, line, i, is_flowed)
+    char *buf;
+    char **line;
+    int i;
+    int is_flowed;
+ {
+    int j;
+ 
+    if (!single_level(buf[i])){
+         if(is_mailbox(buf,i,i)){
+           for (j = i; buf[j] && !isspace(buf[j]); j++);
+           if (is_word(buf,i,j-1) || is_mailbox(buf,i,j-1))
+            j += isspace(buf[j]) ? 2 : 1;
+         }
+         else{
+            switch(buf[i]){
+              case ':' :
+                       if (next(buf,i) != RPAREN)
+                            j = i + 1;
+                       else
+                            j = i + 2;
+                     break;
+ 
+              case '-' :
+                      if (next(buf,i) != '-')
+                         j = i + 2;
+                      else
+                         j = i + 3;
+                     break;
+ 
+              case '+' :
+              case '*' :
+                     if (next(buf,i) != ' ')
+                        j = i + 2;
+                     else
+                        j = i + 3;
+                     break;
+ 
+              default  :
+                    for (j = i; buf[j] && !isspace(buf[j])
+                          && (!single_level(buf[i]) && !is_letter(buf[j])); j++);
+ 
+                    j += isspace(buf[j]) ? 1 : 0;
+                    break;
+              }
+         }
+         if (line && *line)
+            (*line) += j - i;
+     }
+     else{
+        j = i+1;
+        if (line && *line)
+           (*line)++;
+     }
+     if(!is_flowed){
+         if(line && *line)
+           for(; isspace((unsigned char)*(*line)); (*line)++);
+         for (i = j; isspace((unsigned char) buf[i]); i++);
+     }
+     else i = j;
+     if (is_flowed && i != j)
+        buf[i] = '\0';
+    return i;
+ }
  
  int
  color_a_quote(long int linenum, char *line, LT_INS_S **ins, void *is_flowed_msg)
  {
!     int countem = 0, i, j = 0;
      struct variable *vars = ps_global->vars;
!     char *p, buf[NSTRING] = {'\0'};
      struct quote_colors *colors = NULL, *cp, *next;
      COLOR_PAIR *col = NULL;
      int is_flowed = is_flowed_msg ? *((int *)is_flowed_msg) : 0;
+     int code;
+ 
+     code = (is_flowed ? IS_FLOWED : NO_FLOWED) | COLORAQUO;
+     select_quote(linenum, line, ins, (void *) &code);
+     strncpy(buf, tmp_20k_buf, NSTRING < SIZEOF_20KBUF ? NSTRING : SIZEOF_20KBUF);
+     buf[sizeof(buf)-1] = '\0';
  
      p = line;
!     for(i = 0; isspace((unsigned char)buf[i]); i++, p++);
  
!     if(buf[i]){
  	struct quote_colors *c;
  
  	/*
***************
*** 135,141 ****
        free_color_pair(&col);
  
      cp = NULL;
!     while(*p == '>'){
  	cp = (cp && cp->next) ? cp->next : colors;
  
  	if(countem > 0)
--- 223,229 ----
        free_color_pair(&col);
  
      cp = NULL;
!     while(buf[i]){
  	cp = (cp && cp->next) ? cp->next : colors;
  
  	if(countem > 0)
***************
*** 145,154 ****
  
  	countem = (countem == 1) ? 0 : countem;
  
! 	p++;
! 	if(!is_flowed)
! 	  for(; isspace((unsigned char)*p); p++)
! 	    ;
      }
  
      if(colors){
--- 233,241 ----
  
  	countem = (countem == 1) ? 0 : countem;
  
!        i = next_level_quote(buf, &p, i, is_flowed);
!        for (; isspace((unsigned char)*p); p++);
!        for (; isspace((unsigned char)buf[i]); i++);
      }
  
      if(colors){
***************
*** 211,217 ****
  	}
      }
  
!     return(0);
  }
  
  
--- 298,304 ----
  	}
      }
  
!     return(1);
  }
  
  
diff -rc alpine-2.11/pith/color.h alpine-2.11.I.USE/pith/color.h
*** alpine-2.11/pith/color.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/color.h	2013-12-01 16:36:01.000000000 -0700
***************
*** 21,26 ****
--- 21,44 ----
  #include "../pith/pattern.h"
  #include "../pith/osdep/color.h"
  
+ #define NO_FLOWED  0x0000
+ #define IS_FLOWED  0x0001
+ #define DELETEQUO  0x0010
+ #define COLORAQUO  0x0100
+ #define RAWSTRING  0x1000
+ 
+ /* This is needed for justification, I will move it to a better place later
+  * or maybe not
+  */
+ #define is_digit(c) ((((c) >= '0') && ((c) <= '9')) ? 1 : 0)
+ 
+ #define is_letter(c) (((c) >= 'a' && (c) <= 'z') || \
+                          ((c) >= 'A' && (c) <= 'Z'))
+ 
+ #define next(w,i) ((((w)[(i)]) != 0) ? ((w)[(i) + 1]) : 0)
+ 
+ #define single_level(c) (((c) == '>') || ((c) == '|') || ((c) == '~') || \
+                           ((c) == ']'))
  
  typedef struct spec_color_s {
      int   inherit;	/* this isn't a color, it is INHERIT */
***************
*** 80,85 ****
--- 98,104 ----
  /* exported protoypes */
  char	*color_embed(char *, char *);
  int	 colorcmp(char *, char *);
+ int	 next_level_quote(char *, char **, int, int);
  int	 color_a_quote(long, char *, LT_INS_S **, void *);
  void	 free_spec_colors(SPEC_COLOR_S **);
  
diff -rc alpine-2.11/pith/conf.c alpine-2.11.I.USE/pith/conf.c
*** alpine-2.11/pith/conf.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/conf.c	2013-12-01 16:40:52.000000000 -0700
***************
*** 29,34 ****
--- 29,35 ----
  #include "../pith/remote.h"
  #include "../pith/keyword.h"
  #include "../pith/mailview.h"
+ #include "../pith/rules.h"
  #include "../pith/list.h"
  #include "../pith/status.h"
  #include "../pith/ldap.h"
***************
*** 206,211 ****
--- 207,214 ----
  
  CONF_TXT_T cf_text_sort_key[] =		"Sets presentation order of messages in Index. Choices:\n# Subject, From, Arrival, Date, Size, To, Cc, OrderedSubj, Score, and Thread.\n# Order may be reversed by appending /Reverse. Default: \"Arrival\".";
  
+ CONF_TXT_T cf_text_thread_sort_key[] =        "#Sets presentation order of threads in thread index. Choices:\n#arrival, and thread.";
+ 
  CONF_TXT_T cf_text_addrbook_sort_rule[] =	"Sets presentation order of address book entries. Choices: dont-sort,\n# fullname-with-lists-last, fullname, nickname-with-lists-last, nickname\n# Default: \"fullname-with-lists-last\".";
  
  CONF_TXT_T cf_text_folder_sort_rule[] =	"Sets presentation order of folder list entries. Choices: alphabetical,\n# alpha-with-dirs-last, alpha-with-dirs-first.\n# Default: \"alpha-with-directories-last\".";
***************
*** 222,233 ****
--- 225,268 ----
  
  CONF_TXT_T cf_text_editor[] =		"Specifies the program invoked by ^_ in the Composer,\n# or the \"enable-alternate-editor-implicitly\" feature.";
  
+ CONF_TXT_T cf_text_compose_rules[] =	"Allows a user to set rules when composing messages.";
+  
+ CONF_TXT_T cf_text_forward_rules[] =	"Allows a user to set rules when forwarding messages.";
+  
+ CONF_TXT_T cf_text_reply_rules[] =	"Allows a user to set rules when replying messages.";
+  
+ CONF_TXT_T cf_text_index_rules[] =	"Allows a user to supersede global index format variable in designated folders.";
+  
+ CONF_TXT_T cf_text_key_def_rules[] =	"Allows a user to override keystrokes in certain screens.";
+ 
+ CONF_TXT_T cf_text_replace_rules[] =	"Allows a user to change the form a specify field in the index-format is \n# displayed.";
+  
+ CONF_TXT_T cf_text_reply_indent_rules[] = "Allows a user to change the form a specify a reply-indent-string\n# based of rules.";
+  
+ CONF_TXT_T cf_text_reply_leadin_rules[] =	"Allows a user to replace the reply-leadin message based on different parameters.";
+  
+ CONF_TXT_T cf_text_reply_subject_rules[] =	"Allows a user to replace the subject of a message in a customs based way";
+  
+ CONF_TXT_T cf_text_thread_displaystyle_rule[] = "Allows a user to specify the threading style of specific folders";
+  
+ CONF_TXT_T cf_text_thread_indexstyle_rule[] = "Allows a user to specify the threading index style of specific folders";
+  
+ CONF_TXT_T cf_text_save_rules[] =	"Allows a user to specify a save folder message for specific senders or folders.";
+  
+ CONF_TXT_T cf_text_smtp_rules[] =	"Allows a user to specify a smtp server to be used when sending e-mail,\n# according to the rules specified here.";
+  
+ CONF_TXT_T cf_text_sort_rules[] =	"Allows a user to specify the sort default order of a specific folder.";
+  
+ CONF_TXT_T cf_text_startup_rules[] =	"Allows a user to specify the position of a highlighted message when opening a \n# folder.";
+  
  CONF_TXT_T cf_text_speller[] =		"Specifies the program invoked by ^T in the Composer.";
  
  CONF_TXT_T cf_text_deadlets[] =		"Specifies the number of dead letter files to keep when canceling.";
  
  CONF_TXT_T cf_text_fillcol[] =		"Specifies the column of the screen where the composer should wrap.";
  
+ CONF_TXT_T cf_special_text_color[] =	"Specifies a comma separated list of text and regular expresions that Pine\n# will highlight";
+ 
  CONF_TXT_T cf_text_replystr[] =		"Specifies the string to insert when replying to a message.";
  
  CONF_TXT_T cf_text_quotereplstr[] =    	"Specifies the string to replace quotes with when viewing a message.";
***************
*** 340,345 ****
--- 375,382 ----
  
  CONF_TXT_T cf_text_busy_cue_rate[] =	"Number of times per-second to update busy cue messages";
  
+ CONF_TXT_T cf_text_sleep[] =	"The number of seconds between a viewer finishing opening a file and removing\n#it. See more details in configuration screen. Default: 0";
+ 
  CONF_TXT_T cf_text_mailcheck[] =	"The approximate number of seconds between checks for new mail";
  
  CONF_TXT_T cf_text_mailchecknoncurr[] =	"The approximate number of seconds between checks for new mail in folders\n# other than the current folder and inbox.\n# Default is same as mail-check-interval";
***************
*** 430,435 ****
--- 467,475 ----
  
  CONF_TXT_T cf_text_newsrc_path[] =		"Full path and name of NEWSRC file";
  
+ #ifndef _WINDOWS
+ CONF_TXT_T cf_text_maildir_location[] = "Location relative to your HOME directory of the directory where your INBOX\n# for the maildir format is located. Default value is \"Maildir\". If your\n# inbox is located at \"~/Maildir\" you do not need to change this value.\n# A common value is also \".maildir\"";
+ #endif
  
  /*----------------------------------------------------------------------
  These are the variables that control a number of pine functions.  They
***************
*** 520,525 ****
--- 560,567 ----
  	NULL,			cf_text_fcc_name_rule},
  {"sort-key",				0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	NULL,			cf_text_sort_key},
+ {"thread-sort-key",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+ 	NULL,			cf_text_thread_sort_key},
  {"addrbook-sort-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	"Address Book Sort Rule",	cf_text_addrbook_sort_rule},
  {"folder-sort-rule",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
***************
*** 542,547 ****
--- 584,617 ----
  	NULL,			cf_text_thread_exp_char},
  {"threading-lastreply-character",	0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	"Threading Last Reply Character",	cf_text_thread_lastreply_char},
+ {"threading-display-style-rule",	0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Threading Display Style Rule",	cf_text_thread_displaystyle_rule},
+ {"threading-index-style-rule",		0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Threading Index Style Rule",	cf_text_thread_indexstyle_rule},
+ {"compose-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Compose Rules",	cf_text_compose_rules},
+ {"forward-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Forward Rules", 	cf_text_forward_rules},
+ {"index-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
+ 	"Index Rules",		cf_text_index_rules},
+ {"key-definition-rules",		0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
+ 	"Key Definition Rules",	cf_text_key_def_rules},
+ {"replace-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
+ 	"Replace Rules",	cf_text_replace_rules},
+ {"reply-indent-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Reply Indent Rules",	cf_text_reply_indent_rules},
+ {"reply-leadin-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
+ 	"Reply Leadin Rules",	cf_text_reply_leadin_rules},
+ {"reply-subject-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
+ 	"Reply Subject Rules",	cf_text_reply_subject_rules},
+ {"save-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Save Rules",		cf_text_save_rules},
+ {"smtp-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Smtp Rules",		cf_text_smtp_rules},
+ {"sort-rules",				0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Sort Rules",		cf_text_sort_rules},
+ {"startup-rules",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	"Startup Rules",	cf_text_startup_rules},
  #ifndef	_WINDOWS
  {"display-character-set",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	NULL,			cf_text_disp_char_set},
***************
*** 560,565 ****
--- 630,637 ----
  	NULL,			cf_text_speller},
  {"composer-wrap-column",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	NULL,			cf_text_fillcol},
+ {"special-text-color",			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
+ 	NULL,			cf_special_text_color},
  {"reply-indent-string",			0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0,
  	NULL,			cf_text_replystr},
  {"reply-leadin",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
***************
*** 616,621 ****
--- 688,695 ----
  	NULL,			cf_text_stat_msg_delay},
  {"busy-cue-rate",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	NULL,			cf_text_busy_cue_rate},
+ {"sleep-interval-length",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+ 	NULL,			cf_text_sleep},
  {"mail-check-interval",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	NULL,			cf_text_mailcheck},
  {"mail-check-interval-noncurrent",	0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
***************
*** 630,635 ****
--- 704,713 ----
  	NULL,			cf_text_news_active},
  {"news-spool-directory",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	NULL,			cf_text_news_spooldir},
+ #ifndef _WINDOWS
+ {"maildir-location",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+ 	"Maildir Location",			cf_text_maildir_location},
+ #endif
  {"upload-command",			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
  	NULL,			cf_text_upload_cmd},
  {"upload-command-prefix",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
***************
*** 817,822 ****
--- 895,902 ----
  {"incoming-unseen-background-color",	0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0},
  {"signature-foreground-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0},
  {"signature-background-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0},
+ {"special-text-foreground-color",	0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0},
+ {"special-text-background-color",	0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0},
  {"prompt-foreground-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0},
  {"prompt-background-color",		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0},
  {"header-general-foreground-color",	0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0},
***************
*** 1566,1572 ****
      register struct variable *vars = ps->vars;
      int		 obs_header_in_reply = 0,     /* the obs_ variables are to       */
  		 obs_old_style_reply = 0,     /* support backwards compatibility */
! 		 obs_save_by_sender, i, def_sort_rev;
      long         rvl;
      PINERC_S    *fixedprc = NULL;
      FeatureLevel obs_feature_level;
--- 1646,1652 ----
      register struct variable *vars = ps->vars;
      int		 obs_header_in_reply = 0,     /* the obs_ variables are to       */
  		 obs_old_style_reply = 0,     /* support backwards compatibility */
! 		 obs_save_by_sender, i, def_sort_rev, thread_def_sort_rev;
      long         rvl;
      PINERC_S    *fixedprc = NULL;
      FeatureLevel obs_feature_level;
***************
*** 1591,1596 ****
--- 1671,1677 ----
      GLO_FEATURE_LEVEL		= cpystr("sappling");
      GLO_OLD_STYLE_REPLY		= cpystr(DF_OLD_STYLE_REPLY);
      GLO_SORT_KEY		= cpystr(DF_SORT_KEY);
+     GLO_THREAD_SORT_KEY		= cpystr(DF_THREAD_SORT_KEY);
      GLO_SAVED_MSG_NAME_RULE	= cpystr(DF_SAVED_MSG_NAME_RULE);
      GLO_FCC_RULE		= cpystr(DF_FCC_RULE);
      GLO_AB_SORT_RULE		= cpystr(DF_AB_SORT_RULE);
***************
*** 1615,1620 ****
--- 1696,1702 ----
      GLO_LOCAL_FULLNAME		= cpystr(DF_LOCAL_FULLNAME);
      GLO_LOCAL_ADDRESS		= cpystr(DF_LOCAL_ADDRESS);
      GLO_OVERLAP			= cpystr(DF_OVERLAP);
+     GLO_SLEEP			= cpystr("0");
      GLO_MAXREMSTREAM		= cpystr(DF_MAXREMSTREAM);
      GLO_MARGIN			= cpystr(DF_MARGIN);
      GLO_FILLCOL			= cpystr(DF_FILLCOL);
***************
*** 1985,1990 ****
--- 2067,2074 ----
      set_current_val(&vars[V_FORM_FOLDER], TRUE, TRUE);
      set_current_val(&vars[V_EDITOR], TRUE, TRUE);
      set_current_val(&vars[V_SPELLER], TRUE, TRUE);
+     set_current_val(&vars[V_SPECIAL_TEXT], TRUE, TRUE);
+     regex_pattern(VAR_SPECIAL_TEXT);
      set_current_val(&vars[V_IMAGE_VIEWER], TRUE, TRUE);
      set_current_val(&vars[V_BROWSER], TRUE, TRUE);
      set_current_val(&vars[V_SMTP_SERVER], TRUE, TRUE);
***************
*** 2069,2074 ****
--- 2153,2165 ----
  	}
      }
  
+     set_current_val(&vars[V_SLEEP], TRUE, TRUE);
+     ps->sleep = i = 0;
+     if(SVAR_SLEEP(ps, i, tmp_20k_buf, SIZEOF_20KBUF))
+       init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
+     else
+       ps->sleep = i;
+ 
      set_current_val(&vars[V_OVERLAP], TRUE, TRUE);
      ps->viewer_overlap = i = atoi(DF_OVERLAP);
      if(SVAR_OVERLAP(ps, i, tmp_20k_buf, SIZEOF_20KBUF))
***************
*** 2258,2263 ****
--- 2349,2360 ----
        mail_parameters(NULL, SET_NEWSSPOOL,
  		      (void *)VAR_NEWS_SPOOL_DIR);
  
+ #ifndef _WINDOWS
+     set_current_val(&vars[V_MAILDIR_LOCATION], TRUE, TRUE);
+     if(VAR_MAILDIR_LOCATION && VAR_MAILDIR_LOCATION[0])
+       mail_parameters(NULL, SET_MDINBOXPATH, (void *)VAR_MAILDIR_LOCATION);
+ #endif
+ 
      /* guarantee a save default */
      set_current_val(&vars[V_DEFAULT_SAVE_FOLDER], TRUE, TRUE);
      if(!VAR_DEFAULT_SAVE_FOLDER || !VAR_DEFAULT_SAVE_FOLDER[0])
***************
*** 2497,2503 ****
      set_current_val(&vars[V_ARCHIVED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_INCOMING_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_SORT_KEY], TRUE, TRUE);
!     if(decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev) == -1){
  	snprintf(tmp_20k_buf, SIZEOF_20KBUF, "Sort type \"%.200s\" is invalid", VAR_SORT_KEY);
  	init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
  	ps->def_sort = SortArrival;
--- 2594,2600 ----
      set_current_val(&vars[V_ARCHIVED_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_INCOMING_FOLDERS], TRUE, TRUE);
      set_current_val(&vars[V_SORT_KEY], TRUE, TRUE);
!     if(decode_sort(VAR_SORT_KEY, &ps->def_sort, &def_sort_rev,0) == -1){
  	snprintf(tmp_20k_buf, SIZEOF_20KBUF, "Sort type \"%.200s\" is invalid", VAR_SORT_KEY);
  	init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
  	ps->def_sort = SortArrival;
***************
*** 2506,2511 ****
--- 2603,2619 ----
      else
        ps->def_sort_rev = def_sort_rev;
  
+     set_current_val(&vars[V_THREAD_SORT_KEY], TRUE, TRUE);
+     if(decode_sort(VAR_THREAD_SORT_KEY, &ps->thread_def_sort, 
+                               &thread_def_sort_rev, 1) == -1){
+       sprintf(tmp_20k_buf, "Sort type \"%s\" is invalid", VAR_THREAD_SORT_KEY);
+       init_error(ps, SM_ORDER | SM_DING, 3, 5, tmp_20k_buf);
+       ps->thread_def_sort = SortThread;
+       ps->thread_def_sort_rev = 0;
+     }
+     else
+       ps->thread_def_sort_rev = thread_def_sort_rev;
+ 
      cur_rule_value(&vars[V_SAVED_MSG_NAME_RULE], TRUE, TRUE);
      {NAMEVAL_S *v; int i;
      for(i = 0; (v = save_msg_rules(i)); i++)
***************
*** 2592,2597 ****
--- 2700,2706 ----
        if(cmds_f)
          (*cmds_f)(ps, VAR_INIT_CMD_LIST);
  
+     (void)create_rule_list(ps_global->vars);
  #ifdef	_WINDOWS
      mswin_set_quit_confirm (F_OFF(F_QUIT_WO_CONFIRM, ps_global));
  #endif	/* _WINDOWS */
***************
*** 2795,2800 ****
--- 2904,2911 ----
  	 F_ALWAYS_SPELL_CHECK, h_config_always_spell_check, PREF_COMP, 0},
  
  /* Reply Prefs */
+ 	{"alternate-reply-menu", NULL,
+ 	 F_ALT_REPLY_MENU, h_config_alt_reply_menu, PREF_RPLY, 0},
  	{"copy-to-address-to-from-if-it-is-us", "Copy To Address to From if it is Us",
  	 F_COPY_TO_TO_FROM, h_config_copy_to_to_from, PREF_RPLY, 0},
  	{"enable-reply-indent-string-editing", NULL,
***************
*** 2839,2844 ****
--- 2950,2957 ----
  	 F_NO_FCC_ATTACH, h_config_no_fcc_attach, PREF_SEND, 0},
  	{"fcc-on-bounce", "Include Fcc When Bouncing Messages",
  	 F_FCC_ON_BOUNCE, h_config_fcc_on_bounce, PREF_SEND, 0},
+ 	{"return-path-uses-domain-name", NULL,
+ 	 F_USE_DOMAIN_NAME, h_config_use_domain, PREF_SEND, 0},
  	{"mark-fcc-seen", NULL,
  	 F_MARK_FCC_SEEN, h_config_mark_fcc_seen, PREF_SEND, 0},
  	{"fcc-only-without-confirm", "Send to Fcc Only Without Confirming",
***************
*** 2885,2890 ****
--- 2998,3007 ----
  	 F_SORT_DEFAULT_SAVE_ALPHA, h_config_sort_save_alpha, PREF_FLDR, 0},
  	{"vertical-folder-list", "Use Vertical Folder List",
  	 F_VERTICAL_FOLDER_LIST, h_config_vertical_list, PREF_FLDR, 0},
+ #ifndef _WINDOWS
+ 	{"use-courier-folder-list", "Courier Style Folder List",
+ 	 F_COURIER_FOLDER_LIST, h_config_courier_list, PREF_FLDR, 0},
+ #endif
  
  /* Addr book */
  	{"combined-addrbook-display", "Combined Address Book Display",
***************
*** 2901,2906 ****
--- 3018,3025 ----
  /* Index prefs */
  	{"auto-open-next-unread", NULL,
  	 F_AUTO_OPEN_NEXT_UNREAD, h_config_auto_open_unread, PREF_INDX, 0},
+ 	{"enable-circular-tab", NULL,
+ 	 F_AUTO_CIRCULAR_TAB, h_config_circular_tab, PREF_INDX, 0},
  	{"continue-tab-without-confirm", "Continue NextNew Without Confirming",
  	 F_TAB_NO_CONFIRM, h_config_tab_no_prompt, PREF_INDX, 0},
  	{"convert-dates-to-localtime", NULL,
***************
*** 2913,2918 ****
--- 3032,3039 ----
  	 F_ENABLE_SPACE_AS_TAB, h_config_cruise_mode, PREF_INDX, 0},
  	{"enable-cruise-mode-delete", "Enable Cruise Mode With Deleting",
  	 F_ENABLE_TAB_DELETES, h_config_cruise_mode_delete, PREF_INDX, 0},
+ 	{"mark-for-me-in-group", "Mark for Group Message to Me",
+ 	 F_MARK_FOR_GROUP, h_config_mark_for_group, PREF_INDX, 1},
  	{"mark-for-cc", "Mark for CC",
  	 F_MARK_FOR_CC, h_config_mark_for_cc, PREF_INDX, 1},
  	{"next-thread-without-confirm", "Read Next Thread Without Confirming",
***************
*** 2929,2934 ****
--- 3050,3057 ----
  	 F_COLOR_LINE_IMPORTANT, h_config_color_thrd_import, PREF_INDX, 0},
  	{"thread-sorts-by-arrival", "Thread Sorts by Arrival",
  	 F_THREAD_SORTS_BY_ARRIVAL, h_config_thread_sorts_by_arrival, PREF_INDX, 0},
+ 	{"enhanced-fancy-thread-support", "Enhanced Fancy Thread Support",
+ 	 F_ENHANCED_THREAD, h_config_enhanced_thread, PREF_INDX, 0},
  
  /* Viewer prefs */
  	{"enable-msg-view-addresses", "Enable Message View Address Links",
***************
*** 2939,2944 ****
--- 3062,3069 ----
  	 F_VIEW_SEL_URL, h_config_enable_view_url, PREF_VIEW, 1},
  	{"enable-msg-view-web-hostnames", "Enable Message View Web Hostname Links",
  	 F_VIEW_SEL_URL_HOST, h_config_enable_view_web_host, PREF_VIEW, 1},
+ 	{"enable-msg-view-long-url", "Enable Recognition of Long URLS without Delimiter",
+ 	 F_VIEW_LONG_URL, h_config_enable_long_url, PREF_VIEW, 0},
  	{"enable-msg-view-forced-arrows", "Enable Message View Forced Arrows",
  	 F_FORCE_ARROWS, h_config_enable_view_arrows, PREF_VIEW, 0},
  	/* set to TRUE for windows */
***************
*** 3036,3041 ****
--- 3161,3168 ----
  	 F_FORCE_LOW_SPEED, h_config_force_low_speed, PREF_OS_LWSD, 0},
  	{"auto-move-read-msgs", "Auto Move Read Messages",
  	 F_AUTO_READ_MSGS, h_config_auto_read_msgs, PREF_MISC, 0},
+ 	{"auto-move-read-msgs-using-rules", "Auto Move Read Messages Using Rules",
+ 	 F_AUTO_READ_MSGS_RULES, h_config_auto_read_msgs_rules, PREF_MISC, 0},
  	{"auto-unselect-after-apply", NULL,
  	 F_AUTO_UNSELECT, h_config_auto_unselect, PREF_MISC, 0},
  	{"auto-unzoom-after-apply", NULL,
***************
*** 3097,3102 ****
--- 3224,3231 ----
  	 F_FULL_AUTO_EXPUNGE, h_config_full_auto_expunge, PREF_MISC, 0},
  	{"force-arrow-cursor", NULL,
  	 F_FORCE_ARROW, h_config_force_arrow, PREF_MISC, 0},
+ 	{"ignore-size-changes", NULL,
+ 	 F_IGNORE_SIZE, h_config_ignore_size, PREF_MISC, 0},
  	{"maildrops-preserve-state", NULL,
  	 F_MAILDROPS_PRESERVE_STATE, h_config_maildrops_preserve_state,
  	 PREF_MISC, 0},
***************
*** 6483,6488 ****
--- 6612,6618 ----
      set_color_val(&vars[V_IND_OP_FORE_COLOR], 0);
      set_color_val(&vars[V_INCUNSEEN_FORE_COLOR], 0);
      set_color_val(&vars[V_SIGNATURE_FORE_COLOR], 0);
+     set_color_val(&vars[V_SPECIAL_TEXT_FORE_COLOR], 0);
  
      set_current_val(&ps->vars[V_INDEX_TOKEN_COLORS], TRUE, TRUE);
      set_current_val(&ps->vars[V_VIEW_HDR_COLORS], TRUE, TRUE);
***************
*** 7005,7010 ****
--- 7135,7146 ----
  
  	break;
  
+ #ifndef _WINDOWS
+       case F_COURIER_FOLDER_LIST:
+       mail_parameters(NULL,SET_COURIERSTYLE,(void *)(F_ON(f->id ,ps)? 1 : 0));
+       break; /* COURIER == 1, CCLIENT == 0, see maildir.h */
+ #endif
+ 
        case F_COLOR_LINE_IMPORTANT :
        case F_DATES_TO_LOCAL :
  	clear_index_cache(ps->mail_stream, 0);
***************
*** 7016,7021 ****
--- 7152,7158 ----
  	break;
  
        case F_MARK_FOR_CC :
+       case F_MARK_FOR_GROUP :
  	clear_index_cache(ps->mail_stream, 0);
  	if(THREADING() && sp_viewing_a_thread(ps->mail_stream))
  	  unview_thread(ps, ps->mail_stream, ps->msgmap);
***************
*** 7610,7619 ****
--- 7747,7786 ----
  	return(h_config_fcc_rule);
        case V_SORT_KEY :
  	return(h_config_sort_key);
+       case V_THREAD_SORT_KEY :
+         return(h_config_thread_sort_key);
        case V_AB_SORT_RULE :
  	return(h_config_ab_sort_rule);
        case V_FLD_SORT_RULE :
  	return(h_config_fld_sort_rule);
+       case V_THREAD_DISP_STYLE_RULES:
+ 	return(h_config_thread_display_style_rule);
+       case V_THREAD_INDEX_STYLE_RULES:
+ 	return(h_config_thread_index_style_rule);
+       case V_COMPOSE_RULES:
+ 	return(h_config_compose_rules);
+       case V_FORWARD_RULES:
+ 	return(h_config_forward_rules);
+       case V_INDEX_RULES:
+ 	return(h_config_index_rules);
+       case V_KEY_RULES:
+ 	return(h_config_key_macro_rules);
+       case V_REPLACE_RULES:
+ 	return(h_config_replace_rules);
+       case V_REPLY_INDENT_RULES:
+ 	return(h_config_reply_indent_rules);
+       case V_REPLY_LEADIN_RULES:
+ 	return(h_config_reply_leadin_rules);
+       case V_RESUB_RULES:
+ 	return(h_config_resub_rules);
+       case V_SAVE_RULES:
+ 	return(h_config_save_rules);
+       case V_SMTP_RULES:
+ 	return(h_config_smtp_rules);
+       case V_SORT_RULES:
+ 	return(h_config_sort_rules);
+       case V_STARTUP_RULES:
+ 	return(h_config_startup_rules);
        case V_POST_CHAR_SET :
  	return(h_config_post_char_set);
        case V_UNK_CHAR_SET :
***************
*** 7654,7659 ****
--- 7821,7828 ----
  	return(h_config_incoming_second_interv);
        case V_INCCHECKLIST :
  	return(h_config_incoming_list);
+       case V_SLEEP :
+ 	return(h_config_sleep);
        case V_OVERLAP :
  	return(h_config_viewer_overlap);
        case V_MAXREMSTREAM :
***************
*** 7664,7669 ****
--- 7833,7840 ----
  	return(h_config_scroll_margin);
        case V_DEADLETS :
  	return(h_config_deadlets);
+        case V_SPECIAL_TEXT :
+ 	return(h_config_special_text_to_color);
        case V_FILLCOL :
  	return(h_config_composer_wrap_column);
        case V_TCPOPENTIMEO :
***************
*** 7786,7791 ****
--- 7957,7966 ----
  	return(h_config_newmailwidth);
        case V_NEWSRC_PATH :
  	return(h_config_newsrc_path);
+ #ifndef _WINDOWS
+       case V_MAILDIR_LOCATION :
+ 	return(h_config_maildir_location);
+ #endif
        case V_BROWSER :
  	return(h_config_browser);
  #if defined(DOS) || defined(OS2)
***************
*** 7829,7834 ****
--- 8004,8012 ----
        case V_SIGNATURE_FORE_COLOR :
        case V_SIGNATURE_BACK_COLOR :
  	return(h_config_signature_color);
+       case V_SPECIAL_TEXT_FORE_COLOR :
+       case V_SPECIAL_TEXT_BACK_COLOR :
+ 	return(h_config_special_text_color);
        case V_PROMPT_FORE_COLOR :
        case V_PROMPT_BACK_COLOR :
  	return(h_config_prompt_color);
diff -rc alpine-2.11/pith/conf.h alpine-2.11.I.USE/pith/conf.h
*** alpine-2.11/pith/conf.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/conf.h	2013-12-01 16:40:52.000000000 -0700
***************
*** 144,153 ****
--- 144,196 ----
  #define VAR_SORT_KEY		     vars[V_SORT_KEY].current_val.p
  #define GLO_SORT_KEY		     vars[V_SORT_KEY].global_val.p
  #define COM_SORT_KEY		     vars[V_SORT_KEY].cmdline_val.p
+ #define VAR_THREAD_SORT_KEY	     vars[V_THREAD_SORT_KEY].current_val.p
+ #define GLO_THREAD_SORT_KEY	     vars[V_THREAD_SORT_KEY].global_val.p
+ #define COM_THREAD_SORT_KEY	     vars[V_THREAD_SORT_KEY].cmdline_val.p
  #define VAR_AB_SORT_RULE	     vars[V_AB_SORT_RULE].current_val.p
  #define GLO_AB_SORT_RULE	     vars[V_AB_SORT_RULE].global_val.p
  #define VAR_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].current_val.p
  #define GLO_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].global_val.p
+ #define VAR_COMPOSE_RULES	     vars[V_COMPOSE_RULES].current_val.l
+ #define GLO_COMPOSE_RULES	     vars[V_COMPOSE_RULES].global_val.l
+ #define USR_COMPOSE_RULES	     vars[V_COMPOSE_RULES].user_val.l
+ #define VAR_FORWARD_RULES	     vars[V_FORWARD_RULES].current_val.l
+ #define GLO_FORWARD_RULES	     vars[V_FORWARD_RULES].global_val.l
+ #define USR_FORWARD_RULES	     vars[V_FORWARD_RULES].user_val.l
+ #define VAR_INDEX_RULES		     vars[V_INDEX_RULES].current_val.l
+ #define GLO_INDEX_RULES		     vars[V_INDEX_RULES].global_val.l
+ #define USR_INDEX_RULES		     vars[V_INDEX_RULES].user_val.l
+ #define VAR_KEY_RULES		     vars[V_KEY_RULES].current_val.l
+ #define GLO_KEY_RULES		     vars[V_KEY_RULES].global_val.l
+ #define USR_KEY_RULES		     vars[V_KEY_RULES].user_val.l
+ #define VAR_REPLACE_RULES	     vars[V_REPLACE_RULES].current_val.l
+ #define GLO_REPLACE_RULES	     vars[V_REPLACE_RULES].global_val.l
+ #define USR_REPLACE_RULES	     vars[V_REPLACE_RULES].user_val.l
+ #define VAR_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].current_val.l
+ #define GLO_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].global_val.l
+ #define USR_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].user_val.l
+ #define VAR_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].current_val.l
+ #define GLO_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].global_val.l
+ #define USR_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].user_val.l
+ #define VAR_RESUB_RULES		     vars[V_RESUB_RULES].current_val.l
+ #define GLO_RESUB_RULES		     vars[V_RESUB_RULES].global_val.l
+ #define USR_RESUB_RULES		     vars[V_RESUB_RULES].user_val.l
+ #define VAR_THREAD_DISP_STYLE_RULES  vars[V_THREAD_DISP_STYLE_RULES].current_val.l
+ #define GLO_THREAD_DISP_STYLE_RULES  vars[V_THREAD_DISP_STYLE_RULES].global_val.l
+ #define VAR_THREAD_INDEX_STYLE_RULES vars[V_THREAD_INDEX_STYLE_RULES].current_val.l
+ #define GLO_THREAD_INDEX_STYLE_RULES vars[V_THREAD_INDEX_STYLE_RULES].global_val.l
+ #define VAR_SAVE_RULES		     vars[V_SAVE_RULES].current_val.l
+ #define GLO_SAVE_RULES		     vars[V_SAVE_RULES].global_val.l
+ #define USR_SAVE_RULES		     vars[V_SAVE_RULES].user_val.l
+ #define VAR_SMTP_RULES		     vars[V_SMTP_RULES].current_val.l
+ #define GLO_SMTP_RULES		     vars[V_SMTP_RULES].global_val.l
+ #define USR_SMTP_RULES		     vars[V_SMTP_RULES].user_val.l
+ #define VAR_SORT_RULES		     vars[V_SORT_RULES].current_val.l
+ #define GLO_SORT_RULES		     vars[V_SORT_RULES].global_val.l
+ #define USR_SORT_RULES		     vars[V_SORT_RULES].user_val.l
+ #define VAR_STARTUP_RULES	     vars[V_STARTUP_RULES].current_val.l
+ #define GLO_STARTUP_RULES	     vars[V_STARTUP_RULES].global_val.l
+ #define USR_STARTUP_RULES	     vars[V_STARTUP_RULES].user_val.l
  #ifndef	_WINDOWS
  #define VAR_CHAR_SET		     vars[V_CHAR_SET].current_val.p
  #define GLO_CHAR_SET		     vars[V_CHAR_SET].global_val.p
***************
*** 161,166 ****
--- 204,211 ----
  #define GLO_EDITOR		     vars[V_EDITOR].global_val.l
  #define VAR_SPELLER		     vars[V_SPELLER].current_val.p
  #define GLO_SPELLER		     vars[V_SPELLER].global_val.p
+ #define VAR_SPECIAL_TEXT	     vars[V_SPECIAL_TEXT].current_val.l
+ #define GLO_SPECIAL_TEXT	     vars[V_SPECIAL_TEXT].global_val.l
  #define VAR_FILLCOL		     vars[V_FILLCOL].current_val.p
  #define GLO_FILLCOL		     vars[V_FILLCOL].global_val.p
  #define VAR_DEADLETS		     vars[V_DEADLETS].current_val.p
***************
*** 229,234 ****
--- 274,281 ----
  #define GLO_OPENING_SEP		     vars[V_OPENING_SEP].global_val.p
  #define VAR_ABOOK_FORMATS	     vars[V_ABOOK_FORMATS].current_val.l
  #define VAR_INDEX_FORMAT	     vars[V_INDEX_FORMAT].current_val.p
+ #define VAR_SLEEP		     vars[V_SLEEP].current_val.p
+ #define GLO_SLEEP		     vars[V_SLEEP].global_val.p
  #define VAR_OVERLAP		     vars[V_OVERLAP].current_val.p
  #define GLO_OVERLAP		     vars[V_OVERLAP].global_val.p
  #define VAR_MAXREMSTREAM	     vars[V_MAXREMSTREAM].current_val.p
***************
*** 250,255 ****
--- 297,306 ----
  #define GLO_NEWS_ACTIVE_PATH	     vars[V_NEWS_ACTIVE_PATH].global_val.p
  #define VAR_NEWS_SPOOL_DIR	     vars[V_NEWS_SPOOL_DIR].current_val.p
  #define GLO_NEWS_SPOOL_DIR	     vars[V_NEWS_SPOOL_DIR].global_val.p
+ #ifndef _WINDOWS
+ #define VAR_MAILDIR_LOCATION	     vars[V_MAILDIR_LOCATION].current_val.p
+ #define GLO_MAILDIR_LOCATION	     vars[V_MAILDIR_LOCATION].global_val.p
+ #endif
  #define VAR_DISABLE_DRIVERS	     vars[V_DISABLE_DRIVERS].current_val.l
  #define VAR_DISABLE_AUTHS	     vars[V_DISABLE_AUTHS].current_val.l
  #define VAR_REMOTE_ABOOK_METADATA    vars[V_REMOTE_ABOOK_METADATA].current_val.p
***************
*** 456,461 ****
--- 507,514 ----
  #define GLO_SIGNATURE_FORE_COLOR     vars[V_SIGNATURE_FORE_COLOR].global_val.p
  #define VAR_SIGNATURE_BACK_COLOR     vars[V_SIGNATURE_BACK_COLOR].current_val.p
  #define GLO_SIGNATURE_BACK_COLOR     vars[V_SIGNATURE_BACK_COLOR].global_val.p
+ #define VAR_SPECIAL_TEXT_FORE_COLOR  vars[V_SPECIAL_TEXT_FORE_COLOR].current_val.p
+ #define VAR_SPECIAL_TEXT_BACK_COLOR  vars[V_SPECIAL_TEXT_BACK_COLOR].current_val.p
  #define VAR_PROMPT_FORE_COLOR	     vars[V_PROMPT_FORE_COLOR].current_val.p
  #define VAR_PROMPT_BACK_COLOR	     vars[V_PROMPT_BACK_COLOR].current_val.p
  #define VAR_VIEW_HDR_COLORS	     vars[V_VIEW_HDR_COLORS].current_val.l
***************
*** 671,676 ****
--- 724,733 ----
   */
  #define Q_SUPP_LIMIT (4)
  #define Q_DEL_ALL    (-10)
+ #define	SVAR_SLEEP(ps,n,e,el)	strtoval((ps)->VAR_SLEEP,		  \
+ 					 &(n), 0, 120, 0, (e),		  \
+ 					  (el), 			  \
+ 					 "Sleep-Interval-Length")
  #define	SVAR_OVERLAP(ps,n,e,el)	strtoval((ps)->VAR_OVERLAP,		  \
  					 &(n), 0, 20, 0, (e),		  \
  					  (el), 			  \
diff -rc alpine-2.11/pith/conftype.h alpine-2.11.I.USE/pith/conftype.h
*** alpine-2.11/pith/conftype.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/conftype.h	2013-12-01 16:40:52.000000000 -0700
***************
*** 59,64 ****
--- 59,65 ----
  		, V_SAVED_MSG_NAME_RULE
  		, V_FCC_RULE
  		, V_SORT_KEY
+ 		, V_THREAD_SORT_KEY
  		, V_AB_SORT_RULE
  		, V_FLD_SORT_RULE
  		, V_GOTO_DEFAULT_RULE
***************
*** 70,75 ****
--- 71,90 ----
  		, V_THREAD_MORE_CHAR
  		, V_THREAD_EXP_CHAR
  		, V_THREAD_LASTREPLY_CHAR
+ 		, V_THREAD_DISP_STYLE_RULES
+ 		, V_THREAD_INDEX_STYLE_RULES
+ 		, V_COMPOSE_RULES
+ 		, V_FORWARD_RULES
+ 		, V_INDEX_RULES
+ 		, V_KEY_RULES
+ 		, V_REPLACE_RULES
+ 		, V_REPLY_INDENT_RULES
+ 		, V_REPLY_LEADIN_RULES
+ 		, V_RESUB_RULES
+ 		, V_SAVE_RULES
+ 		, V_SMTP_RULES
+ 		, V_SORT_RULES
+ 		, V_STARTUP_RULES
  #ifndef	_WINDOWS
  		, V_CHAR_SET
  		, V_OLD_CHAR_SET
***************
*** 80,85 ****
--- 95,101 ----
  		, V_EDITOR
  		, V_SPELLER
  		, V_FILLCOL
+ 		, V_SPECIAL_TEXT
  		, V_REPLY_STRING
  		, V_REPLY_INTRO
  		, V_QUOTE_REPLACE_STRING
***************
*** 108,113 ****
--- 124,130 ----
  		, V_MARGIN
  		, V_STATUS_MSG_DELAY
  		, V_ACTIVE_MSG_INTERVAL
+ 		, V_SLEEP
  		, V_MAILCHECK
  		, V_MAILCHECKNONCURR
  		, V_MAILDROPCHECK
***************
*** 115,120 ****
--- 132,140 ----
  		, V_NEWSRC_PATH
  		, V_NEWS_ACTIVE_PATH
  		, V_NEWS_SPOOL_DIR
+ #ifndef _WINDOWS
+ 		, V_MAILDIR_LOCATION
+ #endif
  		, V_UPLOAD_CMD
  		, V_UPLOAD_CMD_PREFIX
  		, V_DOWNLOAD_CMD
***************
*** 230,235 ****
--- 250,257 ----
  		, V_INCUNSEEN_BACK_COLOR
  		, V_SIGNATURE_FORE_COLOR
  		, V_SIGNATURE_BACK_COLOR
+ 		, V_SPECIAL_TEXT_FORE_COLOR
+ 		, V_SPECIAL_TEXT_BACK_COLOR
  		, V_PROMPT_FORE_COLOR
  		, V_PROMPT_BACK_COLOR
  		, V_HEADER_GENERAL_FORE_COLOR
***************
*** 327,332 ****
--- 349,355 ----
  	F_FULL_AUTO_EXPUNGE,
  	F_EXPUNGE_MANUALLY,
  	F_AUTO_READ_MSGS,
+ 	F_AUTO_READ_MSGS_RULES,
  	F_AUTO_FCC_ONLY,
  	F_READ_IN_NEWSRC_ORDER,
  	F_SELECT_WO_CONFIRM,
***************
*** 342,350 ****
--- 365,375 ----
  	F_FORCE_ARROW,
  	F_PRUNE_USES_ISO,
  	F_ALT_ED_NOW,
+ 	F_IGNORE_SIZE,
  	F_SHOW_DELAY_CUE,
  	F_CANCEL_CONFIRM,
  	F_AUTO_OPEN_NEXT_UNREAD,
+ 	F_AUTO_CIRCULAR_TAB,
  	F_DISABLE_INDEX_LOCALE_DATES,
  	F_SELECTED_SHOWN_BOLD,
  	F_QUOTE_ALL_FROMS,
***************
*** 388,397 ****
--- 413,426 ----
  	F_PASS_C1_CONTROL_CHARS,
  	F_SINGLE_FOLDER_LIST,
  	F_VERTICAL_FOLDER_LIST,
+ #ifndef _WINDOWS
+ 	F_COURIER_FOLDER_LIST,
+ #endif
  	F_TAB_CHK_RECENT,
  	F_AUTO_REPLY_TO,
  	F_VERBOSE_POST,
  	F_FCC_ON_BOUNCE,
+ 	F_USE_DOMAIN_NAME,
  	F_SEND_WO_CONFIRM,
  	F_USE_SENDER_NOT_X,
  	F_BLANK_KEYMENU,
***************
*** 408,413 ****
--- 437,443 ----
  	F_FIRST_SEND_FILTER_DFLT,
  	F_ALWAYS_LAST_FLDR_DFLT,
  	F_TAB_TO_NEW,
+ 	F_MARK_FOR_GROUP,
  	F_MARK_FOR_CC,
  	F_WARN_ABOUT_NO_SUBJECT,
  	F_WARN_ABOUT_NO_FCC,
***************
*** 443,448 ****
--- 473,479 ----
  	F_VIEW_SEL_ATTACH,
  	F_VIEW_SEL_URL,
  	F_VIEW_SEL_URL_HOST,
+ 	F_VIEW_LONG_URL,
  	F_SCAN_ADDR,
  	F_FORCE_ARROWS,
  	F_PREFER_PLAIN_TEXT,
***************
*** 501,511 ****
--- 532,544 ----
  	F_MAILDROPS_PRESERVE_STATE,
  	F_EXPOSE_HIDDEN_CONFIG,
  	F_ALT_COMPOSE_MENU,
+ 	F_ALT_REPLY_MENU,
  	F_ALT_ROLE_MENU,
  	F_ALWAYS_SPELL_CHECK,
  	F_QUELL_TIMEZONE,
  	F_QUELL_USERAGENT,
  	F_COLOR_LINE_IMPORTANT,
+ 	F_ENHANCED_THREAD,
  	F_SLASH_COLL_ENTIRE,
  	F_ENABLE_FULL_HDR_AND_TEXT,
  	F_QUELL_FULL_HDR_RESET,
***************
*** 713,717 ****
--- 746,751 ----
  
  /* exported protoypes */
  
+ #define DF_THREAD_SORT_KEY  "thread"
  
  #endif /* PITH_CONFTYPE_INCLUDED */
diff -rc alpine-2.11/pith/detoken.c alpine-2.11.I.USE/pith/detoken.c
*** alpine-2.11/pith/detoken.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/detoken.c	2013-12-01 16:34:54.000000000 -0700
***************
*** 24,30 ****
  #include "../pith/reply.h"
  #include "../pith/mailindx.h"
  #include "../pith/options.h"
! 
  
  /*
   * Hook to read signature from local file
--- 24,30 ----
  #include "../pith/reply.h"
  #include "../pith/mailindx.h"
  #include "../pith/options.h"
! #include "../pith/rules.h"
  
  /*
   * Hook to read signature from local file
***************
*** 90,95 ****
--- 90,97 ----
  
      if(is_sig){
  	/*
+ 	 * First we check if there is a rule about signatures, if there is
+ 	 * use it, otherwise keep going and do the following:
  	 * If role->litsig is set, we use it;
  	 * Else, if VAR_LITERAL_SIG is set, we use that;
  	 * Else, if role->sig is set, we use that;
***************
*** 103,116 ****
  	 * there is no reason to mix them, so we don't provide support to
  	 * do so.
  	 */
! 	if(role && role->litsig)
! 	  literal_sig = role->litsig;
! 	else if(ps_global->VAR_LITERAL_SIG)
! 	  literal_sig = ps_global->VAR_LITERAL_SIG;
! 	else if(role && role->sig)
! 	  sigfile = role->sig;
! 	else
! 	  sigfile = ps_global->VAR_SIGNATURE_FILE;
      }
      else if(role && role->template)
        sigfile = role->template;
--- 105,129 ----
  	 * there is no reason to mix them, so we don't provide support to
  	 * do so.
  	 */
!         { RULE_RESULT *rule;
!            rule = get_result_rule(V_COMPOSE_RULES, FOR_COMPOSE, env);
!            if (rule){
!                sigfile = cpystr(rule->result);
! 	       if (rule->result)
! 	          fs_give((void **)&rule->result);
! 	       fs_give((void **)&rule);
! 	   }
!         }
! 	if (!sigfile){
! 	  if(role && role->litsig)
! 	    literal_sig = role->litsig;
! 	  else if(ps_global->VAR_LITERAL_SIG)
! 	    literal_sig = ps_global->VAR_LITERAL_SIG;
! 	  else if(role && role->sig)
! 	    sigfile = role->sig;
! 	  else
! 	    sigfile = ps_global->VAR_SIGNATURE_FILE;
! 	}
      }
      else if(role && role->template)
        sigfile = role->template;
***************
*** 301,307 ****
  			}
  		    }
  		}
! 		else if(pt->what_for & FOR_REPLY_INTRO)
  		  repl = get_reply_data(env, role, pt->ctype,
  					subbuf, sizeof(subbuf)-1);
  
--- 314,320 ----
  			}
  		    }
  		}
! 		else if(pt->what_for & (FOR_REPLY_INTRO | FOR_RULE))
  		  repl = get_reply_data(env, role, pt->ctype,
  					subbuf, sizeof(subbuf)-1);
  
diff -rc alpine-2.11/pith/filter.c alpine-2.11.I.USE/pith/filter.c
*** alpine-2.11/pith/filter.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/filter.c	2013-12-01 16:41:02.000000000 -0700
***************
*** 46,51 ****
--- 46,52 ----
  #include "../pith/conf.h"
  #include "../pith/store.h"
  #include "../pith/color.h"
+ #include "../pith/osdep/color.h"
  #include "../pith/escapes.h"
  #include "../pith/pipe.h"
  #include "../pith/status.h"
***************
*** 1375,1388 ****
  	register unsigned char t = f->t;
  	register int n = (int) f->n;
  	register int state = f->f1;
  
  	while(GF_GETC(f, c)){
  
  	    if(state){
  		state = 0;
  		if (c != '=') {
! 		    gf_error("Illegal '=' in base64 text");
! 		    /* NO RETURN */
  		}
  	    }
  
--- 1376,1399 ----
  	register unsigned char t = f->t;
  	register int n = (int) f->n;
  	register int state = f->f1;
+ 	register unsigned char lastc;
  
  	while(GF_GETC(f, c)){
  
+ 	    lastc = c;
+ 	    if(f->f2){
+ 		GF_PUTC(f->next, c);
+ 		continue;
+ 	    }
+ 
  	    if(state){
  		state = 0;
  		if (c != '=') {
! 		    f->f2++;
! 		    GF_PUTC(f->next, c);
! 		    q_status_message(SM_ORDER,3,3,
! 			_("Warning: Illegal '=' in base64 text"));
! 		    continue;
  		}
  	    }
  
***************
*** 1399,1406 ****
  			break;
  
  		      default:		/* impossible quantum position */
! 			gf_error("Internal base64 decoder error");
! 			/* NO RETURN */
  		    }
  		}
  	    }
--- 1410,1420 ----
  			break;
  
  		      default:		/* impossible quantum position */
! 			f->f2++;
! 			GF_PUTC(f->next, lastc);
! 			q_status_message(SM_ORDER,3,3,
! 			_("Warning: Internal base64 decode error"));
! 			break;
  		    }
  		}
  	    }
***************
*** 1441,1446 ****
--- 1455,1461 ----
  	dprint((9, "-- gf_reset b64_binary\n"));
  	f->n  = 0L;			/* quantum position */
  	f->f1 = 0;			/* state holder: equal seen? */
+ 	f->f2 = 0;			/* No errors when we start */
      }
  }
  
***************
*** 7599,7604 ****
--- 7614,7620 ----
  		char	*p, buf[MAILTMPLEN];
  		ADDRESS *adr;
  		extern char datestamp[];
+ 		extern char plevstamp[];
  
  		if(!strcmp(s = removing_quotes(s + 4), "ALPINE_VERSION")){
  		    p = ALPINE_VERSION;
***************
*** 7612,7617 ****
--- 7628,7636 ----
  		else if(!strcmp(s, "ALPINE_COMPILE_DATE")){
  		    p = datestamp;
  		}
+ 		else if(!strcmp(s, "ALPINE_PATCHLEVEL")){
+ 		    p = plevstamp;
+ 		}
  		else if(!strcmp(s, "ALPINE_TODAYS_DATE")){
  		    rfc822_date(p = buf);
  		}
***************
*** 9167,9172 ****
--- 9186,9196 ----
  		margin_r,
  		indent;
      char	special[256];
+     long	curlinenum;	/* current line number */
+     int		curqstrpos;	/* current position in quote string */
+     long	linenum;	/* line number */
+     long	qstrlen;	/* multiples of 100 */
+     char      **qstrln;		/* qstrln[i] = quote string line i - 1 */
  } WRAP_S;
  
  #define	WRAP_MARG_L(F)	(((WRAP_S *)(F)->opt)->margin_l)
***************
*** 9208,9213 ****
--- 9232,9243 ----
  #define	WRAP_COLOR(F)	(((WRAP_S *)(F)->opt)->color)
  #define	WRAP_COLOR_SET(F)  ((WRAP_COLOR(F)) && (WRAP_COLOR(F)->fg[0]))
  #define	WRAP_SPACES(F)	(((WRAP_S *)(F)->opt)->spaces)
+ #define	WRAP_CURLINE(F)	(((WRAP_S *)(F)->opt)->curlinenum)
+ #define	WRAP_CURPOS(F)	(((WRAP_S *)(F)->opt)->curqstrpos)
+ #define	WRAP_LINENUM(F)	(((WRAP_S *)(F)->opt)->linenum)
+ #define	WRAP_QSTRLEN(F)	(((WRAP_S *)(F)->opt)->qstrlen)
+ #define	WRAP_QSTRN(F)	(((WRAP_S *)(F)->opt)->qstrln)
+ #define	WRAP_QSTR(F, N)	(((WRAP_S *)(F)->opt)->qstrln[(N)])
  #define	WRAP_PUTC(F,C,W) {						\
  			    if((F)->linep == WRAP_LASTC(F)){		\
  				size_t offset = (F)->linep - (F)->line;	\
***************
*** 9285,9290 ****
--- 9315,9322 ----
  	      case CCR :				/* CRLF or CR in text ? */
  		state = BOL;				/* either way, handle start */
  
+ 		WRAP_CURLINE(f)++;
+ 		WRAP_CURPOS(f) = 0;
  		if(WRAP_FLOW(f)){
  		    /* wrapped line? */
  		    if(f->f2 == 0 && WRAP_SPC_LEN(f) && WRAP_TRL_SPC(f)){
***************
*** 9378,9384 ****
  
  	      case BOL :
  		if(WRAP_FLOW(f)){
! 		    if(c == '>'){
  			WRAP_FL_QC(f) = 1;		/* init it */
  			state = FL_QLEV;		/* go collect it */
  		    }
--- 9410,9420 ----
  
  	      case BOL :
  		if(WRAP_FLOW(f)){
! 		    if(WRAP_CURLINE(f) < WRAP_QSTRLEN(f) 
! 			&& WRAP_QSTR(f, WRAP_CURLINE(f)) 
! 			&& WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)]
! 			&& WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)] == c){
! 			WRAP_CURPOS(f)++;
  			WRAP_FL_QC(f) = 1;		/* init it */
  			state = FL_QLEV;		/* go collect it */
  		    }
***************
*** 9392,9398 ****
  			}
  
  			/* quote level change implies new paragraph */
! 			if(WRAP_FL_QD(f)){
  			    WRAP_FL_QD(f) = 0;
  			    if(WRAP_HARD(f) == 0){
  				WRAP_HARD(f) = 1;
--- 9428,9443 ----
  			}
  
  			/* quote level change implies new paragraph */
! 			if (WRAP_CURLINE(f) > 0 
! 			&& WRAP_CURLINE(f) < WRAP_QSTRLEN(f)
! 			&& (WRAP_QSTR(f, WRAP_CURLINE(f)) != NULL
! 			     || WRAP_QSTR(f, WRAP_CURLINE(f) - 1) != NULL)
! 			&& ((WRAP_QSTR(f, WRAP_CURLINE(f)) != NULL && 
! 			     WRAP_QSTR(f, WRAP_CURLINE(f) - 1) == NULL)
! 			   || (WRAP_QSTR(f, WRAP_CURLINE(f)) == NULL && 
! 			       WRAP_QSTR(f, WRAP_CURLINE(f) - 1) != NULL)
! 			   || strcmp(WRAP_QSTR(f, WRAP_CURLINE(f)),
! 				     WRAP_QSTR(f, WRAP_CURLINE(f) - 1)))){
  			    WRAP_FL_QD(f) = 0;
  			    if(WRAP_HARD(f) == 0){
  				WRAP_HARD(f) = 1;
***************
*** 9444,9451 ****
  		break;
  
  	      case  FL_QLEV :
! 		if(c == '>'){				/* another level */
! 		    WRAP_FL_QC(f)++;
  		}
  		else {
  		    /* if EMBEDed, process it and return here */
--- 9489,9500 ----
  		break;
  
  	      case  FL_QLEV :
! 		if(WRAP_CURLINE(f) < WRAP_QSTRLEN(f)
! 		   && WRAP_QSTR(f, WRAP_CURLINE(f)) 
! 		   && WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)]
! 		   && WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)] == c){
! 		    WRAP_CURPOS(f)++;
! 		    WRAP_FL_QC(f)++; 			/* another level */
  		}
  		else {
  		    /* if EMBEDed, process it and return here */
***************
*** 9457,9463 ****
  		    }
  
  		    /* quote level change signals new paragraph */
! 		    if(WRAP_FL_QC(f) != WRAP_FL_QD(f)){
  			WRAP_FL_QD(f) = WRAP_FL_QC(f);
  			if(WRAP_HARD(f) == 0){		/* add hard newline */ 
  			    WRAP_HARD(f) = 1;		/* hard newline */
--- 9506,9521 ----
  		    }
  
  		    /* quote level change signals new paragraph */
! 		    if (WRAP_CURLINE(f) > 0 
! 			&& WRAP_CURLINE(f) < WRAP_QSTRLEN(f)
! 			&& (WRAP_QSTR(f, WRAP_CURLINE(f))
! 			     || WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
! 			&& ((WRAP_QSTR(f, WRAP_CURLINE(f)) && 
! 			     !WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
! 			   || (!WRAP_QSTR(f, WRAP_CURLINE(f)) && 
! 			       WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
! 			   || strcmp(WRAP_QSTR(f, WRAP_CURLINE(f)),
! 				      WRAP_QSTR(f, WRAP_CURLINE(f) - 1)))){
  			WRAP_FL_QD(f) = WRAP_FL_QC(f);
  			if(WRAP_HARD(f) == 0){		/* add hard newline */ 
  			    WRAP_HARD(f) = 1;		/* hard newline */
***************
*** 9514,9519 ****
--- 9572,9584 ----
  		    state = FL_SIG;
  		    break;
  
+ 		  case ' ' :				/* what? */
+ 		   if (WRAP_CURLINE(f) < WRAP_QSTRLEN(f) 
+ 			&& WRAP_QSTR(f, WRAP_CURLINE(f))){
+ 			WRAP_SPC_LEN(f)++;
+ 			so_writec(' ', WRAP_SPACES(f));
+ 		   }
+ 
  		  default :				/* something else */
  		    state = DFL;
  		    goto case_dfl;			/* handle c like DFL */
***************
*** 9530,9536 ****
  					     &eob);      /* note any embedded*/
  			    wrap_eol(f, 1, &ip, &eib,
  				     &op, &eob);       /* plunk down newline */
! 			    wrap_bol(f, 1, 1, &ip, &eib,
  				     &op, &eob);         /* write any prefix */
  			}
  
--- 9595,9601 ----
  					     &eob);      /* note any embedded*/
  			    wrap_eol(f, 1, &ip, &eib,
  				     &op, &eob);       /* plunk down newline */
! 			    wrap_bol(f, 1, WRAP_FLOW(f), &ip, &eib,
  				     &op, &eob);         /* write any prefix */
  			}
  
***************
*** 10027,10033 ****
  		    wrap_flush_embed(f, &ip, &eib, &op, &eob);
  		    wrap_eol(f, 1, &ip, &eib, &op,
  			     &eob);	    /* plunk down newline */
! 		    wrap_bol(f,1,1, &ip, &eib, &op,
  			     &eob);	      /* write any prefix */
  		}
  
--- 10092,10098 ----
  		    wrap_flush_embed(f, &ip, &eib, &op, &eob);
  		    wrap_eol(f, 1, &ip, &eib, &op,
  			     &eob);	    /* plunk down newline */
! 		    wrap_bol(f,1,WRAP_FLOW(f), &ip, &eib, &op,
  			     &eob);	      /* write any prefix */
  		}
  
***************
*** 10100,10105 ****
--- 10165,10177 ----
  	if(WRAP_COLOR(f))
  	  free_color_pair(&WRAP_COLOR(f));
  
+ 	{ long i;
+ 	  for (i = 0L; i < WRAP_QSTRLEN(f); i++)
+ 	      if (WRAP_QSTR(f,i))
+ 		fs_give((void **) &(WRAP_QSTR(f,i)));
+ 	  fs_give((void **)&WRAP_QSTRN(f));
+ 	}
+ 
  	fs_give((void **) &f->line);	/* free temp line buffer */
  	so_give(&WRAP_SPACES(f));
  	fs_give((void **) &f->opt);	/* free wrap widths struct */
***************
*** 10450,10456 ****
  {
      int j, i;
      COLOR_PAIR *col = NULL;
!     char *prefix = NULL, *last_prefix = NULL;
  
      if(ps_global->VAR_QUOTE_REPLACE_STRING){
  	get_pair(ps_global->VAR_QUOTE_REPLACE_STRING, &prefix, &last_prefix, 0, 0);
--- 10522,10529 ----
  {
      int j, i;
      COLOR_PAIR *col = NULL;
!     char *prefix = NULL, *last_prefix = NULL, *wrap_qstr = NULL;
!     int level = 0, oldj, len;
  
      if(ps_global->VAR_QUOTE_REPLACE_STRING){
  	get_pair(ps_global->VAR_QUOTE_REPLACE_STRING, &prefix, &last_prefix, 0, 0);
***************
*** 10459,10468 ****
  	    last_prefix = NULL;
  	}
      }
! 
!     for(j = 0; j < WRAP_FL_QD(f); j++){
  	if(WRAP_USE_CLR(f)){
! 	    if((j % 3) == 0
  	       && ps_global->VAR_QUOTE1_FORE_COLOR
  	       && ps_global->VAR_QUOTE1_BACK_COLOR
  	       && (col = new_color_pair(ps_global->VAR_QUOTE1_FORE_COLOR,
--- 10532,10553 ----
  	    last_prefix = NULL;
  	}
      }
!     
!     if(WRAP_CURLINE(f) < WRAP_QSTRLEN(f) && WRAP_QSTR(f, WRAP_CURLINE(f)))
!        wrap_qstr = cpystr(WRAP_QSTR(f, WRAP_CURLINE(f)));
!     len = wrap_qstr ? strlen(wrap_qstr) : 0;
! 
!     for (j = wrap_qstr && *wrap_qstr == ' ' ? 1 : 0;
! 		 j < len && isspace((unsigned char)wrap_qstr[j]); j++){
! 	GF_PUTC_GLO(f->next, wrap_qstr[j]);
!         f->n += ((wrap_qstr[j] == TAB) ? (~f->n & 0x07) + 1 : 1);
!     }
!     
!     for(; j < len && level < len; level++){
!         oldj = j;
!         j = next_level_quote(wrap_qstr, (char **)NULL, j, WRAP_FLOW(f));
  	if(WRAP_USE_CLR(f)){
! 	    if((level % 3) == 0
  	       && ps_global->VAR_QUOTE1_FORE_COLOR
  	       && ps_global->VAR_QUOTE1_BACK_COLOR
  	       && (col = new_color_pair(ps_global->VAR_QUOTE1_FORE_COLOR,
***************
*** 10470,10476 ****
  	       && pico_is_good_colorpair(col)){
                  GF_COLOR_PUTC(f, col);
              }
! 	    else if((j % 3) == 1
  		    && ps_global->VAR_QUOTE2_FORE_COLOR
  		    && ps_global->VAR_QUOTE2_BACK_COLOR
  		    && (col = new_color_pair(ps_global->VAR_QUOTE2_FORE_COLOR,
--- 10555,10561 ----
  	       && pico_is_good_colorpair(col)){
                  GF_COLOR_PUTC(f, col);
              }
! 	    else if((level % 3) == 1
  		    && ps_global->VAR_QUOTE2_FORE_COLOR
  		    && ps_global->VAR_QUOTE2_BACK_COLOR
  		    && (col = new_color_pair(ps_global->VAR_QUOTE2_FORE_COLOR,
***************
*** 10478,10484 ****
  		    && pico_is_good_colorpair(col)){
  	        GF_COLOR_PUTC(f, col);
              }
! 	    else if((j % 3) == 2
  		    && ps_global->VAR_QUOTE3_FORE_COLOR
  		    && ps_global->VAR_QUOTE3_BACK_COLOR
  		    && (col = new_color_pair(ps_global->VAR_QUOTE3_FORE_COLOR,
--- 10563,10569 ----
  		    && pico_is_good_colorpair(col)){
  	        GF_COLOR_PUTC(f, col);
              }
! 	    else if((level % 3) == 2
  		    && ps_global->VAR_QUOTE3_FORE_COLOR
  		    && ps_global->VAR_QUOTE3_BACK_COLOR
  		    && (col = new_color_pair(ps_global->VAR_QUOTE3_FORE_COLOR,
***************
*** 10492,10534 ****
  	    }
  	}
  
  	if(!WRAP_LV_FLD(f)){
  	    if(!WRAP_FOR_CMPS(f) && ps_global->VAR_QUOTE_REPLACE_STRING && prefix){
  		for(i = 0; prefix[i]; i++)
  		  GF_PUTC_GLO(f->next, prefix[i]);
! 		f->n += utf8_width(prefix);
! 	    }
! 	    else if(ps_global->VAR_REPLY_STRING
! 		    && (!strcmp(ps_global->VAR_REPLY_STRING, ">")
! 			|| !strcmp(ps_global->VAR_REPLY_STRING, "\">\""))){
! 		GF_PUTC_GLO(f->next, '>');
! 		f->n += 1;
  	    }
  	    else{
! 		GF_PUTC_GLO(f->next, '>');
! 		GF_PUTC_GLO(f->next, ' ');
! 		f->n += 2;
  	    }
  	}
  	else{
! 	    GF_PUTC_GLO(f->next, '>');
! 	    f->n += 1;
  	}
      }
      if(j && WRAP_LV_FLD(f)){
  	GF_PUTC_GLO(f->next, ' ');
  	f->n++;
      }
!     else if(j && last_prefix){
  	for(i = 0; last_prefix[i]; i++)
  	  GF_PUTC_GLO(f->next, last_prefix[i]);
! 	f->n += utf8_width(last_prefix);	
      }
  
      if(prefix)
        fs_give((void **)&prefix);
      if(last_prefix)
        fs_give((void **)&last_prefix);
  
      return 0;
  }
--- 10577,10636 ----
  	    }
  	}
  
+ 	if (j > 1 && wrap_qstr[j-1] == ' ')
+ 	   j -= 1; 
+ 
  	if(!WRAP_LV_FLD(f)){
  	    if(!WRAP_FOR_CMPS(f) && ps_global->VAR_QUOTE_REPLACE_STRING && prefix){
  		for(i = 0; prefix[i]; i++)
  		  GF_PUTC_GLO(f->next, prefix[i]);
! 		f->n += utf8_widthis(prefix);
  	    }
  	    else{
! 	      for (i = oldj; i < j; i++)   
! 		GF_PUTC_GLO(f->next, wrap_qstr[i]);
! 	      f->n += j - oldj;
  	    }
  	}
  	else{
! 	    for (i = oldj; i < j; i++)   
! 		GF_PUTC_GLO(f->next, wrap_qstr[i]);
! 	    f->n += j - oldj;
! 	}
! 	for (i = j; isspace((unsigned char)wrap_qstr[i]); i++);
! 	if(!wrap_qstr[i]){
! 	  f->n += i - j;
! 	  for (; j < i; j++)
! 		GF_PUTC_GLO(f->next, ' '); 
! 	}
!         else{
! 	   if((WRAP_LV_FLD(f)
! 		|| !ps_global->VAR_QUOTE_REPLACE_STRING || !prefix)
! 		|| !ps_global->VAR_REPLY_STRING
! 			|| (strcmp(ps_global->VAR_REPLY_STRING, ">")
! 			  && strcmp(ps_global->VAR_REPLY_STRING, "\">\""))){
! 		  GF_PUTC_GLO(f->next, ' ');
! 		  f->n += 1;
! 	   }
  	}
+ 	for (; isspace((unsigned char)wrap_qstr[j]); j++);
      }
      if(j && WRAP_LV_FLD(f)){
  	GF_PUTC_GLO(f->next, ' ');
  	f->n++;
      }
!     else if(j && !value_is_space(wrap_qstr) && last_prefix){
  	for(i = 0; last_prefix[i]; i++)
  	  GF_PUTC_GLO(f->next, last_prefix[i]);
! 	f->n += utf8_widthis(last_prefix);	
      }
  
      if(prefix)
        fs_give((void **)&prefix);
      if(last_prefix)
        fs_give((void **)&last_prefix);
+     if (wrap_qstr)
+       fs_give((void **)&wrap_qstr);  
  
      return 0;
  }
***************
*** 10560,10565 ****
--- 10662,10673 ----
      wrap->hdr_color    = (GFW_HDRCOLOR & flags) == GFW_HDRCOLOR;
      wrap->for_compose  = (GFW_FORCOMPOSE & flags) == GFW_FORCOMPOSE;
      wrap->handle_soft_hyphen = (GFW_SOFTHYPHEN & flags) == GFW_SOFTHYPHEN;
+     wrap->curlinenum   = 0L;
+     wrap->curqstrpos   = 0;
+     wrap->linenum      = 0L;
+     wrap->qstrlen      = 100L;
+     wrap->qstrln       = (char **) fs_get(100*sizeof(char *));
+     memset(wrap->qstrln, 0, 100*sizeof(char *));
  
      return((void *) wrap);
  }
***************
*** 11003,11009 ****
--- 11111,11325 ----
  			    } \
  			}
  
+ #define ADD_QUOTE_STRING(F) {						\
+ 	int len = tmp_20k_buf[0] ? strlen(tmp_20k_buf) + 1 : 0;		\
+ 	FILTER_S *fltr;							\
+ 									\
+ 	for(fltr = (F); fltr && fltr->f != gf_wrap; fltr = fltr->next); \
+ 	if (fltr){							\
+ 	   if (WRAP_LINENUM(fltr) >= WRAP_QSTRLEN(fltr)){		\
+ 	      fs_resize((void **)&WRAP_QSTRN(fltr),			\
+ 			(WRAP_QSTRLEN(fltr) + 100) * sizeof(char *));	\
+ 	      memset(WRAP_QSTRN(fltr)+WRAP_QSTRLEN(fltr), 0, 		\
+ 						100*sizeof(char*));	\
+ 	      WRAP_QSTRLEN(fltr) += 100L;				\
+ 	   }								\
+ 	   if (len){							\
+ 	      WRAP_QSTR(fltr, WRAP_LINENUM(fltr)) = 			\
+ 				(char *) fs_get(len*sizeof(char));	\
+ 	      WRAP_QSTR(fltr, WRAP_LINENUM(fltr)) = cpystr(tmp_20k_buf);\
+ 	   }								\
+ 	   WRAP_LINENUM(fltr)++;					\
+ 	}								\
+ }
+ 
+ int end_of_line(char *line)
+ {
+   int i;
+ 
+   for(i= 0; line && line[i]; i++){
+      if((line[i] == '\015' && line[i+1] == '\012') || line[i] == '\012')
+ 	break;
+   }
+   return i;
+ }
+ 
+ /* This macro is used in gf_quote_test. It receives a return code
+    from a filter. All filters that will print something must send
+    return code 0, except color_a_quote which must send return code
+    1
+  */
+ 
+ #define GF_ADD_QUOTED_LINE(F, line) \
+ { \
+     LT_INS_S *ins = NULL, *insp; \
+     int done; \
+     char *gline, *cline;\
+     unsigned char  ch;\
+     register char *cp;\
+     register int   l;\
+ 	\
+     for (gline = cline = line; gline && cline; ){\
+ 	if(cline = strchr(gline,'\012'))\
+ 	  *cline = '\0';\
+ 	done = (*((LINETEST_S *) (F)->opt)->f)((F)->n++, gline, &ins,\
+ 			   ((LINETEST_S *) (F)->opt)->local);\
+ 	if (done < 2){ \
+ 	   if(done == 1)\
+ 	     ADD_QUOTE_STRING((F));\
+ 	   for(insp = ins,  cp = gline; *cp ; ){\
+ 	       if(insp && cp == insp->where){\
+ 		if(insp->len > 0){ \
+ 	          for(l = 0; l < insp->len; l++){\
+ 			  ch =  (unsigned char) insp->text[l];\
+ 		     GF_PUTC((F)->next, ch);\
+ 	          }\
+ 	          insp = insp->next;\
+ 		  continue; \
+ 		} else if(insp->len < 0){ \
+ 		  cp -= insp->len; \
+ 		  insp = insp->next; \
+ 		  continue; \
+ 		} \
+ 	       }\
+ 	       GF_PUTC((F)->next, *cp);\
+ 	       cp++;\
+ 	   }\
+ 	   while(insp){\
+ 	       for(l = 0; l < insp->len; l++){\
+ 	          ch = (unsigned char) insp->text[l];\
+ 	          GF_PUTC((F)->next, ch);\
+ 	       }\
+ 	       insp = insp->next;\
+ 	   }\
+ 	   gf_line_test_free_ins(&ins);\
+ 	   if(cline){ \
+ 	     *cline = '\012';\
+ 	     gline += cline - gline + 1;\
+ 	   }\
+ 	   GF_PUTC((F)->next, '\015');\
+ 	   GF_PUTC((F)->next, '\012');\
+ 	}\
+    }\
+ }
+ /* test second line of old line first */
+ #define SECOND_LINE_QUOTE_TEST(line, F) \
+ {\
+ 	*p = '\0';\
+ 	i = end_of_line((F)->oldline); \
+ 	if (((F)->oldline)[i]){\
+ 	   i += (((F)->oldline)[i] == '\015') ? 2 : 1;\
+ 	   line = (F)->oldline + i;\
+ 	   i = end_of_line(line); \
+ 	   if(line[i])\
+ 	     line[i] = '\0'; \
+ 	}\
+ 	for (i = 0; ((F)->line) \
+ 		&& (i < LINE_TEST_BLOCK) \
+ 		&& (i < SIZEOF_20KBUF)\
+ 		&& ((F)->line)[i] \
+ 		&& (((F)->line)[i] != '\015')\
+ 		&& (((F)->line)[i] != '\012')\
+ 		&& (tmp_20k_buf[i] = ((F)->line)[i]); i++);\
+ 	tmp_20k_buf[i] = '\0';\
+ 	GF_ADD_QUOTED_LINE((F), line);\
+ }
+ 
+ #define FIRST_LINE_QUOTE_TEST(line, F)\
+ {\
+ 	*p = '\0';\
+ 	line = (F)->line;\
+ 	if ((F)->oldline)\
+ 	   fs_give((void **)&(F)->oldline);\
+ 	(F)->oldline = cpystr(line);\
+ 	i = end_of_line(line); \
+ 	if (line[i]){ \
+ 	   j = (line[i] == '\015') ? 2 : 1;\
+ 	   line[i] = '\0'; \
+ 	   i += j; \
+ 	}\
+ 	for (j = 0; ((F)->line) \
+ 		&& ((i + j) < LINE_TEST_BLOCK) \
+ 		&& (j < SIZEOF_20KBUF) \
+ 		&& ((F)->line)[i + j] \
+ 		&& (((F)->line)[i + j] != '\015')\
+ 		&& (((F)->line)[i + j] != '\012')\
+ 		&& (tmp_20k_buf[j] = ((F)->line)[i + j]); j++);\
+ 	tmp_20k_buf[j] = '\0';\
+ 	GF_ADD_QUOTED_LINE((F), line);\
+ }
+ 
+ 
+ void
+ gf_quote_test(f, flg)
+     FILTER_S *f;
+     int	      flg;
+ {
+     register char *p = f->linep;
+     register char *eobuf = GF_LINE_TEST_EOB(f);
+     char *line = NULL; 
+     int i, j;
+     GF_INIT(f, f->next);
+ 
+     if(flg == GF_DATA){
+ 	register unsigned char c;
+ 	register int state = f->f1;
+ 
+ 	while(GF_GETC(f, c)){
+ 
+ 	    GF_LINE_TEST_ADD(f, c);
+ 	    if(c == '\012')
+ 	      state++;
+ 	    if(state == 2){		/* two full lines read */
+ 		state = 0;
+ 
+ 		/* first process the second line of an old line */
+ 		if (f->oldline && f->oldline[0])
+ 		    SECOND_LINE_QUOTE_TEST(line, f);
+ 
+ 		/* now we process the first line */
+ 		FIRST_LINE_QUOTE_TEST(line, f);
+ 
+ 		p = f->line;
+ 	    }
+ 	}
+ 
+ 	f->f1 = state;
+ 	GF_END(f, f->next);
+     }
+     else if(flg == GF_EOD){
+         /* first process the second line of an old line */
+ 	if (f->oldline && f->oldline[0])
+ 	    SECOND_LINE_QUOTE_TEST(line, f);
+ 
+ 	/* now we process the first line */
+ 	FIRST_LINE_QUOTE_TEST(line, f);
+ 
+ 	/* We are out of data. In this case we have processed the second
+ 	 * line of an oldline, then the first line of a line, but we need
+ 	 * to process the second line of the given line. We do this by
+ 	 * processing it now!.
+ 	 */
+ 	if (line[i]){
+ 	   tmp_20k_buf[0] = '\0';	/* No next line */
+ 	   GF_ADD_QUOTED_LINE(f, line+i);
+ 	}
+ 
+ 	fs_give((void **) &f->oldline); /* free old line buffer */
+ 	fs_give((void **) &f->line);	/* free line buffer */
+ 	fs_give((void **) &f->opt);	/* free test struct */
+ 	GF_FLUSH(f->next);
+ 	(*f->next->f)(f->next, GF_EOD);
+     }
+     else if(flg == GF_RESET){
+ 	f->f1 = 0;			/* state */
+ 	f->n  = 0L;			/* line number */
+ 	f->f2 = LINE_TEST_BLOCK;	/* size of alloc'd line */
+ 	f->line = p = (char *) fs_get(f->f2 * sizeof(char));
+     }
  
+     f->linep = p;
+ }
  
  /*
   * this simple filter accumulates characters until a newline, offers it
diff -rc alpine-2.11/pith/filter.h alpine-2.11.I.USE/pith/filter.h
*** alpine-2.11/pith/filter.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/filter.h	2013-12-01 16:36:01.000000000 -0700
***************
*** 216,221 ****
--- 216,222 ----
  void	   *gf_prepend_editorial_opt(prepedtest_t, char *);
  void	    gf_nvtnl_local(FILTER_S *, int);
  void	    gf_local_nvtnl(FILTER_S *, int);
+ void	    gf_quote_test(FILTER_S *, int);
  void	   *gf_url_hilite_opt(URL_HILITE_S *, HANDLE_S **, int);
  
  
diff -rc alpine-2.11/pith/filttype.h alpine-2.11.I.USE/pith/filttype.h
*** alpine-2.11/pith/filttype.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/filttype.h	2013-12-01 16:36:01.000000000 -0700
***************
*** 35,40 ****
--- 35,42 ----
      unsigned char t;		/* temporary char                        */
      char     *line;		/* place for temporary storage           */
      char     *linep;		/* pointer into storage space            */
+     char     *oldline;		/* the previous line to "line"		 */
+     char     *oldlinep;		/* the previous line to "line"		 */
      void     *opt;		/* optional per instance data		 */
      void     *data;		/* misc internal data pointer		 */
      unsigned char queue[1 + GF_MAXBUF];
diff -rc alpine-2.11/pith/flag.c alpine-2.11.I.USE/pith/flag.c
*** alpine-2.11/pith/flag.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/flag.c	2013-12-01 16:33:57.000000000 -0700
***************
*** 594,607 ****
  
  	was_invisible = (pelt->hidden || pelt->colhid) ? 1 : 0;
  
  	if((chk_thrd_cnt = ((msgs->visible_threads >= 0L)
  	   && THRD_INDX_ENABLED() && (f & MN_HIDE) && (pelt->hidden != v))) != 0){
  	    thrd = fetch_thread(stream, rawno);
  	    if(thrd && thrd->top){
! 		if(thrd->top == thrd->rawno)
  		  topthrd = thrd;
  		else
! 		  topthrd = fetch_thread(stream, thrd->top);
  	    }
  
  	    if(topthrd){
--- 594,609 ----
  
  	was_invisible = (pelt->hidden || pelt->colhid) ? 1 : 0;
  
+ 	thrd = fetch_thread(stream, rawno);
+ 
  	if((chk_thrd_cnt = ((msgs->visible_threads >= 0L)
  	   && THRD_INDX_ENABLED() && (f & MN_HIDE) && (pelt->hidden != v))) != 0){
  	    thrd = fetch_thread(stream, rawno);
  	    if(thrd && thrd->top){
! 		if(top_thread(stream, thrd->top) == thrd->rawno)
  		  topthrd = thrd;
  		else
! 		  topthrd = fetch_thread(stream, top_thread(stream, thrd->top));
  	    }
  
  	    if(topthrd){
diff -rc alpine-2.11/pith/imap.c alpine-2.11.I.USE/pith/imap.c
*** alpine-2.11/pith/imap.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/imap.c	2013-12-01 16:38:36.000000000 -0700
***************
*** 967,974 ****
--- 967,984 ----
  	 && !strcmp(user, l->user)
  	 && l->altflag == altflag){
  	  if(passwd){
+ 	    if(l->invalidpwd == 0){
  	      strncpy(passwd, l->passwd, NETMAXPASSWD);
  	      passwd[NETMAXPASSWD-1] = '\0';
+ 	    }
+ 	    else{
+ 	      q_status_message(SM_ORDER | SM_DING, 3, 4,
+ 			 "Failed to login!. Re-enter password.");
+ 	      dprint((9, "imap_get_passwd: reseting password due to login failure.\n"));
+ 	      dprint((10, "imap_get_passwd: Old passwd=\"%s\"\n",
+ 		      passwd ? passwd : "?"));
+ 	      return FALSE;
+ 	    }
  	  }
  	  dprint((9, "imap_get_passwd: match\n"));
  	  dprint((10, "imap_get_passwd: trying passwd=\"%s\"\n",
***************
*** 1016,1021 ****
--- 1026,1032 ----
      (*l)->altflag = altflag;
      (*l)->ok_novalidate = ok_novalidate;
      (*l)->warned = warned;
+     (*l)->invalidpwd = 0;	/* assume correct password for now */
  
      if(!(*l)->user)
        (*l)->user = cpystr(user);
diff -rc alpine-2.11/pith/imap.h alpine-2.11.I.USE/pith/imap.h
*** alpine-2.11/pith/imap.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/imap.h	2013-12-01 16:38:36.000000000 -0700
***************
*** 35,40 ****
--- 35,41 ----
      unsigned	    altflag:1;
      unsigned	    ok_novalidate:1;
      unsigned	    warned:1;
+     unsigned	    invalidpwd:1;	/* password is invalid, assume valid */
      STRLIST_S	   *hosts;
      struct _mmlogin_s *next;
  } MMLOGIN_S;
diff -rc alpine-2.11/pith/indxtype.h alpine-2.11.I.USE/pith/indxtype.h
*** alpine-2.11/pith/indxtype.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/indxtype.h	2013-12-01 16:34:54.000000000 -0700
***************
*** 76,87 ****
  	      iKey, iKeyInit,
  	      iPrefDate, iPrefTime, iPrefDateTime,
  	      iCurPrefDate, iCurPrefTime, iCurPrefDateTime,
! 	      iSize, iSizeComma, iSizeNarrow, iDescripSize,
  	      iNewsAndTo, iToAndNews, iNewsAndRecips, iRecipsAndNews,
  	      iFromTo, iFromToNotNews, iFrom, iTo, iSender, iCc, iNews, iRecips,
  	      iCurNews, iArrow,
  	      iMailbox, iAddress, iInit, iCursorPos,
  	      iDay2Digit, iMon2Digit, iYear2Digit,
  	      iSTime, iKSize,
  	      iRoleNick, iNewLine,
  	      iHeader, iText,
--- 76,90 ----
  	      iKey, iKeyInit,
  	      iPrefDate, iPrefTime, iPrefDateTime,
  	      iCurPrefDate, iCurPrefTime, iCurPrefDateTime,
! 	      iSize, iSizeComma, iSizeNarrow, iDescripSize,  iSizeThread,
  	      iNewsAndTo, iToAndNews, iNewsAndRecips, iRecipsAndNews,
  	      iFromTo, iFromToNotNews, iFrom, iTo, iSender, iCc, iNews, iRecips,
  	      iCurNews, iArrow,
  	      iMailbox, iAddress, iInit, iCursorPos,
  	      iDay2Digit, iMon2Digit, iYear2Digit,
+ 	      iFolder, iFlag, iCollection, iRole, iProcid, iScreen, iPkey,
+ 	      iNick, iAddressTo, iAddressCc, iAddressRecip, iBcc, iLcc,
+ 	      iFfrom, iFadd,
  	      iSTime, iKSize,
  	      iRoleNick, iNewLine,
  	      iHeader, iText,
***************
*** 103,117 ****
  
  
  /* these are flags for the what_for field in INDEX_PARSE_T */
! #define FOR_NOTHING	0x00
! #define FOR_INDEX	0x01
! #define FOR_REPLY_INTRO	0x02
! #define FOR_TEMPLATE	0x04		/* or for signature */
! #define FOR_FILT	0x08
! #define DELIM_USCORE	0x10
! #define DELIM_PAREN	0x20
! #define DELIM_COLON	0x40
! 
  
  #define DEFAULT_REPLY_INTRO "default"
  
--- 106,131 ----
  
  
  /* these are flags for the what_for field in INDEX_PARSE_T */
! #define FOR_NOTHING	0x00000
! #define FOR_INDEX	0x00001
! #define FOR_REPLY_INTRO	0x00002
! #define FOR_TEMPLATE	0x00004  /* or for signature */
! #define FOR_FILT	0x00008
! #define DELIM_USCORE	0x00010
! #define DELIM_PAREN	0x00020
! #define DELIM_COLON	0x00040
! #define FOR_FOLDER	0x00080  /* for rules */
! #define FOR_RULE	0x00100  /* for rules */
! #define FOR_TRIM	0x00200  /* for rules */
! #define FOR_RESUB	0x00400  /* for rules */
! #define FOR_REPLACE	0x00800  /* for rules */
! #define FOR_SORT	0x01000  /* for rules */
! #define FOR_FLAG	0x02000  /* for rules */
! #define FOR_COMPOSE	0x04000  /* for rules */
! #define FOR_THREAD	0x08000  /* for rules */
! #define FOR_STARTUP	0x10000  /* for rules */
! #define FOR_KEY		0x20000	 /* for rules */
! #define FOR_SAVE	0x40000  /* for rules */
  
  #define DEFAULT_REPLY_INTRO "default"
  
diff -rc alpine-2.11/pith/init.c alpine-2.11.I.USE/pith/init.c
*** alpine-2.11/pith/init.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/init.c	2013-12-01 16:34:08.000000000 -0700
***************
*** 408,413 ****
--- 408,416 ----
             && stricmp(filename, folder_base)){
  #else
          if(strncmp(filename, folder_base, folder_base_len) == 0
+ #ifndef _WINDOWS
+ 	   && filename[folder_base_len] != list_cntxt->dir->delim
+ #endif
             && strcmp(filename, folder_base)){
  #endif
  #endif
diff -rc alpine-2.11/pith/mailcap.c alpine-2.11.I.USE/pith/mailcap.c
*** alpine-2.11/pith/mailcap.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/mailcap.c	2013-12-01 16:40:07.000000000 -0700
***************
*** 53,58 ****
--- 53,59 ----
      int                needsterminal;
      char              *contenttype;
      char              *command;
+     char	      *nametemplate;
      char              *testcommand;
      char              *label;           /* unused */
      char              *printcommand;    /* unused */
***************
*** 213,218 ****
--- 214,222 ----
  	    if(mc->printcommand)
  	      dprint((11, "   printcommand: %s",
  		     mc->printcommand ? mc->printcommand : "?"));
+ 	    if(mc->nametemplate)
+ 	      dprint((11, "   nametemplate: %s",
+ 		     mc->nametemplate ? mc->nametemplate : "?"));
  	    dprint((11, "   needsterminal %d\n", mc->needsterminal));
  	}
      }
***************
*** 488,493 ****
--- 492,502 ----
  	    dprint((9, "mailcap: printcommand=%s\n",
  		       mc->printcommand ? mc->printcommand : "?"));
  	}
+ 	else if(arg && !strucmp(*tokens, "nametemplate")){
+ 	    mc->nametemplate = arg;
+ 	    dprint((9, "mailcap: nametemplate=%s\n",
+ 		   arg ? arg : "?"));
+ 	}
  	else if(arg && !strucmp(*tokens, "compose")){
  	    /* not used */
  	    dprint((9, "mailcap: not using compose=%s\n",
***************
*** 974,976 ****
--- 983,1042 ----
      mail_free_stringlist(&MailcapData.raw);
      mc_free_entry(&MailcapData.head);
  }
+ 
+ char *
+ mc_template(char *tmp_file, BODY *body, int chk_extension)
+ {
+     MailcapEntry *mc;
+     int  quoted = 0;
+     char *s, *to, *namefile = NULL;
+ 
+     mc = mc_get_command(body->type, body->subtype, body, chk_extension, NULL);
+     if(!mc || !mc->nametemplate || !tmp_file)
+       return tmp_file;
+ 
+     /* remove extension if requested for a specific extension */
+     if(mc->nametemplate && tmp_file && (s = strrchr(tmp_file, '.')) != NULL
+         && strchr(s, C_FILESEP) == NULL)
+         *s = '\0';
+ 
+     to = tmp_20k_buf;
+     if((s = strrchr(tmp_file, C_FILESEP)) != NULL){
+ 	*s++ = '\0';
+ 	sstrncpy(&to, tmp_file, SIZEOF_20KBUF-(to-tmp_20k_buf));
+ 	if(to-tmp_20k_buf < SIZEOF_20KBUF)
+ 	   *to++ = C_FILESEP;
+ 	namefile = s;
+     }
+ 
+     for(s = mc->nametemplate; *s; s++)
+       if(quoted){
+ 	quoted = 0;
+ 	switch(*s){
+ 	    case '%':
+ 		if(to-tmp_20k_buf < SIZEOF_20KBUF)
+ 		   *to++ = '%';
+ 		break;
+ 
+ 	   case 's':
+ 		sstrncpy(&to, namefile ? namefile : tmp_file, SIZEOF_20KBUF-(to-tmp_20k_buf));
+                 break;
+ 
+ 	   default:
+ 		dprint((9,
+ 	"Ignoring unercognized format code in nametemplate: %%%c\n", *s ));
+ 		break;
+ 	}
+       }
+       else if(*s == '%')
+ 	quoted = 1;
+       else if(to-tmp_20k_buf < SIZEOF_20KBUF)
+ 	*to++ = *s;
+ 
+     *to++ = '\0';
+ 
+     fs_give((void **)&tmp_file);
+     tmp_file = cpystr(tmp_20k_buf);
+     return tmp_file;
+ }
+ 
diff -rc alpine-2.11/pith/mailcap.h alpine-2.11.I.USE/pith/mailcap.h
*** alpine-2.11/pith/mailcap.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/mailcap.h	2013-12-01 16:40:07.000000000 -0700
***************
*** 29,34 ****
--- 29,35 ----
  int	    mailcap_can_display(int, char *, BODY *, int);
  MCAP_CMD_S *mailcap_build_command(int, char *, BODY *, char *, int *, int);
  void	    mailcap_free(void);
+ char 	   *mc_template(char *, BODY *, int);
  
  /* currently mandatory to implement stubs */
  
diff -rc alpine-2.11/pith/mailcmd.c alpine-2.11.I.USE/pith/mailcmd.c
*** alpine-2.11/pith/mailcmd.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/mailcmd.c	2013-12-01 16:34:54.000000000 -0700
***************
*** 39,44 ****
--- 39,45 ----
  #include "../pith/ablookup.h"
  #include "../pith/search.h"
  #include "../pith/charconv/utf8.h"
+ #include "../pith/rules.h"
  
  #ifdef _WINDOWS
  #include "../pico/osdep/mswin.h"
***************
*** 665,670 ****
--- 666,672 ----
  	strncpy(ps_global->cur_folder, p, sizeof(ps_global->cur_folder)-1);
  	ps_global->cur_folder[sizeof(ps_global->cur_folder)-1] = '\0';
  	ps_global->context_current = ps_global->context_list;
+ 	setup_threading_index_style();
  	reset_index_format();
  	clear_index_cache(ps_global->mail_stream, 0);
          /* MUST sort before restoring msgno! */
***************
*** 990,995 ****
--- 992,998 ----
  
      clear_index_cache(ps_global->mail_stream, 0);
      reset_index_format();
+     setup_threading_index_style();
  
      /*
       * Start news reading with messages the user's marked deleted
***************
*** 1113,1119 ****
  
      if(!cur_already_set && mn_get_total(ps_global->msgmap) > 0L){
  
! 	perfolder_startup_rule = reset_startup_rule(ps_global->mail_stream);
  
  	if(ps_global->start_entry > 0){
  	    mn_set_cur(ps_global->msgmap, mn_get_revsort(ps_global->msgmap)
--- 1116,1125 ----
  
      if(!cur_already_set && mn_get_total(ps_global->msgmap) > 0L){
  
! 	perfolder_startup_rule = get_perfolder_startup_rule(ps_global->mail_stream,
!                                        V_STARTUP_RULES, newfolder);
! 
! 	reset_startup_rule(ps_global->mail_stream);
  
  	if(ps_global->start_entry > 0){
  	    mn_set_cur(ps_global->msgmap, mn_get_revsort(ps_global->msgmap)
***************
*** 1135,1258 ****
  	    else
  	      use_this_startup_rule = ps_global->inc_startup_rule;
  
! 	    switch(use_this_startup_rule){
! 	      /*
! 	       * For news in incoming collection we're doing the same thing
! 	       * for first-unseen and first-recent. In both those cases you
! 	       * get first-unseen if FAKE_NEW is off and first-recent if
! 	       * FAKE_NEW is on. If FAKE_NEW is on, first unseen is the
! 	       * same as first recent because all recent msgs are unseen
! 	       * and all unrecent msgs are seen (see pine_mail_open).
! 	       */
! 	      case IS_FIRST_UNSEEN:
! first_unseen:
! 		mn_set_cur(ps_global->msgmap,
! 			(sp_first_unseen(m)
! 			 && mn_get_sort(ps_global->msgmap) == SortArrival
! 			 && !mn_get_revsort(ps_global->msgmap)
! 			 && !get_lflag(ps_global->mail_stream, NULL,
! 				       sp_first_unseen(m), MN_EXLD)
! 			 && (n = mn_raw2m(ps_global->msgmap, 
! 					  sp_first_unseen(m))))
! 			   ? n
! 			   : first_sorted_flagged(F_UNSEEN | F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		break;
! 
! 	      case IS_FIRST_RECENT:
! first_recent:
! 		/*
! 		 * We could really use recent for news but this is the way
! 		 * it has always worked, so we'll leave it. That is, if
! 		 * the FAKE_NEW feature is on, recent and unseen are
! 		 * equivalent, so it doesn't matter. If the feature isn't
! 		 * on, all the undeleted messages are unseen and we start
! 		 * at the first one. User controls with the FAKE_NEW feature.
! 		 */
! 		if(IS_NEWS(ps_global->mail_stream)){
! 		    mn_set_cur(ps_global->msgmap,
! 			       first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID));
! 		}
! 		else{
! 		    mn_set_cur(ps_global->msgmap,
! 			       first_sorted_flagged(F_RECENT | F_UNSEEN
! 						    | F_UNDEL,
! 						    m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		}
! 		break;
! 
! 	      case IS_FIRST_IMPORTANT:
! 		mn_set_cur(ps_global->msgmap,
! 			   first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		break;
! 
! 	      case IS_FIRST_IMPORTANT_OR_UNSEEN:
! 
! 		if(IS_NEWS(ps_global->mail_stream))
! 		  goto first_unseen;
! 
! 		{
! 		    MsgNo flagged, first_unseen;
! 
! 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    first_unseen = (sp_first_unseen(m)
! 			     && mn_get_sort(ps_global->msgmap) == SortArrival
! 			     && !mn_get_revsort(ps_global->msgmap)
! 			     && !get_lflag(ps_global->mail_stream, NULL,
! 					   sp_first_unseen(m), MN_EXLD)
! 			     && (n = mn_raw2m(ps_global->msgmap, 
! 					      sp_first_unseen(m))))
! 				? n
! 				: first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    mn_set_cur(ps_global->msgmap,
! 			  (MsgNo) MIN((int) flagged, (int) first_unseen));
! 
! 		}
! 
! 		break;
! 
! 	      case IS_FIRST_IMPORTANT_OR_RECENT:
! 
! 		if(IS_NEWS(ps_global->mail_stream))
! 		  goto first_recent;
! 
! 		{
! 		    MsgNo flagged, first_recent;
! 
! 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    first_recent = first_sorted_flagged(F_RECENT | F_UNSEEN
! 							| F_UNDEL,
! 							m, pc,
! 					       THREADING() ? 0 : FSF_SKIP_CHID);
! 		    mn_set_cur(ps_global->msgmap,
! 			      (MsgNo) MIN((int) flagged, (int) first_recent));
! 		}
! 
! 		break;
! 
! 	      case IS_FIRST:
! 		mn_set_cur(ps_global->msgmap,
! 			   first_sorted_flagged(F_UNDEL, m, pc,
! 					      THREADING() ? 0 : FSF_SKIP_CHID));
! 		break;
! 
! 	      case IS_LAST:
! 		mn_set_cur(ps_global->msgmap,
! 			   first_sorted_flagged(F_UNDEL, m, pc,
! 			         FSF_LAST | (THREADING() ? 0 : FSF_SKIP_CHID)));
! 		break;
! 
! 	      default:
! 		panic("Unexpected incoming startup case");
! 		break;
! 
! 	    }
  	}
  	else if(IS_NEWS(ps_global->mail_stream)){
  	    /*
--- 1141,1147 ----
  	    else
  	      use_this_startup_rule = ps_global->inc_startup_rule;
  
! 	    find_startup_position(use_this_startup_rule, m, pc);
  	}
  	else if(IS_NEWS(ps_global->mail_stream)){
  	    /*
***************
*** 1430,1438 ****
  	    /* Save read messages? */
  	    if(VAR_READ_MESSAGE_FOLDER && VAR_READ_MESSAGE_FOLDER[0]
  	       && sp_flagged(stream, SP_INBOX)
! 	       && (seen_not_del = count_flagged(stream, F_SEEN | F_UNDEL))){
  
  		if(F_ON(F_AUTO_READ_MSGS,ps_global)
  		   || (pith_opt_read_msg_prompt
  		       && (*pith_opt_read_msg_prompt)(seen_not_del, VAR_READ_MESSAGE_FOLDER)))
  		  /* move inbox's read messages */
--- 1319,1329 ----
  	    /* Save read messages? */
  	    if(VAR_READ_MESSAGE_FOLDER && VAR_READ_MESSAGE_FOLDER[0]
  	       && sp_flagged(stream, SP_INBOX)
! 	       && (F_ON(F_AUTO_READ_MSGS_RULES, ps_global) ||
! 		  (seen_not_del = count_flagged(stream, F_SEEN | F_UNDEL)))){
  
  		if(F_ON(F_AUTO_READ_MSGS,ps_global)
+ 		   || F_ON(F_AUTO_READ_MSGS_RULES, ps_global)
  		   || (pith_opt_read_msg_prompt
  		       && (*pith_opt_read_msg_prompt)(seen_not_del, VAR_READ_MESSAGE_FOLDER)))
  		  /* move inbox's read messages */
***************
*** 1703,1708 ****
--- 1594,1602 ----
      char	  *bufp = NULL;
      MESSAGECACHE *mc;
  
+     if (F_ON(F_AUTO_READ_MSGS_RULES, ps_global))
+      return move_read_msgs_using_rules(stream, dstfldr, buf);
+ 
      if(!is_absolute_path(dstfldr)
         && !(save_context = default_save_context(ps_global->context_list)))
        save_context = ps_global->context_list;
***************
*** 1742,1749 ****
  	snprintf(buf, buflen, "Moving %s read message%s to \"%s\"",
  		comatose(searched), plural(searched), dstfldr);
  	we_cancel = busy_cue(buf, NULL, 0);
! 	if(save(ps_global, stream, save_context, dstfldr, msgmap,
! 		SV_DELETE | SV_FIX_DELS | SV_INBOXWOCNTXT) == searched)
  	  strncpy(bufp = buf + 1, "Moved", MIN(5,buflen)); /* change Moving to Moved */
  
  	buf[buflen-1] = '\0';
--- 1636,1644 ----
  	snprintf(buf, buflen, "Moving %s read message%s to \"%s\"",
  		comatose(searched), plural(searched), dstfldr);
  	we_cancel = busy_cue(buf, NULL, 0);
! 	ps_global->exiting = 1;
! 	if((save(ps_global, stream, save_context, dstfldr, msgmap,
! 		SV_DELETE | SV_FIX_DELS | SV_INBOXWOCNTXT) == searched))
  	  strncpy(bufp = buf + 1, "Moved", MIN(5,buflen)); /* change Moving to Moved */
  
  	buf[buflen-1] = '\0';
***************
*** 1781,1787 ****
         && ((context_isambig(folder)
  	    && folder_is_nick(folder, FOLDERS(context), 0))
  	   || folder_index(folder, context, FI_FOLDER) > 0)
!        && (seen_undel = count_flagged(stream, F_SEEN | F_UNDEL))){
  
  	for(; f && *archive; archive++){
  	    char *p;
--- 1676,1684 ----
         && ((context_isambig(folder)
  	    && folder_is_nick(folder, FOLDERS(context), 0))
  	   || folder_index(folder, context, FI_FOLDER) > 0)
!        && ((seen_undel = count_flagged(stream, F_SEEN | F_UNDEL))
! 	   || (F_ON(F_AUTO_READ_MSGS,ps_global) &&
! 	       F_ON(F_AUTO_READ_MSGS_RULES, ps_global)))){
  
  	for(; f && *archive; archive++){
  	    char *p;
***************
*** 2739,2741 ****
--- 2636,2930 ----
  
      return(*target ? target : NULL);
  }
+ 
+ char *
+ move_read_msgs_using_rules(MAILSTREAM *stream, char *dstfldr, char *buf)
+ {
+     CONTEXT_S  *save_context = NULL;
+     char **folder_to_save = NULL;
+     int  num, we_cancel;
+     long i, j, success;
+     MSGNO_S *msgmap = NULL;
+     unsigned long nmsgs = 0L, stream_nmsgs;
+ 
+     if(!is_absolute_path(dstfldr)
+        && !(save_context = default_save_context(ps_global->context_list)))
+        save_context = ps_global->context_list;
+ 
+     folder_to_save = (char **)fs_get((stream->nmsgs + 1)*sizeof(char *));
+     folder_to_save[0] = NULL;
+     mn_init(&msgmap, stream->nmsgs);
+     stream_nmsgs = stream->nmsgs;
+     for (i = 1L; i <= stream_nmsgs ; i++){
+         set_lflag(stream, msgmap, i, MN_SLCT, 0);
+         folder_to_save[i] = get_lflag(stream, NULL, i, MN_EXLD)
+                             ? NULL : get_folder_to_save(stream, i, dstfldr);
+     }
+     for (i = 1L; i <= stream_nmsgs; i++){
+         num = 0;
+         if (folder_to_save[i]){
+            mn_init(&msgmap, stream_nmsgs);
+            for (j = i; j <= stream_nmsgs ; j++){
+                 if (folder_to_save[j]){
+                    if (!strcmp(folder_to_save[i], folder_to_save[j])){
+                         set_lflag(stream, msgmap, j, MN_SLCT, 1);
+                         num++;
+                         if (j != i)
+                            fs_give((void **)&folder_to_save[j]);
+                    }
+                  }
+            }
+            pseudo_selected(stream, msgmap);
+            sprintf(buf, "Moving %s read message%s to \"%.45s\"",
+                       comatose(num), plural(num), folder_to_save[i]);
+            we_cancel = busy_cue(buf, NULL, 1);
+            ps_global->exiting = 1;
+            if(success = save(ps_global, stream,save_context, folder_to_save[i],
+                                 msgmap, SV_DELETE | SV_FIX_DELS))
+            nmsgs += success;
+            if(we_cancel)
+              cancel_busy_cue(success ? 0 : -1);
+            for (j = i; j <= stream_nmsgs ; j++)
+                set_lflag(stream, msgmap, j, MN_SLCT, 0);
+            fs_give((void **)&folder_to_save[i]);
+            mn_give(&msgmap);
+         }
+     }
+     ps_global->exiting = 0; /* useful if we call from aggregate operations */
+     sprintf(buf, "Moved automatically %s message%s",
+                 comatose(nmsgs), plural(nmsgs));
+     if (folder_to_save)
+         fs_give((void **)folder_to_save);
+     rule_curpos = 0L;
+     return buf;
+ }
+ 
+ char *
+ get_folder_to_save(MAILSTREAM *stream, long i, char *dstfldr)
+ {
+     MESSAGECACHE *mc = NULL;
+     RULE_RESULT *rule;
+     MSGNO_S *msgmap = NULL;
+     char *folder_to_save = NULL, *save_folder = NULL;
+     int n;
+     long msgno;
+ 
+     /* The plan is as follows: Select each message of the folder. We
+      * need to set the cursor correctly so that iFlag gets the value
+      * correctly too, otherwise iFlag will get the value of the position
+      * of the cursor. After that we need to look for a rule that applies
+      * to the message and get the saving folder. If we get a saving folder,
+      * and we used the _FLAG_ token, use that folder, if no
+      * _FLAG_ token was used, move only if seen and not deleted, to the
+      * folder specified in the saving rule. If we did not get a saving
+      * folder from the rule, just save in the default folder.
+      */
+     mn_init(&msgmap, stream->nmsgs);
+     rule_curpos = i;
+     msgno = mn_m2raw(msgmap, i);
+     if (msgno > 0L){
+         mc = mail_elt(stream, msgno);
+         rule = (RULE_RESULT *)
+             get_result_rule(V_SAVE_RULES, FOR_SAVE, mc->private.msg.env);
+         if (rule){
+             folder_to_save = cpystr(rule->result);
+             n = rule->number;
+             fs_give((void **)&rule->result);
+             fs_give((void **)&rule);
+         }
+     }
+ 
+     if (folder_to_save && *folder_to_save){
+         RULELIST *list = get_rulelist_from_code(V_SAVE_RULES,
+                                                 ps_global->rule_list);
+         RULE_S *prule = get_rule(list, n);
+         if (condition_contains_token(prule->condition, "_FLAG_")
+              || (mc->valid && mc->seen && !mc->deleted)
+              || (!mc->valid && mc->searched))
+              save_folder = cpystr(folder_to_save);
+           else
+              save_folder = NULL;
+     }
+     else
+        if (!mc || (mc->seen && !mc->deleted))
+           save_folder = cpystr(dstfldr);
+     mn_give(&msgmap);
+     rule_curpos = 0L;
+     return save_folder;
+ }
+ 
+ unsigned long
+ rules_cursor_pos(MAILSTREAM *stream)
+ {
+   MSGNO_S *msgmap = sp_msgmap(stream);
+   return rule_curpos != 0L ? rule_curpos : mn_m2raw(msgmap,mn_get_cur(msgmap));
+ }
+ 
+ void
+ setup_threading_index_style(void)
+ {
+   RULE_RESULT *rule;
+   NAMEVAL_S *v;
+   int i;
+ 
+   rule = get_result_rule(V_THREAD_INDEX_STYLE_RULES, FOR_THREAD, NULL);
+   if (rule || ps_global->VAR_THREAD_INDEX_STYLE){
+      for(i = 0; v = thread_index_styles(i); i++)
+         if(!strucmp(rule ? rule->result : ps_global->VAR_THREAD_INDEX_STYLE,
+                     rule ? (v ? v->name : "" ) : S_OR_L(v))){
+               ps_global->thread_index_style = v->value;
+               break;
+         }
+      if (rule){
+         if (rule->result)
+            fs_give((void **)&rule->result);
+         fs_give((void **)&rule);
+      }
+   }
+ }
+ 
+ unsigned
+ get_perfolder_startup_rule(MAILSTREAM *stream, int rule_type, char *folder)
+ {
+     unsigned    startup_rule;
+     char        *rule_result;
+ 
+     startup_rule =  reset_startup_rule(stream);
+     rule_result = get_rule_result(FOR_STARTUP, folder, rule_type);
+     if (rule_result && *rule_result){
+        int        i;
+        NAMEVAL_S *v;
+ 
+        for(i = 0; v = incoming_startup_rules(i); i++)
+           if(!strucmp(rule_result, v->name)){
+              startup_rule = v->value;
+              break;
+           }
+        fs_give((void **)&rule_result);
+      }
+    return startup_rule;
+ }
+ 
+ void
+ find_startup_position(int rule, MAILSTREAM *m, long pc)
+ {
+   long n;
+   switch(rule){
+               /*
+                * For news in incoming collection we're doing the same thing
+                * for first-unseen and first-recent. In both those cases you
+                * get first-unseen if FAKE_NEW is off and first-recent if
+                * FAKE_NEW is on. If FAKE_NEW is on, first unseen is the
+                * same as first recent because all recent msgs are unseen
+                * and all unrecent msgs are seen (see pine_mail_open).
+                */
+               case IS_FIRST_UNSEEN:
+ first_unseen:
+                 mn_set_cur(ps_global->msgmap,
+                         (sp_first_unseen(m)
+                          && mn_get_sort(ps_global->msgmap) == SortArrival
+                          && !mn_get_revsort(ps_global->msgmap)
+                          && !get_lflag(ps_global->mail_stream, NULL,
+                                        sp_first_unseen(m), MN_EXLD)
+                          && (n = mn_raw2m(ps_global->msgmap,
+                                           sp_first_unseen(m))))
+                            ? n
+                            : first_sorted_flagged(F_UNSEEN | F_UNDEL, m, pc,
+                                               THREADING() ? 0 : FSF_SKIP_CHID));
+                 break;
+ 
+               case IS_FIRST_RECENT:
+ first_recent:
+                 /*
+                  * We could really use recent for news but this is the way
+                  * it has always worked, so we'll leave it. That is, if
+                  * the FAKE_NEW feature is on, recent and unseen are
+                  * equivalent, so it doesn't matter. If the feature isn't
+                  * on, all the undeleted messages are unseen and we start
+                  * at the first one. User controls with the FAKE_NEW feature.
+                  */
+                 if(IS_NEWS(ps_global->mail_stream)){
+                     mn_set_cur(ps_global->msgmap,
+                                first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
+                                                THREADING() ? 0 : FSF_SKIP_CHID));
+                 }
+                 else{
+                     mn_set_cur(ps_global->msgmap,
+                                first_sorted_flagged(F_RECENT | F_UNSEEN
+                                                     | F_UNDEL,
+                                                     m, pc,
+                                               THREADING() ? 0 : FSF_SKIP_CHID));
+                 }
+                 break;
+ 
+               case IS_FIRST_IMPORTANT:
+                 mn_set_cur(ps_global->msgmap,
+                            first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+                                               THREADING() ? 0 : FSF_SKIP_CHID));
+                 break;
+ 
+               case IS_FIRST_IMPORTANT_OR_UNSEEN:
+ 
+                 if(IS_NEWS(ps_global->mail_stream))
+                   goto first_unseen;
+ 
+                 {
+                     MsgNo flagged, first_unseen;
+ 
+                     flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+                                                THREADING() ? 0 : FSF_SKIP_CHID);
+                     first_unseen = (sp_first_unseen(m)
+                              && mn_get_sort(ps_global->msgmap) == SortArrival
+                              && !mn_get_revsort(ps_global->msgmap)
+                              && !get_lflag(ps_global->mail_stream, NULL,
+                                            sp_first_unseen(m), MN_EXLD)
+                              && (n = mn_raw2m(ps_global->msgmap,
+                                               sp_first_unseen(m))))
+                                 ? n
+                                 : first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
+                                                THREADING() ? 0 : FSF_SKIP_CHID);
+                     mn_set_cur(ps_global->msgmap,
+                           (MsgNo) MIN((int) flagged, (int) first_unseen));
+ 
+                 }
+ 
+                 break;
+ 
+               case IS_FIRST_IMPORTANT_OR_RECENT:
+ 
+                 if(IS_NEWS(ps_global->mail_stream))
+                   goto first_recent;
+ 
+                 {
+                     MsgNo flagged, first_recent;
+ 
+                     flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+                                                THREADING() ? 0 : FSF_SKIP_CHID);
+                     first_recent = first_sorted_flagged(F_RECENT | F_UNSEEN
+                                                         | F_UNDEL,
+                                                         m, pc,
+                                                THREADING() ? 0 : FSF_SKIP_CHID);
+                     mn_set_cur(ps_global->msgmap,
+                               (MsgNo) MIN((int) flagged, (int) first_recent));
+                 }
+ 
+                 break;
+ 
+               case IS_FIRST:
+                 mn_set_cur(ps_global->msgmap,
+                            first_sorted_flagged(F_UNDEL, m, pc,
+                                               THREADING() ? 0 : FSF_SKIP_CHID));
+                 break;
+ 
+               case IS_LAST:
+                 mn_set_cur(ps_global->msgmap,
+                            first_sorted_flagged(F_UNDEL, m, pc,
+                                  FSF_LAST | (THREADING() ? 0 : FSF_SKIP_CHID)));
+                 break;
+ 
+               default:
+                 panic("Unexpected incoming startup case");
+                 break;
+ 
+   }
+ }
diff -rc alpine-2.11/pith/mailcmd.h alpine-2.11.I.USE/pith/mailcmd.h
*** alpine-2.11/pith/mailcmd.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/mailcmd.h	2013-12-01 16:34:54.000000000 -0700
***************
*** 42,47 ****
--- 42,49 ----
  #define DB_FROMTAB	0x02	/* opening because of TAB command      */
  #define DB_INBOXWOCNTXT	0x04	/* interpret inbox as one true inbox */
  
+ static  MAILSTREAM *saved_stream;
+ static  unsigned long rule_curpos = 0L;
  
  /*
   * generic "is aggregate message command?" test
***************
*** 63,69 ****
--- 65,77 ----
  void	   expunge_and_close(MAILSTREAM *, char **, unsigned long);
  void	   agg_select_all(MAILSTREAM *, MSGNO_S *, long *, int);
  char	  *move_read_msgs(MAILSTREAM *, char *, char *, size_t, long);
+ char	  *move_read_msgs_using_rules (MAILSTREAM *, char *, char *);
+ unsigned   get_perfolder_startup_rule (MAILSTREAM *, int, char *);
+ void	   setup_threading_index_style (void);
+ void	   find_startup_position (int, MAILSTREAM *, long);
+ char	  *get_folder_to_save (MAILSTREAM *, long, char *);
  char	  *move_read_incoming(MAILSTREAM *, CONTEXT_S *, char *, char **, char *, size_t);
+ unsigned   long rules_cursor_pos (MAILSTREAM *);
  void	   cross_delete_crossposts(MAILSTREAM *);
  long	   zoom_index(struct pine *, MAILSTREAM *, MSGNO_S *, int);
  int	   unzoom_index(struct pine *, MAILSTREAM *, MSGNO_S *);
diff -rc alpine-2.11/pith/mailindx.c alpine-2.11.I.USE/pith/mailindx.c
*** alpine-2.11/pith/mailindx.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/mailindx.c	2013-12-01 16:41:34.000000000 -0700
***************
*** 17,22 ****
--- 17,23 ----
  
  #include "../pith/headers.h"
  #include "../pith/mailindx.h"
+ #include "../pith/pineelt.h"
  #include "../pith/mailview.h"
  #include "../pith/flag.h"
  #include "../pith/icache.h"
***************
*** 40,45 ****
--- 41,47 ----
  #include "../pith/send.h"
  #include "../pith/options.h"
  #include "../pith/ablookup.h"
+ #include "../pith/rules.h"
  #ifdef _WINDOWS
  #include "../pico/osdep/mswin.h"
  #endif
***************
*** 228,233 ****
--- 230,236 ----
  	      case iSTime:
  	      case iKSize:
  	      case iSize:
+ 	      case iSizeThread:
  	      case iPrioAlpha:
  		(*answer)[column].req_width = 7;
  		break;
***************
*** 374,379 ****
--- 377,389 ----
      PAT_STATE     pstate;
      PAT_S        *pat;
      int           we_set_it = 0;
+     char *rule;
+ 
+     if(rule = get_rule_result(FOR_INDEX, ps_global->cur_folder, V_INDEX_RULES)){
+       init_index_format(rule, &ps_global->index_disp_format);
+       fs_give((void **)&rule);
+       return;
+     }
  
      if(ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
***************
*** 447,460 ****
  static INDEX_PARSE_T itokens[] = {
      {"STATUS",		iStatus,	FOR_INDEX},
      {"MSGNO",		iMessNo,	FOR_INDEX},
!     {"DATE",		iDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"FROMORTO",	iFromTo,	FOR_INDEX},
      {"FROMORTONOTNEWS",	iFromToNotNews,	FOR_INDEX},
      {"SIZE",		iSize,		FOR_INDEX},
      {"SIZECOMMA",	iSizeComma,	FOR_INDEX},
      {"SIZENARROW",	iSizeNarrow,	FOR_INDEX},
      {"KSIZE",		iKSize,		FOR_INDEX},
!     {"SUBJECT",		iSubject,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"FULLSTATUS",	iFStatus,	FOR_INDEX},
      {"IMAPSTATUS",	iIStatus,	FOR_INDEX},
      {"SHORTIMAPSTATUS",	iSIStatus,	FOR_INDEX},
--- 457,471 ----
  static INDEX_PARSE_T itokens[] = {
      {"STATUS",		iStatus,	FOR_INDEX},
      {"MSGNO",		iMessNo,	FOR_INDEX},
!     {"DATE",		iDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
      {"FROMORTO",	iFromTo,	FOR_INDEX},
      {"FROMORTONOTNEWS",	iFromToNotNews,	FOR_INDEX},
      {"SIZE",		iSize,		FOR_INDEX},
      {"SIZECOMMA",	iSizeComma,	FOR_INDEX},
+     {"SIZETHREAD",	iSizeThread,	FOR_INDEX},
      {"SIZENARROW",	iSizeNarrow,	FOR_INDEX},
      {"KSIZE",		iKSize,		FOR_INDEX},
!     {"SUBJECT",		iSubject,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_TRIM},
      {"FULLSTATUS",	iFStatus,	FOR_INDEX},
      {"IMAPSTATUS",	iIStatus,	FOR_INDEX},
      {"SHORTIMAPSTATUS",	iSIStatus,	FOR_INDEX},
***************
*** 463,517 ****
      {"SUBJECTTEXT",	iSubjectText,	FOR_INDEX},
      {"SUBJKEYTEXT",	iSubjKeyText,	FOR_INDEX},
      {"SUBJKEYINITTEXT", iSubjKeyInitText, FOR_INDEX},
!     {"OPENINGTEXT",	iOpeningText,	FOR_INDEX},
!     {"OPENINGTEXTNQ",	iOpeningTextNQ,	FOR_INDEX},
!     {"KEY",		iKey,		FOR_INDEX},
!     {"KEYINIT",		iKeyInit,	FOR_INDEX},
      {"DESCRIPSIZE",	iDescripSize,	FOR_INDEX},
      {"ATT",		iAtt,		FOR_INDEX},
      {"SCORE",		iScore,		FOR_INDEX},
      {"PRIORITY",	iPrio,		FOR_INDEX},
      {"PRIORITYALPHA",	iPrioAlpha,	FOR_INDEX},
!     {"PRIORITY!",	iPrioBang,	FOR_INDEX},
!     {"LONGDATE",	iLDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATE1",	iS1Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATE2",	iS2Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATE3",	iS3Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATE4",	iS4Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DATEISO",		iDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SHORTDATEISO",	iDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATE",	iSDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTTIME",	iSTime,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATEISO",	iSDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATESHORTISO",iSDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATES1",	iSDateS1,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATES2",	iSDateS2,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATES3",	iSDateS3,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATES4",	iSDateS4,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIME",	iSDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMEISO",iSDateTimeIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMESHORTISO",iSDateTimeIsoS,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMES1",	iSDateTimeS1,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMES2",	iSDateTimeS2,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMES3",	iSDateTimeS3,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMES4",	iSDateTimeS4,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIME24",		iSDateTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMEISO24",	iSDateTimeIso24,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMESHORTISO24",iSDateTimeIsoS24,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMES124",	iSDateTimeS124,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMES224",	iSDateTimeS224,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMES324",	iSDateTimeS324,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SMARTDATETIMES424",	iSDateTimeS424,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TIME24",		iTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TIME12",		iTime12,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TIMEZONE",	iTimezone,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"MONTHABBREV",	iMonAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYOFWEEKABBREV",	iDayOfWeekAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYOFWEEK",	iDayOfWeek,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"FROM",		iFrom,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"TO",		iTo,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"SENDER",		iSender,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"CC",		iCc,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"RECIPS",		iRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"NEWS",		iNews,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"TOANDNEWS",	iToAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
--- 474,531 ----
      {"SUBJECTTEXT",	iSubjectText,	FOR_INDEX},
      {"SUBJKEYTEXT",	iSubjKeyText,	FOR_INDEX},
      {"SUBJKEYINITTEXT", iSubjKeyInitText, FOR_INDEX},
!     {"OPENINGTEXT",	iOpeningText,	FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_TRIM},
!     {"OPENINGTEXTNQ",	iOpeningTextNQ,	FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_TRIM},
!     {"KEY",		iKey,		FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_COMPOSE},
!     {"KEYINIT",		iKeyInit,	FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_COMPOSE},
      {"DESCRIPSIZE",	iDescripSize,	FOR_INDEX},
      {"ATT",		iAtt,		FOR_INDEX},
      {"SCORE",		iScore,		FOR_INDEX},
      {"PRIORITY",	iPrio,		FOR_INDEX},
      {"PRIORITYALPHA",	iPrioAlpha,	FOR_INDEX},
!     {"PRIORITY!",	iPrioBang,	FOR_INDEX},  
!     {"LONGDATE",	iLDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATE1",	iS1Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATE2",	iS2Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATE3",	iS3Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATE4",	iS4Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DATEISO",		iDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SHORTDATEISO",	iDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATE",	iSDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTTIME",	iSTime,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATEISO",	iSDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATESHORTISO",iSDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATES1",	iSDateS1,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATES2",	iSDateS2,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATES3",	iSDateS3,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATES4",	iSDateS4,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIME",	iSDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMEISO",iSDateTimeIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMESHORTISO",iSDateTimeIsoS,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMES1",	iSDateTimeS1,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMES2",	iSDateTimeS2,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMES3",	iSDateTimeS3,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMES4",	iSDateTimeS4,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIME24",		iSDateTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMEISO24",	iSDateTimeIso24,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMESHORTISO24",iSDateTimeIsoS24,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMES124",	iSDateTimeS124,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMES224",	iSDateTimeS224,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMES324",	iSDateTimeS324,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"SMARTDATETIMES424",	iSDateTimeS424,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"TIME24",		iTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"TIME12",		iTime12,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"TIMEZONE",	iTimezone,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"MONTHABBREV",	iMonAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAYOFWEEKABBREV",	iDayOfWeekAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAYOFWEEK",	iDayOfWeek,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"FROM",		iFrom,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_COMPOSE},
!     {"TO",		iTo,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_COMPOSE},
!     {"SENDER",		iSender,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"CC",		iCc,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_SAVE},
!     {"ADDRESSTO",	iAddressTo,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"ADDRESSCC",	iAddressCc,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"ADDRESSRECIPS",	iAddressRecip,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
      {"RECIPS",		iRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"NEWS",		iNews,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"TOANDNEWS",	iToAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
***************
*** 520,575 ****
      {"NEWSANDRECIPS",	iNewsAndRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"MSGID",		iMsgID,		FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"CURNEWS",		iCurNews,	FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYDATE",		iRDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"PREFDATE",	iPrefDate,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"PREFTIME",	iPrefTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"PREFDATETIME",	iPrefDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAY",		iDay,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYORDINAL",	iDayOrdinal,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAY2DIGIT",	iDay2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"MONTHLONG",	iMonLong,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"MONTH",		iMon,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"MONTH2DIGIT",	iMon2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"YEAR",		iYear,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"YEAR2DIGIT",	iYear2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"ADDRESS",		iAddress,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"MAILBOX",		iMailbox,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"ROLENICK",       	iRoleNick,	FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"INIT",		iInit,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"CURDATE",		iCurDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDATEISO",	iCurDateIso,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDATEISOS",	iCurDateIsoS,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURTIME24",	iCurTime24,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURTIME12",	iCurTime12,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDAY",		iCurDay,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDAY2DIGIT",	iCurDay2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURDAYOFWEEK",	iCurDayOfWeek,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
      {"CURDAYOFWEEKABBREV", iCurDayOfWeekAbb,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURMONTH",	iCurMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURMONTH2DIGIT",	iCurMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURMONTHLONG",	iCurMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURMONTHABBREV",	iCurMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURYEAR",		iCurYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURYEAR2DIGIT",	iCurYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURPREFDATE",	iCurPrefDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"CURPREFTIME",	iCurPrefTime,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
      {"CURPREFDATETIME",	iCurPrefDateTime,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTH",	iLstMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTH2DIGIT",	iLstMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTHLONG",	iLstMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTHABBREV",	iLstMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTMONTHYEAR",	iLstMonYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
      {"LASTMONTHYEAR2DIGIT", iLstMonYear2Digit,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTYEAR",	iLstYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
!     {"LASTYEAR2DIGIT",	iLstYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
      {"HEADER",		iHeader,	FOR_INDEX},
      {"TEXT",		iText,		FOR_INDEX},
      {"ARROW",		iArrow,		FOR_INDEX},
      {"NEWLINE",		iNewLine,	FOR_REPLY_INTRO},
      {"CURSORPOS",	iCursorPos,	FOR_TEMPLATE},
      {NULL,		iNothing,	FOR_NOTHING}
  };
  
--- 534,601 ----
      {"NEWSANDRECIPS",	iNewsAndRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"MSGID",		iMsgID,		FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"CURNEWS",		iCurNews,	FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"DAYDATE",		iRDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"PREFDATE",	iPrefDate,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"PREFTIME",	iPrefTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"PREFDATETIME",	iPrefDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAY",		iDay,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAYORDINAL",	iDayOrdinal,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"DAY2DIGIT",	iDay2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"MONTHLONG",	iMonLong,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"MONTH",		iMon,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"MONTH2DIGIT",	iMon2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"YEAR",		iYear,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"YEAR2DIGIT",	iYear2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
!     {"ADDRESS",		iAddress,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE},
      {"MAILBOX",		iMailbox,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"ROLENICK",       	iRoleNick,	FOR_REPLY_INTRO|FOR_TEMPLATE},
      {"INIT",		iInit,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
!     {"CURDATE",		iCurDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURDATEISO",	iCurDateIso,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURDATEISOS",	iCurDateIsoS,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURTIME24",	iCurTime24,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURTIME12",	iCurTime12,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURDAY",		iCurDay,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURDAY2DIGIT",	iCurDay2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURDAYOFWEEK",	iCurDayOfWeek,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
      {"CURDAYOFWEEKABBREV", iCurDayOfWeekAbb,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURMONTH",	iCurMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURMONTH2DIGIT",	iCurMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURMONTHLONG",	iCurMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURMONTHABBREV",	iCurMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURYEAR",		iCurYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURYEAR2DIGIT",	iCurYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURPREFDATE",	iCurPrefDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"CURPREFTIME",	iCurPrefTime,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
      {"CURPREFDATETIME",	iCurPrefDateTime,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"LASTMONTH",	iLstMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"LASTMONTH2DIGIT",	iLstMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"LASTMONTHLONG",	iLstMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"LASTMONTHABBREV",	iLstMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"LASTMONTHYEAR",	iLstMonYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
      {"LASTMONTHYEAR2DIGIT", iLstMonYear2Digit,
! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"LASTYEAR",	iLstYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
!     {"LASTYEAR2DIGIT",	iLstYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
      {"HEADER",		iHeader,	FOR_INDEX},
      {"TEXT",		iText,		FOR_INDEX},
      {"ARROW",		iArrow,		FOR_INDEX},
      {"NEWLINE",		iNewLine,	FOR_REPLY_INTRO},
      {"CURSORPOS",	iCursorPos,	FOR_TEMPLATE},
+     {"NICK",		iNick,		FOR_RULE|FOR_SAVE},
+     {"FOLDER",		iFolder,	FOR_RULE|FOR_SAVE|FOR_FOLDER},
+     {"ROLE",		iRole,		FOR_RULE|FOR_RESUB|FOR_TRIM|FOR_TEMPLATE},
+     {"PROCID",		iProcid,	FOR_RULE|FOR_RESUB|FOR_FLAG|FOR_COMPOSE|FOR_TRIM|FOR_TEMPLATE},
+     {"PKEY",		iPkey,		FOR_RULE|FOR_KEY},
+     {"SCREEN",		iScreen,	FOR_RULE|FOR_KEY},
+     {"FLAG",		iFlag,		FOR_RULE|FOR_SAVE|FOR_FLAG},
+     {"COLLECTION",	iCollection,	FOR_RULE|FOR_SAVE|FOR_COMPOSE|FOR_FOLDER},
+     {"BCC",		iBcc,		FOR_COMPOSE|FOR_RULE},
+     {"LCC",		iLcc,		FOR_COMPOSE|FOR_RULE},
+     {"FORWARDFROM",	iFfrom,		FOR_COMPOSE|FOR_RULE},
+     {"FORWARDADDRESS",	iFadd,		FOR_COMPOSE|FOR_RULE},
      {NULL,		iNothing,	FOR_NOTHING}
  };
  
***************
*** 943,949 ****
      iSDateTimeS1, iSDateTimeS2, iSDateTimeS3, iSDateTimeS4,
      iSDateTimeIso24, iSDateTimeIsoS24,
      iSDateTimeS124, iSDateTimeS224, iSDateTimeS324, iSDateTimeS424,
!     iSize, iSizeComma, iSizeNarrow, iKSize, iDescripSize,
      iPrio, iPrioBang, iPrioAlpha, iInit,
      iAtt, iTime24, iTime12, iTimezone, iMonAbb, iYear, iYear2Digit,
      iDay2Digit, iMon2Digit, iDayOfWeekAbb, iScore, iMonLong, iDayOfWeek
--- 969,975 ----
      iSDateTimeS1, iSDateTimeS2, iSDateTimeS3, iSDateTimeS4,
      iSDateTimeIso24, iSDateTimeIsoS24,
      iSDateTimeS124, iSDateTimeS224, iSDateTimeS324, iSDateTimeS424,
!     iSize, iSizeComma, iSizeNarrow, iKSize, iDescripSize, iSizeThread,
      iPrio, iPrioBang, iPrioAlpha, iInit,
      iAtt, iTime24, iTime12, iTimezone, iMonAbb, iYear, iYear2Digit,
      iDay2Digit, iMon2Digit, iDayOfWeekAbb, iScore, iMonLong, iDayOfWeek
***************
*** 1136,1141 ****
--- 1162,1168 ----
  		  case iTime12:
  		  case iSize:
  		  case iKSize:
+ 		  case iSizeThread:
  		    cdesc->actual_length = 7;
  		    cdesc->adjustment = Right;
  		    break;
***************
*** 1229,1235 ****
  	cdesc->ctype != iNothing;
  	cdesc++)
        if(cdesc->ctype == iSize || cdesc->ctype == iKSize ||
!          cdesc->ctype == iSizeNarrow ||
  	 cdesc->ctype == iSizeComma || cdesc->ctype == iDescripSize){
  	  if(cdesc->actual_length == 0){
  	      if((fix=cdesc->width) > 0){ /* had this reserved */
--- 1256,1262 ----
  	cdesc->ctype != iNothing;
  	cdesc++)
        if(cdesc->ctype == iSize || cdesc->ctype == iKSize ||
!          cdesc->ctype == iSizeNarrow  || cdesc->ctype == iSizeThread ||
  	 cdesc->ctype == iSizeComma || cdesc->ctype == iDescripSize){
  	  if(cdesc->actual_length == 0){
  	      if((fix=cdesc->width) > 0){ /* had this reserved */
***************
*** 1612,1621 ****
  
  		/* find next thread which is visible */
  		do{
  		    if(mn_get_revsort(msgmap) && thrd->prevthd)
  		      thrd = fetch_thread(stream, thrd->prevthd);
! 		    else if(!mn_get_revsort(msgmap) && thrd->nextthd)
! 		      thrd = fetch_thread(stream, thrd->nextthd);
  		    else
  		      thrd = NULL;
  		} while(thrd
--- 1639,1650 ----
  
  		/* find next thread which is visible */
  		do{
+ 		   unsigned long branch;
  		    if(mn_get_revsort(msgmap) && thrd->prevthd)
  		      thrd = fetch_thread(stream, thrd->prevthd);
! 			/*branch = get_branch(stream,thrd)*/
! 		    else if(!mn_get_revsort(msgmap) && thrd->branch)
! 		      thrd = fetch_thread(stream, thrd->branch);
  		    else
  		      thrd = NULL;
  		} while(thrd
***************
*** 2027,2039 ****
       */
      ice = copy_ice(ice);
  
      /* is this a collapsed thread index line? */
!     if(!idata->bogus && THREADING()){
! 	thrd = fetch_thread(idata->stream, idata->rawno);
! 	collapsed = thrd && thrd->next
! 		    && get_lflag(idata->stream, NULL,
! 				 idata->rawno, MN_COLL);
!     }
  
      /* calculate contents of the required fields */
      for(cdesc = ps_global->index_disp_format; cdesc->ctype != iNothing; cdesc++)
--- 2056,2065 ----
       */
      ice = copy_ice(ice);
  
+     thrd = fetch_thread(idata->stream, idata->rawno);
      /* is this a collapsed thread index line? */
!     if(!idata->bogus && THREADING())
! 	collapsed = thrd && thread_is_kolapsed(ps_global, idata->stream, ps_global->msgmap, idata->rawno);
  
      /* calculate contents of the required fields */
      for(cdesc = ps_global->index_disp_format; cdesc->ctype != iNothing; cdesc++)
***************
*** 2075,2084 ****
  			      if(to_us == ' ')
  				to_us = '+';
  
  			      break;
  			  }
  
! 			if(to_us != '+' && resent_to_us(idata)){
  			    ice->to_us = 1;
  			    if(to_us == ' ')
  			      to_us = '+';
--- 2101,2115 ----
  			      if(to_us == ' ')
  				to_us = '+';
  
+ 			      if(to_us == '+' 
+ 				   && F_ON(F_MARK_FOR_GROUP,ps_global) &&
+ 				 (addr->next || addr != fetch_to(idata)))
+ 				   to_us = '.';
+ 
  			      break;
  			  }
  
! 			if(to_us == ' ' && resent_to_us(idata)){
  			    ice->to_us = 1;
  			    if(to_us == ' ')
  			      to_us = '+';
***************
*** 2132,2138 ****
  			    ielem->color = new_color_pair(VAR_IND_IMP_FORE_COLOR, VAR_IND_IMP_BACK_COLOR);
  			}
  		    }
! 		    else if(str[0] == '+' || str[0] == '-'){
  			if(VAR_IND_PLUS_FORE_COLOR && VAR_IND_PLUS_BACK_COLOR){
  			    ielem = ifield->ielem;
  			    ielem->freecolor = 1;
--- 2163,2169 ----
  			    ielem->color = new_color_pair(VAR_IND_IMP_FORE_COLOR, VAR_IND_IMP_BACK_COLOR);
  			}
  		    }
! 		    else if(str[0] == '+' || str[0] == '-' || str[0] == '.'){
  			if(VAR_IND_PLUS_FORE_COLOR && VAR_IND_PLUS_BACK_COLOR){
  			    ielem = ifield->ielem;
  			    ielem->freecolor = 1;
***************
*** 2188,2193 ****
--- 2219,2230 ----
  			for(addr = fetch_to(idata); addr; addr = addr->next)
  			  if(address_is_us(addr, ps_global)){
  			      to_us = '+';
+ 
+ 			      if(to_us == '+' 
+ 				   && F_ON(F_MARK_FOR_GROUP,ps_global) &&
+ 				 (addr->next || addr != fetch_to(idata)))
+ 				   to_us = '.';
+ 
  			      break;
  			  }
  		      
***************
*** 2283,2289 ****
  
  		  if(pico_usingcolor()){
  
! 		      if(str[0] == '+' || str[0] == '-'){
  			  if(start == 0
  			     && VAR_IND_PLUS_FORE_COLOR
  			     && VAR_IND_PLUS_BACK_COLOR){
--- 2320,2326 ----
  
  		  if(pico_usingcolor()){
  
! 		      if(str[0] == '+' || str[0] == '-' || str[0] == '.'){
  			  if(start == 0
  			     && VAR_IND_PLUS_FORE_COLOR
  			     && VAR_IND_PLUS_BACK_COLOR){
***************
*** 2465,2470 ****
--- 2502,2525 ----
  		from_str(cdesc->ctype, idata, str, sizeof(str), ice);
  	        break;
  
+ 	      case iAddressTo:
+ 	      case iAddressCc:
+ 	      case iAddressRecip:
+ 		{ENVELOPE *env;
+ 		 int we_clear;
+ 		env = rules_fetchenvelope(idata, &we_clear); 
+ 		sprintf(str, "%-*.*s", ifield->width, ifield->width,
+ 		        detoken_src((cdesc->ctype == iAddressTo 
+ 				? "_ADDRESSTO_"
+ 				: (cdesc->ctype == iAddressCc
+ 				   ? "_ADRESSCC_"
+ 				   : "_ADRESSRECIPS_")), FOR_INDEX, 
+ 				env, NULL, NULL, NULL));
+ 		if(we_clear)
+ 		   mail_free_envelope(&env);
+ 		}
+ 		break;
+ 
  	      case iTo:
  		if(((field = ((addr = fetch_to(idata))
  			      ? "To"
***************
*** 2531,2537 ****
--- 2586,2615 ----
  
  	        break;
  
+            case iSizeThread:
+               if (!THREADING()){
+                 goto getsize;
+               } else if (collapsed){
+                    l =  count_flags_in_thread(idata->stream, thrd, F_NONE);
+                    snprintf(str, sizeof(str), "(%lu)", l);
+               }
+               else{
+                   thrd = fetch_thread(idata->stream, idata->rawno);
+                   if(!thrd)
+                          snprintf(str, sizeof(str), "%s", "Error");
+                   else{
+                       long lengthb;
+                       lengthb = get_length_branch(idata->stream, idata->rawno);
+                       if (lengthb > 0L)
+                          snprintf(str, sizeof(str), "(%lu)", lengthb);
+                       else
+                          snprintf(str,sizeof(str), "%s", " ");
+                     }
+               }
+              break;
+ 
  	      case iSize:
+ getsize:
  		/* 0 ... 9999 */
  		if((l = fetch_size(idata)) < 10*1000L)
  		  snprintf(str, sizeof(str), "(%lu)", l);
***************
*** 2785,2791 ****
  		    if(first_text){
  			strncpy(str, first_text, BIGWIDTH);
  			str[BIGWIDTH] = '\0';
- 			fs_give((void **) &first_text);
  		    }
  		}
  
--- 2863,2868 ----
***************
*** 3107,3113 ****
  		  tice->linecolor = new_color_pair(VAR_IND_IMP_FORE_COLOR,
  						   VAR_IND_IMP_BACK_COLOR);
  	    }
! 	    else if((to_us == '+' || to_us == '-')
  		    && VAR_IND_PLUS_FORE_COLOR && VAR_IND_PLUS_BACK_COLOR){
  		ielem = ifield->ielem;
  		ielem->freecolor = 1;
--- 3184,3190 ----
  		  tice->linecolor = new_color_pair(VAR_IND_IMP_FORE_COLOR,
  						   VAR_IND_IMP_BACK_COLOR);
  	    }
! 	    else if((to_us == '+' || to_us == '-' || to_us == '.')
  		    && VAR_IND_PLUS_FORE_COLOR && VAR_IND_PLUS_BACK_COLOR){
  		ielem = ifield->ielem;
  		ielem->freecolor = 1;
***************
*** 3710,3715 ****
--- 3787,3812 ----
      gf_io_t pc;
      long partial_fetch_len = 0L;
      SEARCHSET *ss, **sset;
+     MESSAGECACHE *mc;
+     PINELT_S     *pelt;
+ 
+     /* we cache the result we get from this function, so that we do not have to
+      * refetch the text in case there is a change. We could cache in the envelope
+      * but c-client does not have a special field for that, nor we want to use the
+      * sparep pointer, since there could be other uses for sparep later, and even 
+      * if we add a pointer to the ENVELOPE structure, we would be caching the same 
+      * text twice (one in a private pointer, and the new pointer) and that would 
+      * not make sense. Instead we will use an elt for this
+      */
+ 
+     if((mc = mail_elt(idata->stream, idata->rawno))
+        && ((pelt = (PINELT_S *) mc->sparep) == NULL)){
+         pelt = (PINELT_S *) fs_get(sizeof(PINELT_S));
+         memset(pelt, 0, sizeof(PINELT_S));
+     }
+         
+     if(pelt && pelt->firsttext != NULL)
+       return(pelt->firsttext);
  
  try_again:
  
***************
*** 3803,3809 ****
--- 3900,3916 ----
  
  			if(p > buf){
  			    size_t l;
+ 			    ENVELOPE *env;
+ 			    char *rule_result;
  
+ 			    if(rule_result = find_value((delete_quotes
+ 				      ? "_OPENINGTEXTNQ_" : "_OPENINGTEXT_"), 
+ 				      buf, PROCESS_SP, idata, 4)){
+ 			      collspaces(rule_result);
+ 			      strncpy(buf, rule_result, sizeof(buf));
+ 			      buf[sizeof(buf) - 1] = '\0';
+ 			      fs_give((void **) &rule_result);
+ 			    }
  			    l = strlen(buf);
  			    l += 100;
  			    firsttext = fs_get((l+1) * sizeof(char));
***************
*** 3827,3832 ****
--- 3934,3941 ----
  			    goto try_again;
  			}
  		    }
+ 		    if(mc && pelt)
+ 			pelt->firsttext = firsttext;
  		}
  	    }	
  	}
***************
*** 5267,5276 ****
  {
      char          *subject, *origsubj, *origstr, *rawsubj, *sptr = NULL;
      char          *p, *border, *q = NULL, *free_subj = NULL;
!     char	  *sp;
      size_t         len;
      int            width = -1;
!     int            depth = 0, mult = 2;
      int            save;
      int            do_subj = 0, truncated_tree = 0;
      PINETHRD_S    *thd, *thdorig;
--- 5376,5385 ----
  {
      char          *subject, *origsubj, *origstr, *rawsubj, *sptr = NULL;
      char          *p, *border, *q = NULL, *free_subj = NULL;
!     char	  *sp, *rule_result;
      size_t         len;
      int            width = -1;
!     int            depth = 0, mult = 2, collapsed, i, we_clear = 0;
      int            save;
      int            do_subj = 0, truncated_tree = 0;
      PINETHRD_S    *thd, *thdorig;
***************
*** 5324,5330 ****
       * origsubj is the original subject but it has been decoded. We need
       * to free it at the end of this routine.
       */
! 
  
      /*
       * prepend_keyword will put the keyword stuff before the subject
--- 5433,5445 ----
       * origsubj is the original subject but it has been decoded. We need
       * to free it at the end of this routine.
       */
!     if (rule_result = find_value("_SUBJECT_", origsubj, PROCESS_SP, idata, 4)){
!        if(origsubj)
! 	 fs_give((void **)&origsubj);
!        we_clear++;
!        origsubj = cpystr(rule_result);
!        fs_give((void **)&rule_result);
!     }
  
      /*
       * prepend_keyword will put the keyword stuff before the subject
***************
*** 5412,5421 ****
  
  	if(pith_opt_condense_thread_cue)
  	  width = (*pith_opt_condense_thread_cue)(thd, ice, &str, &strsize, width,
! 						  thd && thd->next
! 						  && get_lflag(idata->stream,
! 							       NULL,idata->rawno,
! 							       MN_COLL));
  
  	/*
  	 * width is < available strsize and
--- 5527,5534 ----
  
  	if(pith_opt_condense_thread_cue)
  	  width = (*pith_opt_condense_thread_cue)(thd, ice, &str, &strsize, width,
! 	   this_thread_is_kolapsed(ps_global, idata->stream, ps_global->msgmap, idata->rawno) &&
! 	   (count_thread(ps_global,idata->stream, ps_global->msgmap, idata->rawno) != 1));
  
  	/*
  	 * width is < available strsize and
***************
*** 5765,5770 ****
--- 5878,5886 ----
  
      if(free_subj)
        fs_give((void **) &free_subj);
+ 
+     if (we_clear && origsubj)
+       fs_give((void **)&origsubj);
  }
  
  
***************
*** 6043,6053 ****
  	border = str + width;
  	if(pith_opt_condense_thread_cue)
  	  width = (*pith_opt_condense_thread_cue)(thd, ice, &str, &strsize, width,
! 						  thd && thd->next
! 						  && get_lflag(idata->stream,
! 							       NULL,idata->rawno,
! 							       MN_COLL));
! 
  	fptr = str;
  
  	if(thd)
--- 6159,6166 ----
  	border = str + width;
  	if(pith_opt_condense_thread_cue)
  	  width = (*pith_opt_condense_thread_cue)(thd, ice, &str, &strsize, width,
! 	   this_thread_is_kolapsed(ps_global, idata->stream, ps_global->msgmap, idata->rawno) &&
! 	     (count_thread(ps_global,idata->stream, ps_global->msgmap, idata->rawno) != 1));
  	fptr = str;
  
  	if(thd)
***************
*** 6133,6148 ****
  				 ? "To"
  				 : (addr = fetch_cc(idata))
  				 ? "Cc"
! 				 : NULL))
! 		       && set_index_addr(idata, field, addr, "To: ",
! 					 strsize-1, fptr))
! 		      break;
  
  		    if(ctype == iFromTo &&
  		       (newsgroups = fetch_newsgroups(idata)) &&
  		       *newsgroups){
! 			snprintf(fptr, strsize, "To: %-*.*s", strsize-1-4, strsize-1-4,
! 				newsgroups);
  			break;
  		    }
  
--- 6246,6278 ----
  				 ? "To"
  				 : (addr = fetch_cc(idata))
  				 ? "Cc"
! 				 : NULL))){
! 			  char *rule_result;
! 			  rule_result = find_value("_FROM_", NULL, 0, idata, 1);
! 			  if (!rule_result)
! 			  set_index_addr(idata, field, addr, "To: ",
! 				strsize-1, fptr);
! 			  else{
! 			    sprintf(str, "%-*.*s", strsize-1, strsize-1, 
! 								rule_result);
! 			    fs_give((void **)&rule_result);
! 			  }
  
+ 		      break;
+ 		    }
  		    if(ctype == iFromTo &&
  		       (newsgroups = fetch_newsgroups(idata)) &&
  		       *newsgroups){
! 			   char *rule_result;
! 			   rule_result = find_value("_FROM_", NULL, 0, idata, 1);
! 			   if (!rule_result)
! 				sprintf(str, "To: %-*.*s", strsize-1-4, 
! 					strsize-1-4, newsgroups);
! 				else{
! 				  sprintf(str, "%-*.*s", strsize-1, strsize-1,
! 							 rule_result);
! 				  fs_give((void **)&rule_result);
! 				}
  			break;
  		    }
  
***************
*** 6155,6161 ****
  	      break;
  
  	  case iFrom:
! 	    set_index_addr(idata, "From", fetch_from(idata), NULL, strsize-1, fptr);
  	    break;
  
  	  case iAddress:
--- 6285,6299 ----
  	      break;
  
  	  case iFrom:
! 	   { char *rule_result;
! 	     rule_result = find_value("_FROM_", NULL, 0, idata, 4);
! 	     if (!rule_result) 
! 	      set_index_addr(idata, "From", fetch_from(idata), NULL, strsize-1, fptr);
! 	     else{
! 		sprintf(str, "%-*.*s", strsize-1, strsize-1, rule_result);
! 		fs_give((void **)&rule_result);
! 	     }
! 	   }
  	    break;
  
  	  case iAddress:
***************
*** 6452,6454 ****
--- 6590,6653 ----
  	}
      }
  }
+ 
+ void
+ setup_threading_display_style(void)
+ {
+   RULE_RESULT *rule;
+   NAMEVAL_S *v;
+   int i;
+ 
+   rule = get_result_rule(V_THREAD_DISP_STYLE_RULES, FOR_THREAD, NULL);
+   if (rule || ps_global->VAR_THREAD_DISP_STYLE){
+      for(i = 0; v = thread_disp_styles(i); i++)
+         if(!strucmp(rule ? rule->result : ps_global->VAR_THREAD_DISP_STYLE, 
+ 		    rule ? (v ? v->name : "" ) : S_OR_L(v))){
+               ps_global->thread_disp_style = v->value;
+               break;
+         }
+      if (rule){
+ 	if (rule->result)
+ 	   fs_give((void **)&rule->result);
+ 	fs_give((void **)&rule);
+      }
+   }
+ }
+ 
+ char *
+ find_value(char *token, char *use_this, int flag, INDEXDATA_S *idata, int nfcn)
+ {
+  int n = 0, i, rule_context, we_clear;
+  char  *rule_result = NULL, **list;
+  ENVELOPE *env;
+  RULELIST *rule;
+  RULE_S *prule;
+ 
+  env = rules_fetchenvelope(idata, &we_clear);
+  if(env && env->sparep)
+     fs_give((void **)&env->sparep);
+  if(we_clear)
+    mail_free_envelope(&env);
+  if(rule = get_rulelist_from_code(V_REPLACE_RULES, ps_global->rule_list)){
+     list = functions_for_token(token);
+     while(rule_result == NULL && (prule = get_rule(rule,n++))){
+         rule_context = 0;
+         if (prule->action->token && !strcmp(prule->action->token, token)){
+            for (i = 0; i < nfcn; i++)
+               if(list[i+1] && !strcmp(prule->action->function, list[i+1]))
+                  rule_context |= context_for_function(list[i+1]);
+            if (rule_context){
+ 	      env = rules_fetchenvelope(idata, &we_clear);
+ 	      if(use_this)
+ 		env->sparep = get_sparep_for_rule(use_this, flag);
+ 	     rule_result = process_rule(prule, rule_context, env);
+ 	     if(env->sparep)
+ 		free_sparep_for_rule(&env->sparep);
+ 	     if(we_clear)
+ 	       mail_free_envelope(&env);
+ 	   }
+         }
+     }
+  }
+  return rule_result;
+ }
diff -rc alpine-2.11/pith/mailindx.h alpine-2.11.I.USE/pith/mailindx.h
*** alpine-2.11/pith/mailindx.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/mailindx.h	2013-12-01 16:34:54.000000000 -0700
***************
*** 30,35 ****
--- 30,38 ----
  
  
  /* exported prototypes */
+ SortOrder      translate (char *, int);
+ char	      *find_value (char *, char *, int, INDEXDATA_S *, int);
+ void	       setup_threading_display_style (void);
  int	       msgline_hidden(MAILSTREAM *, MSGNO_S *, long, int);
  void	       adjust_cur_to_visible(MAILSTREAM *, MSGNO_S *);
  unsigned long  line_hash(char *);
diff -rc alpine-2.11/pith/mailview.c alpine-2.11.I.USE/pith/mailview.c
*** alpine-2.11/pith/mailview.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/mailview.c	2013-12-01 16:39:57.000000000 -0700
***************
*** 52,58 ****
  #include "../pith/escapes.h"
  #include "../pith/keyword.h"
  #include "../pith/smime.h"
! 
  
  #define FBUF_LEN	(50)
  
--- 52,62 ----
  #include "../pith/escapes.h"
  #include "../pith/keyword.h"
  #include "../pith/smime.h"
! #include "../pith/osdep/color.h"
! #include "../pico/osdep/color.h"
! #include "../pico/estruct.h"
! #include "../pico/pico.h"
! #include "../pico/efunc.h"
  
  #define FBUF_LEN	(50)
  
***************
*** 282,290 ****
  	    if((flgs & FM_DISPLAY)
  	       && !(flgs & FM_NOCOLOR)
  	       && pico_usingcolor()
  	       && ps_global->VAR_SIGNATURE_FORE_COLOR
  	       && ps_global->VAR_SIGNATURE_BACK_COLOR){
! 		gf_link_filter(gf_line_test, gf_line_test_opt(color_signature, &is_in_sig));
  	    }
  
  	    if((flgs & FM_DISPLAY)
--- 286,302 ----
  	    if((flgs & FM_DISPLAY)
  	       && !(flgs & FM_NOCOLOR)
  	       && pico_usingcolor()
+ 	       && ps_global->VAR_SPECIAL_TEXT_FORE_COLOR
+ 	       && ps_global->VAR_SPECIAL_TEXT_BACK_COLOR){
+ 		gf_link_filter(gf_line_test, gf_line_test_opt(color_this_text, NULL));
+ 	    }
+ 
+ 	    if((flgs & FM_DISPLAY)
+ 	       && !(flgs & FM_NOCOLOR)
+ 	       && pico_usingcolor()
  	       && ps_global->VAR_SIGNATURE_FORE_COLOR
  	       && ps_global->VAR_SIGNATURE_BACK_COLOR){
! 		gf_link_filter(gf_quote_test, gf_line_test_opt(color_signature, &is_in_sig));
  	    }
  
  	    if((flgs & FM_DISPLAY)
***************
*** 292,299 ****
  	       && pico_usingcolor()
  	       && ps_global->VAR_QUOTE1_FORE_COLOR
  	       && ps_global->VAR_QUOTE1_BACK_COLOR){
! 		gf_link_filter(gf_line_test, gf_line_test_opt(color_a_quote, NULL));
  	    }
  
  	    if(!(flgs & FM_NOWRAP)){
  		wrapflags = (flgs & FM_DISPLAY) ? (GFW_HANDLES|GFW_SOFTHYPHEN) : GFW_NONE;
--- 304,313 ----
  	       && pico_usingcolor()
  	       && ps_global->VAR_QUOTE1_FORE_COLOR
  	       && ps_global->VAR_QUOTE1_BACK_COLOR){
! 		gf_link_filter(gf_quote_test, gf_line_test_opt(color_a_quote, NULL));
  	    }
+ 	    else
+ 		gf_link_filter(gf_quote_test,gf_line_test_opt(select_quote, NULL));
  
  	    if(!(flgs & FM_NOWRAP)){
  		wrapflags = (flgs & FM_DISPLAY) ? (GFW_HANDLES|GFW_SOFTHYPHEN) : GFW_NONE;
***************
*** 1098,1124 ****
  color_signature(long int linenum, char *line, LT_INS_S **ins, void *is_in_sig)
  {
      struct variable *vars = ps_global->vars;
!     int             *in_sig_block;
      COLOR_PAIR      *col = NULL;
  
      if(is_in_sig == NULL)
        return 0;
  
      in_sig_block = (int *) is_in_sig;
      
!     if(!strcmp(line, SIGDASHES))
!       *in_sig_block = START_SIG_BLOCK; 
!     else if(*line == '\0')
        /* 
         * Suggested by Eduardo: allow for a blank line right after 
         * the sigdashes. 
         */
        *in_sig_block = (*in_sig_block == START_SIG_BLOCK)
  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
      else
        *in_sig_block = (*in_sig_block != OUT_SIG_BLOCK)
  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
  
      if(*in_sig_block != OUT_SIG_BLOCK
         && VAR_SIGNATURE_FORE_COLOR && VAR_SIGNATURE_BACK_COLOR
         && (col = new_color_pair(VAR_SIGNATURE_FORE_COLOR,
--- 1112,1199 ----
  color_signature(long int linenum, char *line, LT_INS_S **ins, void *is_in_sig)
  {
      struct variable *vars = ps_global->vars;
!     int             *in_sig_block, i, j,same_qstr = 0, plb;
      COLOR_PAIR      *col = NULL;
+     static char GLine[NSTRING] = {'\0'};
+     static char PLine[NSTRING] = {'\0'};
+     static char PPLine[NSTRING] = {'\0'};
+     char NLine[NSTRING] = {'\0'};
+     char rqstr[NSTRING] = {'\0'};
+     char *p, *q;
+     static char *buf, buf2[NSTRING] = {'\0'};
+     QSTRING_S *qs;
+     static int qstrlen = 0;
  
      if(is_in_sig == NULL)
        return 0;
  
+     if (linenum > 0){
+ 	strncpy(PLine, GLine, sizeof(PLine));
+ 	PLine[sizeof(PLine)-1] = '\0';
+     }
+ 
+     if(p = strchr(tmp_20k_buf, '\015')) *p = '\0';
+     strncpy(NLine, tmp_20k_buf, sizeof(NLine));
+     NLine[sizeof(NLine) - 1] = '\0';
+     if (p) *p = '\015';
+ 
+     strncpy(GLine, line, sizeof(GLine));
+     GLine[sizeof(GLine) - 1] = '\0';
+ 
+     ps_global->list_qstr = default_qstr(ps_global->prefix && *ps_global->prefix 
+ 		? (void *) ps_global->prefix : (void *) ">", 0);
+     plb = line_isblank(ps_global->list_qstr, PLine, GLine, PPLine, NSTRING);
+     qs = do_quote_match(ps_global->list_qstr, GLine, NLine, PLine, rqstr, NSTRING, plb);
+     if(linenum > 0)
+        strncpy(PPLine, PLine, NSTRING);
+     strncpy(buf2, rqstr, NSTRING);
+     i = buf2 && buf2[0] ? strlen(buf2) : 0;
+     free_qs(&qs);
+ 
+     /* determine if buf and buf2 are the same quote string */
+     if (!struncmp(buf, buf2, qstrlen)){
+       for (j = qstrlen; buf2[j] && isspace((unsigned char)buf2[j]); j++);
+       if (!buf2[j] || buf2[j] == '|' || (buf2[j] == '*' && buf2[j+1] != '>'))
+          same_qstr++;
+     }
+ 
      in_sig_block = (int *) is_in_sig;
      
!     if (*in_sig_block != OUT_SIG_BLOCK){
!       if (line && *line && (strlen(line) >= qstrlen) && same_qstr)
!          line += qstrlen;
!         else if (strlen(line) < qstrlen)
!          line += i;
!       else if (!same_qstr)
!          *in_sig_block = OUT_SIG_BLOCK;
!     }
!     else
!       line += i;
! 
!     if(!strcmp(line, SIGDASHES) || !strcmp(line, "--")){
!       *in_sig_block = START_SIG_BLOCK;
!        buf = (char *) fs_get((i + 1)*sizeof(char));
!        buf = cpystr(buf2);
!        qstrlen = i;
!     }
!     else if(*line == '\0'){
        /* 
         * Suggested by Eduardo: allow for a blank line right after 
         * the sigdashes. 
         */
        *in_sig_block = (*in_sig_block == START_SIG_BLOCK)
  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
+     }
      else
        *in_sig_block = (*in_sig_block != OUT_SIG_BLOCK)
  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
  
+     if (*in_sig_block == OUT_SIG_BLOCK){
+       qstrlen = 0;    /* reset back in case there's another paragraph */
+       if (buf)
+          fs_give((void **)&buf);
+     }
+ 
      if(*in_sig_block != OUT_SIG_BLOCK
         && VAR_SIGNATURE_FORE_COLOR && VAR_SIGNATURE_BACK_COLOR
         && (col = new_color_pair(VAR_SIGNATURE_FORE_COLOR,
***************
*** 1482,1499 ****
      return(0);
  }
  
  
  int
  url_hilite(long int linenum, char *line, LT_INS_S **ins, void *local)
  {
      register char *lp, *up = NULL, *urlp = NULL,
  		  *weburlp = NULL, *mailurlp = NULL;
!     int		   n, n1, n2, n3, l;
      char	   buf[256], color[256];
      HANDLE_S	  *h;
      URL_HILITE_S  *uh;
  
!     for(lp = line; ; lp = up + n){
  	/* scan for all of them so we can choose the first */
  	if(F_ON(F_VIEW_SEL_URL,ps_global))
  	  urlp = rfc1738_scan(lp, &n1);
--- 1557,1634 ----
      return(0);
  }
  
+ int
+ incomplete_url(char *up, int n, int delim)
+ {
+   char *line, *line2;
+   int rv = 0, len;
+ 
+   if(*(up + n) != '\0')
+     return 0;
+ 
+   if(delim > 0)
+    return 1;
+ 
+   if(F_ON(F_VIEW_LONG_URL, ps_global)){
+     line = up;
+     if(!strncmp(line, "http://", 7))
+       line += 7;
+     else if(!strncmp(line, "https://", 8))
+       line += 8;
+     if(strchr(line, '/') != NULL && (line = strrchr(line, '/')) != NULL){
+       line++;
+       line2 = strrchr(line, '.');
+       rv = (strpbrk(line,"+#?=&") != NULL) 
+ 	    || (!line2 || line-line2 > 4);
+     }
+   }
+   return rv;
+ }
+ 
  
  int
  url_hilite(long int linenum, char *line, LT_INS_S **ins, void *local)
  {
      register char *lp, *up = NULL, *urlp = NULL,
  		  *weburlp = NULL, *mailurlp = NULL;
!     char *use_this_line, c, *begin_line, *end_line;
!     static int scannextline, delim = -1;
!     int		   n, n1, n2, n3, l, len;
!     int		   we_clear = 0, newhandle = 1, tie_off = 0;
      char	   buf[256], color[256];
      HANDLE_S	  *h;
      URL_HILITE_S  *uh;
  
!     uh = (URL_HILITE_S *) local;
!     if((uh && uh->handlesp && ((h = *(uh->handlesp)) == NULL) || h->key == 0) ||
! 	(!line || !*line) || linenum == 0)
!       scannextline = 0;		/* initialize scannextline */
! 
!     if(scannextline != 0){
! 	up = rfc1738_scan(line, &n1);
! 
! 	/* if we found a url in the current line, but it is not at the beginning of 
! 	 * the next line, or if there is no url in this line, we check if the url 
! 	 * in the previous line continues in this line.
! 	 */
! 
! 	if(line != up){
! 	  if(*uh->handlesp == NULL)
! 	    h = new_handle(uh->handlesp);
! 	  for(h = *uh->handlesp; h->next; h = h->next);	/* get last handle */
! 	  len = h->h.url.path ? strlen(h->h.url.path) : 0;
! 	  use_this_line = (char *) fs_get((len + strlen(line) + 1)*sizeof(char));
! 	  sprintf(use_this_line,"%s%s", (h->h.url.path ? h->h.url.path : ""), line);
! 	  we_clear++;
! 	  newhandle = 0;
! 	}
! 	else
! 	  use_this_line = line;
!     }
!     else
!        use_this_line = line;
! 
!     for(lp = use_this_line; ; lp = up + n){
  	/* scan for all of them so we can choose the first */
  	if(F_ON(F_VIEW_SEL_URL,ps_global))
  	  urlp = rfc1738_scan(lp, &n1);
***************
*** 1503,1508 ****
--- 1638,1647 ----
  	  mailurlp = mail_addr_scan(lp, &n3);
  	
  	if(urlp || weburlp || mailurlp){
+ 	    if(scannextline == 0){
+ 		newhandle++;
+ 		delim = -1;
+ 	    }
  	    up = urlp ? urlp : 
  		  weburlp ? weburlp : mailurlp;
  	    if(up == urlp && weburlp && weburlp < up)
***************
*** 1511,1517 ****
--- 1650,1665 ----
  	      up = mailurlp;
  
  	    if(up == urlp){
+ 		if(delim < 0)
+ 		   delim = up > use_this_line && *(up - 1) == '<';
  		n = n1;
+ 		if(incomplete_url(up,n, delim))
+ 		   scannextline++;
+ 		else{
+ 		   if(scannextline)
+ 		     tie_off++;
+ 		   scannextline = 0;
+ 		}
  		weburlp = mailurlp = NULL;
  	    }
  	    else if(up == weburlp){
***************
*** 1528,1563 ****
  
  	uh = (URL_HILITE_S *) local;
  
! 	h	      = new_handle(uh->handlesp);
! 	h->type	      = URL;
! 	h->h.url.path = (char *) fs_get((n + 10) * sizeof(char));
! 	snprintf(h->h.url.path, n+10, "%s%.*s",
  		weburlp ? "http://" : (mailurlp ? "mailto:" : ""), n, up);
! 	h->h.url.path[n+10-1] = '\0';
  
  	if(handle_start_color(color, sizeof(color), &l, uh->hdr_color))
! 	  ins = gf_line_test_new_ins(ins, up, color, l);
  	else if(F_OFF(F_SLCTBL_ITEM_NOBOLD, ps_global))
! 	  ins = gf_line_test_new_ins(ins, up, url_embed(TAG_BOLDON), 2);
  
  	buf[0] = TAG_EMBED;
  	buf[1] = TAG_HANDLE;
  	snprintf(&buf[3], sizeof(buf)-3, "%d", h->key);
  	buf[sizeof(buf)-1] = '\0';
  	buf[2] = strlen(&buf[3]);
! 	ins = gf_line_test_new_ins(ins, up, buf, (int) buf[2] + 3);
  
  	/* in case it was the current selection */
! 	ins = gf_line_test_new_ins(ins, up + n, url_embed(TAG_INVOFF), 2);
  
  	if(scroll_handle_end_color(color, sizeof(color), &l, uh->hdr_color))
! 	  ins = gf_line_test_new_ins(ins, up + n, color, l);
  	else
! 	  ins = gf_line_test_new_ins(ins, up + n, url_embed(TAG_BOLDOFF), 2);
  
  	urlp = weburlp = mailurlp = NULL;
      }
  
      return(0);
  }
  
--- 1676,1733 ----
  
  	uh = (URL_HILITE_S *) local;
  
! 	if(tie_off){
! 	   tie_off = 0;	/* do only once */
! 	   begin_line = line;
! 	   end_line = line + n - strlen(h->h.url.path);
! 	   fs_give((void **)&h->h.url.path);
! 	   c = *(use_this_line + n);
! 	   *(use_this_line+n) = '\0';
! 	   h->h.url.path = cpystr(use_this_line);
! 	   *(use_this_line+n) = c;
! 	}
! 	else{
! 	   if(newhandle){
! 	     h = new_handle(uh->handlesp);
! 	     h->type = URL;
! 	   }
! 	   begin_line = newhandle ? (we_clear ? line + strlen(line) - strlen(up) 
! 					      : up) : line;
! 	   end_line = newhandle ? begin_line + n : line + strlen(line);
! 	   if(scannextline && h->h.url.path)
! 	     fs_give((void **)&h->h.url.path);
! 	   h->h.url.path = (char *) fs_get((n + 10) * sizeof(char));
! 	   snprintf(h->h.url.path, n+10, "%s%.*s",
  		weburlp ? "http://" : (mailurlp ? "mailto:" : ""), n, up);
! 	   h->h.url.path[n+10-1] = '\0';
! 	}
  
  	if(handle_start_color(color, sizeof(color), &l, uh->hdr_color))
! 	  ins = gf_line_test_new_ins(ins, begin_line, color, l);
  	else if(F_OFF(F_SLCTBL_ITEM_NOBOLD, ps_global))
! 	  ins = gf_line_test_new_ins(ins, begin_line, url_embed(TAG_BOLDON), 2);
  
  	buf[0] = TAG_EMBED;
  	buf[1] = TAG_HANDLE;
  	snprintf(&buf[3], sizeof(buf)-3, "%d", h->key);
  	buf[sizeof(buf)-1] = '\0';
  	buf[2] = strlen(&buf[3]);
! 	ins = gf_line_test_new_ins(ins, begin_line, buf, (int) buf[2] + 3);
  
  	/* in case it was the current selection */
! 	ins = gf_line_test_new_ins(ins, end_line, url_embed(TAG_INVOFF), 2);
  
  	if(scroll_handle_end_color(color, sizeof(color), &l, uh->hdr_color))
! 	  ins = gf_line_test_new_ins(ins, end_line, color, l);
  	else
! 	  ins = gf_line_test_new_ins(ins, end_line, url_embed(TAG_BOLDOFF), 2);
  
  	urlp = weburlp = mailurlp = NULL;
      }
  
+     if(we_clear)
+ 	fs_give((void **)&use_this_line);
+ 
      return(0);
  }
  
***************
*** 1678,1683 ****
--- 1848,1924 ----
  }
  
  
+ /* This filter gives a quote string of a line. It sends its reply back to the
+    calling filter in the tmp_20k_buf variable. This filter replies with
+    the full quote string including tailing spaces if any. It is the
+    responsibility of the calling filter to figure out if thos spaces are
+    useful for that filter or if they should be removed before doing any
+    useful work. For example, color_a_quote does not require the trailing
+    spaces, but gf_wrap does.
+  */
+ int
+ select_quote(long linenum, char *line, LT_INS_S **ins, void *local)
+ {
+      int i, plb, *code;
+      char rqstr[NSTRING] = {'\0'}, buf[NSTRING] = {'\0'};
+      char GLine[NSTRING] = {'\0'}, PLine[NSTRING] = {'\0'};
+      char PPLine[NSTRING] = {'\0'}, NLine[NSTRING] = {'\0'};
+      static char GLine1[NSTRING] = {'\0'};
+      static char PLine1[NSTRING] = {'\0'};
+      static char PPLine1[NSTRING] = {'\0'};
+      static char GLine2[NSTRING] = {'\0'};
+      static char PLine2[NSTRING] = {'\0'};
+      static char PPLine2[NSTRING] = {'\0'};
+      QSTRING_S *qs;
+      int buflen = NSTRING < SIZEOF_20KBUF ? NSTRING - 1: SIZEOF_20KBUF - 1;
+      int who, raw;
+ 
+      code = (int *)local;
+      who = code ? (*code & COLORAQUO) : 0; /* may I ask who is calling? */
+      raw = code ? (*code & RAWSTRING) : 0; /* return raw string */
+      strncpy(GLine, (who ? GLine1 : GLine2), buflen);
+      strncpy(PLine, (who ? PLine1 : PLine2), buflen);
+      strncpy(PPLine, (who ? PPLine1 : PPLine2), buflen);
+ 
+      if (linenum > 0)
+         strncpy(PLine, GLine, buflen);
+ 
+      strncpy(NLine, tmp_20k_buf, buflen);
+ 
+      if (line)
+         strncpy(GLine, line, buflen);
+      else
+         GLine[0] = '\0';
+ 
+      ps_global->list_qstr = default_qstr(ps_global->prefix && *ps_global->prefix 
+ 		? (void *) ps_global->prefix : (void *) ">", 0);
+      plb = line_isblank(ps_global->list_qstr, PLine, GLine, PPLine, NSTRING);
+ 
+      qs = do_quote_match(ps_global->list_qstr, GLine, NLine, PLine, rqstr, NSTRING, plb);
+      if (raw)
+         strncpy(buf, rqstr, NSTRING);
+      else
+         flatten_qstring(qs, buf, NSTRING);
+      if(qs)
+ 	record_quote_string(qs);
+      free_qs(&qs);
+ 
+      /* do not paint an extra level for a line with a >From string at the
+       * begining of it
+       */
+      if (buf[0]){
+        i = strlen(buf);
+        if (strlen(line) >= i + 6 && !strncmp(line+i-1,">From ", 6))
+            buf[i - 1] = '\0';
+      }
+      strncpy(tmp_20k_buf, buf, buflen);
+      if (linenum > 0)
+        strncpy((who ? PPLine1 : PPLine2), PLine, buflen);
+      strncpy((who ? GLine1 : GLine2), GLine, buflen);
+      strncpy((who ? PLine1 : PLine2), PLine, buflen);
+      return 1;
+ }
+ 
  
  #define	UES_LEN	12
  #define	UES_MAX	32
***************
*** 2503,2508 ****
--- 2744,2933 ----
      return(color_pair);
  }
  
+ void
+ interval_free(IVAL_S **ival)
+ {
+   if (!(*ival))
+     return;
+ 
+   if ((*ival)->next)
+     interval_free(&((*ival)->next));
+ 
+   fs_give((void **)(ival));
+ }
+ 
+ IVAL_S *
+ compute_interval (char *string, int endm)
+ {
+   IVAL_S *ival = NULL;
+   regmatch_t pmatch;
+ 
+   if(ps_global->paterror == 0 && 
+      regexec(&ps_global->colorpat, string + endm, 1, &pmatch, 0) == 0){
+        ival = (IVAL_S *) fs_get(sizeof(IVAL_S));
+        ival->start = endm + pmatch.rm_so;
+        ival->end   = endm + pmatch.rm_eo;
+        ival->next  = compute_interval(string, ival->end);
+   }
+   return ival;
+ }
+ 
+ void
+ regex_pattern(char **plist)
+ {
+   int i = 0, j = 0, len = 0;
+   char *pattern = NULL;
+   regex_t preg;
+ 
+   if(ps_global->paterror == 0)
+     regfree(&ps_global->colorpat);
+ 
+   if(plist && *plist && *plist){
+     for (i = 0; plist[i] && plist[i][0]; i++)
+ 	len += strlen(plist[i]) + 1;
+     pattern = (char *) fs_get(len * sizeof(char));
+     *pattern = '\0';
+     for (j = 0; j < i; j++){
+ 	strcat(pattern, plist[j]);
+ 	strcat(pattern, (j < i - 1) ? "|" : "");
+     }
+     if ((ps_global->paterror = regcomp(&preg, pattern, REG_EXTENDED)) != 0)
+       regfree(&preg);
+     else
+        ps_global->colorpat = preg;
+   }
+   if(pattern)
+     fs_give((void **)&pattern);
+ }
+ 
+ LT_INS_S **
+ insert_color_special_text(LT_INS_S **ins, char **p, IVAL_S *ival, int last_end,
+ 			COLOR_PAIR *col)
+ {
+    struct variable *vars = ps_global->vars;
+ 
+    if (ival){
+       *p += ival->start - last_end;
+       ins = gf_line_test_new_ins(ins, *p,  color_embed(col->fg, col->bg),
+ 				   (2 * RGBLEN) + 4);
+       *p += ival->end - ival->start;
+       ins = gf_line_test_new_ins(ins, *p, color_embed(VAR_NORM_FORE_COLOR,
+ 		      VAR_NORM_BACK_COLOR), (2 * RGBLEN) + 4);
+       ins = insert_color_special_text(ins, p, ival->next, ival->end, col);
+    }
+    return ins;
+ }  
+ 
+ int
+ length_color(char *p, int begin_color)
+ {
+   int len = 0, done = begin_color ? 0 : -1;
+   char *orig = p;
+ 
+   while (*p  && done <= 0){
+         switch(*p++){
+            case TAG_HANDLE :
+              p += *p + 1; 
+ 	     done++;
+            break;
+ 
+            case TAG_FGCOLOR :
+            case TAG_BGCOLOR :
+              p += RGBLEN;
+ 	     if (!begin_color)
+ 		done++;  
+            break;
+ 
+            default :
+              break;
+         }
+    }
+    len = p - orig;
+    return len;
+ }
+ 
+ int
+ any_color_in_string(char *p)
+ {
+    int rv = 0;
+    char *orig = p;
+    while (*p && !rv)
+       if (*p++ == TAG_EMBED)
+ 	rv = p - orig;
+    return rv;
+ }
+ 
+ void
+ remove_spaces_ival(IVAL_S **ivalp, char *p)
+ {
+     IVAL_S *ival;
+     int i;
+     if (!ivalp || !*ivalp)
+     return;
+     ival = *ivalp;
+     for (i = 0; isspace((unsigned char) p[ival->start + i]); i++);
+     if (ival->start + i < ival->end)  /* do not do this if match only spaces */
+       ival->start += i;
+     else
+       return;
+     for (i = 0; isspace((unsigned char) p[ival->end - i - 1]); i++);
+      ival->end -= i;
+     if (ival->next)
+ 	remove_spaces_ival(&(ival->next), p);
+ }
+ 
+ int
+ color_this_text(long linenum, char *line, LT_INS_S **ins, void *local)
+ {
+     struct variable *vars = ps_global->vars;
+     COLOR_PAIR *col = NULL;
+     char *p;
+     int i = 0;
+     static char *pattern = NULL;
+ 
+ /*  select_quote(linenum, line, ins, (void *) &i);
+     for (i = 0; tmp_20k_buf[i] != '\0'; i++); */
+     p = line + i;
+ 
+     if(VAR_SPECIAL_TEXT_FORE_COLOR && VAR_SPECIAL_TEXT_BACK_COLOR
+        && (col = new_color_pair(VAR_SPECIAL_TEXT_FORE_COLOR,
+                                 VAR_SPECIAL_TEXT_BACK_COLOR))
+        && !pico_is_good_colorpair(col))
+           free_color_pair(&col);
+ 
+     if(ps_global->VAR_SPECIAL_TEXT && *ps_global->VAR_SPECIAL_TEXT 
+ 	&& **ps_global->VAR_SPECIAL_TEXT && col){
+        IVAL_S *ival;
+        int done = 0, begin_color = 0;
+ 
+         while (!done){
+            if (i = any_color_in_string(p)){
+ 	      begin_color = (begin_color + 1) % 2;
+ 	      if (begin_color){
+                  p[i - 1] = '\0';
+                  ival = compute_interval(p, 0);
+ 		 remove_spaces_ival(&ival, p);
+                  p[i - 1] = TAG_EMBED;
+ 	         ins = insert_color_special_text(ins, &p, ival, 0, col);
+ 	      }
+               for (;*p++ != TAG_EMBED; );
+               p += length_color(p, begin_color);
+            }
+            else{
+               ival = compute_interval(p, 0);
+ 	      remove_spaces_ival(&ival, p);
+ 	      ins = insert_color_special_text(ins, &p, ival, 0, col);
+ 	      done++;
+            }
+ 	   interval_free(&ival);
+            if (!*p)
+              done++;
+         }
+         free_color_pair(&col);
+     }
+ 
+     return 0;
+ }
  
  /*
   * The argument fieldname is something like "Subject:..." or "Subject".
diff -rc alpine-2.11/pith/mailview.h alpine-2.11.I.USE/pith/mailview.h
*** alpine-2.11/pith/mailview.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/mailview.h	2013-12-01 16:38:26.000000000 -0700
***************
*** 30,35 ****
--- 30,41 ----
  #include "../pith/color.h"
  
  
+ typedef struct IVAL {
+    int start;
+    int end;
+    struct IVAL *next;
+ } IVAL_S;
+ 
  /* format_message flags */
  #define	FM_DISPLAY	  0x0001	/* result is headed for display		*/
  #define	FM_NEW_MESS	  0x0002	/* a new message so zero out attachment descrip */
***************
*** 126,131 ****
--- 132,146 ----
  int	 url_hilite(long, char *, LT_INS_S **, void *);
  int	 handle_start_color(char *, size_t, int *, int);
  int	 handle_end_color(char *, size_t, int *);
+ IVAL_S	*compute_interval(char *,  int);
+ void	 remove_spaces_ival(IVAL_S **, char *);
+ void	 interval_free(IVAL_S **);
+ void	 regex_pattern(char **);
+ LT_INS_S  **insert_color_special_text(LT_INS_S **, char **, IVAL_S *,
+                                                        int, COLOR_PAIR *);
+ int	    any_color_in_string(char *);
+ int	    length_color(char *, int);
+ int	    color_this_text(long, char *, LT_INS_S **, void *);
  
  /*
   * BUG:  BELOW IS UNIX/PC ONLY since config'd browser means nothing to webpine
***************
*** 142,147 ****
--- 157,163 ----
  char	   *display_parameters(PARAMETER *);
  char	   *pine_fetch_header(MAILSTREAM *, long, char *, char **, long);
  int         color_signature(long, char *, LT_INS_S **, void *);
+ int	    select_quote(long, char *, LT_INS_S **, void *);
  int	    scroll_handle_start_color(char *, size_t, int *);
  int	    scroll_handle_end_color(char *, size_t, int *, int);
  int         width_at_this_position(unsigned char *, unsigned long);
diff -rc alpine-2.11/pith/Makefile.am alpine-2.11.I.USE/pith/Makefile.am
*** alpine-2.11/pith/Makefile.am	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/Makefile.am	2013-12-01 16:34:54.000000000 -0700
***************
*** 25,31 ****
  	filter.c flag.c folder.c handle.c help.c helpindx.c hist.c icache.c imap.c init.c \
  	keyword.c ldap.c list.c mailcap.c mailcmd.c mailindx.c maillist.c mailview.c \
  	margin.c mimedesc.c mimetype.c msgno.c newmail.c news.c pattern.c pipe.c \
! 	readfile.c remote.c reply.c rfc2231.c save.c search.c sequence.c send.c sort.c \
  	state.c status.c store.c stream.c string.c strlst.c takeaddr.c tempfile.c text.c \
  	thread.c adjtime.c url.c util.c helptext.c smkeys.c smime.c
  
--- 25,31 ----
  	filter.c flag.c folder.c handle.c help.c helpindx.c hist.c icache.c imap.c init.c \
  	keyword.c ldap.c list.c mailcap.c mailcmd.c mailindx.c maillist.c mailview.c \
  	margin.c mimedesc.c mimetype.c msgno.c newmail.c news.c pattern.c pipe.c \
! 	readfile.c remote.c reply.c rfc2231.c rules.c save.c search.c sequence.c send.c sort.c \
  	state.c status.c store.c stream.c string.c strlst.c takeaddr.c tempfile.c text.c \
  	thread.c adjtime.c url.c util.c helptext.c smkeys.c smime.c
  
diff -rc alpine-2.11/pith/Makefile.in alpine-2.11.I.USE/pith/Makefile.in
*** alpine-2.11/pith/Makefile.in	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/Makefile.in	2013-12-01 16:34:54.000000000 -0700
***************
*** 88,94 ****
  	margin.$(OBJEXT) mimedesc.$(OBJEXT) mimetype.$(OBJEXT) \
  	msgno.$(OBJEXT) newmail.$(OBJEXT) news.$(OBJEXT) \
  	pattern.$(OBJEXT) pipe.$(OBJEXT) readfile.$(OBJEXT) \
! 	remote.$(OBJEXT) reply.$(OBJEXT) rfc2231.$(OBJEXT) \
  	save.$(OBJEXT) search.$(OBJEXT) sequence.$(OBJEXT) \
  	send.$(OBJEXT) sort.$(OBJEXT) state.$(OBJEXT) status.$(OBJEXT) \
  	store.$(OBJEXT) stream.$(OBJEXT) string.$(OBJEXT) \
--- 88,94 ----
  	margin.$(OBJEXT) mimedesc.$(OBJEXT) mimetype.$(OBJEXT) \
  	msgno.$(OBJEXT) newmail.$(OBJEXT) news.$(OBJEXT) \
  	pattern.$(OBJEXT) pipe.$(OBJEXT) readfile.$(OBJEXT) \
! 	remote.$(OBJEXT) reply.$(OBJEXT) rfc2231.$(OBJEXT) rules.$(OBJEXT) \
  	save.$(OBJEXT) search.$(OBJEXT) sequence.$(OBJEXT) \
  	send.$(OBJEXT) sort.$(OBJEXT) state.$(OBJEXT) status.$(OBJEXT) \
  	store.$(OBJEXT) stream.$(OBJEXT) string.$(OBJEXT) \
***************
*** 324,330 ****
  	filter.c flag.c folder.c handle.c help.c helpindx.c hist.c icache.c imap.c init.c \
  	keyword.c ldap.c list.c mailcap.c mailcmd.c mailindx.c maillist.c mailview.c \
  	margin.c mimedesc.c mimetype.c msgno.c newmail.c news.c pattern.c pipe.c \
! 	readfile.c remote.c reply.c rfc2231.c save.c search.c sequence.c send.c sort.c \
  	state.c status.c store.c stream.c string.c strlst.c takeaddr.c tempfile.c text.c \
  	thread.c adjtime.c url.c util.c helptext.c smkeys.c smime.c
  
--- 324,330 ----
  	filter.c flag.c folder.c handle.c help.c helpindx.c hist.c icache.c imap.c init.c \
  	keyword.c ldap.c list.c mailcap.c mailcmd.c mailindx.c maillist.c mailview.c \
  	margin.c mimedesc.c mimetype.c msgno.c newmail.c news.c pattern.c pipe.c \
! 	readfile.c remote.c reply.c rfc2231.c rules.c save.c search.c sequence.c send.c sort.c \
  	state.c status.c store.c stream.c string.c strlst.c takeaddr.c tempfile.c text.c \
  	thread.c adjtime.c url.c util.c helptext.c smkeys.c smime.c
  
***************
*** 456,461 ****
--- 456,462 ----
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/url.Po@am__quote@
  @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util.Po@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rules.Po@am__quote@
  
  .c.o:
  @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
diff -rc alpine-2.11/pith/makefile.wnt alpine-2.11.I.USE/pith/makefile.wnt
*** alpine-2.11/pith/makefile.wnt	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/makefile.wnt	2013-12-01 16:34:54.000000000 -0700
***************
*** 44,50 ****
  	init.h keyword.h ldap.h list.h mailcap.h mailcmd.h mailindx.h maillist.h \
  	mailpart.h mailview.h margin.h mimedesc.h mimetype.h msgno.h newmail.h news.h \
  	options.h pattern.h pineelt.h pipe.h readfile.h remote.h remtype.h repltype.h reply.h \
! 	rfc2231.h save.h savetype.h search.h send.h sequence.h signal.h sort.h sorttype.h \
  	state.h status.h store.h stream.h string.h strlst.h takeaddr.h tempfile.h text.h \
  	thread.h url.h user.h util.h
  
--- 44,50 ----
  	init.h keyword.h ldap.h list.h mailcap.h mailcmd.h mailindx.h maillist.h \
  	mailpart.h mailview.h margin.h mimedesc.h mimetype.h msgno.h newmail.h news.h \
  	options.h pattern.h pineelt.h pipe.h readfile.h remote.h remtype.h repltype.h reply.h \
! 	rfc2231.h rules.h save.h savetype.h search.h send.h sequence.h signal.h sort.h sorttype.h \
  	state.h status.h store.h stream.h string.h strlst.h takeaddr.h tempfile.h text.h \
  	thread.h url.h user.h util.h
  
***************
*** 53,59 ****
  	filter.obj flag.obj folder.obj handle.obj help.obj helptext.obj hist.obj icache.obj imap.obj init.obj \
  	keyword.obj ldap.obj list.obj mailcap.obj mailcmd.obj mailindx.obj maillist.obj mailview.obj \
  	margin.obj mimedesc.obj mimetype.obj msgno.obj newmail.obj news.obj pattern.obj pipe.obj \
! 	readfile.obj remote.obj reply.obj rfc2231.obj save.obj search.obj sequence.obj send.obj sort.obj state.obj \
  	status.obj store.obj stream.obj string.obj strlst.obj takeaddr.obj tempfile.obj text.obj \
  	thread.obj adjtime.obj url.obj util.obj
  
--- 53,59 ----
  	filter.obj flag.obj folder.obj handle.obj help.obj helptext.obj hist.obj icache.obj imap.obj init.obj \
  	keyword.obj ldap.obj list.obj mailcap.obj mailcmd.obj mailindx.obj maillist.obj mailview.obj \
  	margin.obj mimedesc.obj mimetype.obj msgno.obj newmail.obj news.obj pattern.obj pipe.obj \
! 	readfile.obj remote.obj reply.obj rfc2231.obj rules.obj save.obj search.obj sequence.obj send.obj sort.obj state.obj \
  	status.obj store.obj stream.obj string.obj strlst.obj takeaddr.obj tempfile.obj text.obj \
  	thread.obj adjtime.obj url.obj util.obj
  
diff -rc alpine-2.11/pith/msgno.c alpine-2.11.I.USE/pith/msgno.c
*** alpine-2.11/pith/msgno.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/msgno.c	2013-12-01 16:39:47.000000000 -0700
***************
*** 933,938 ****
--- 933,941 ----
  	if((*peltp)->pthrd)
  	  fs_give((void **) &(*peltp)->pthrd);
  
+ 	if((*peltp)->firsttext)
+ 	  fs_give((void **) &(*peltp)->firsttext);
+ 
  	if((*peltp)->ice)
  	  free_ice(&(*peltp)->ice);
  
diff -rc alpine-2.11/pith/osdep/color.c alpine-2.11.I.USE/pith/osdep/color.c
*** alpine-2.11/pith/osdep/color.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/osdep/color.c	2013-12-01 16:36:01.000000000 -0700
***************
*** 31,37 ****
  
  #include <system.h>
  #include "./color.h"
! 
  
  
  /*
--- 31,39 ----
  
  #include <system.h>
  #include "./color.h"
! #include "./collate.h"
! #include "../charconv/utf8.h"
! #include "../../c-client/c-client.h"
  
  
  /*
***************
*** 91,93 ****
--- 93,1349 ----
  {
      return(pico_set_colors(col ? col->fg : NULL, col ? col->bg : NULL, flags));
  }
+ 
+ 
+   /* 
+    * Extended Justification support also does not belong here
+    * but otherwise webpine will not build, so we move everything
+    * here. Hopefully this will be the permanent place for these
+    * routines. These routines used to be in pico/word.c
+    */
+ #define NSTRING 256
+ #include "../../include/general.h"
+ 
+ /* Support of indentation of paragraphs */
+ #define is_indent_char(c)  (((c) == '.' || (c) == '}' || (c) == RPAREN || \
+ 			     (c) == '*' || (c) == '+' || is_a_digit(c) || \
+ 			     ISspace(c) || (c) == '-' || \
+ 			     (c) == ']') ? 1 : 0)
+ #define allowed_after_digit(c,word,k)  ((((c) == '.' && \
+ 			     allowed_after_period(next((word),(k))))  ||\
+ 				(c) == RPAREN || (c) == '}' || (c) == ']' ||\
+ 				  ISspace(c) ||  is_a_digit(c) || \
+ 				  ((c) == '-' ) && \
+ 				    allowed_after_dash(next((word),(k)))) \
+ 				? 1 : 0)
+ #define allowed_after_period(c)	 (((c) == RPAREN || (c) == '}' || (c) == ']' ||\
+ 				   ISspace(c) || (c) == '-' || \
+ 				   is_a_digit(c)) ? 1 : 0)
+ #define allowed_after_parenth(c)  (ISspace(c) ? 1 : 0)
+ #define allowed_after_space(c)	  (ISspace(c) ? 1 : 0)
+ #define allowed_after_braces(c)	  (ISspace(c) ? 1 : 0)
+ #define allowed_after_star(c)	 ((ISspace(c) || (c) == RPAREN ||\
+                                        (c) == ']' || (c) == '}') ? 1 : 0)
+ #define allowed_after_dash(c)	  ((ISspace(c) || is_a_digit(c)) ? 1 : 0)
+ #define EOLchar(c)		  (((c) == '.' || (c) == ':' || (c) == '?' ||\
+ 					(c) == '!') ? 1 : 0)
+ 
+ 
+ /* Extended justification support */
+ #define is_cquote(c) ((c) == '>' || (c) == '|' || (c) == ']' || (c) == ':')
+ #define is_cword(c)  ((((c) >= 'a') && ((c) <= 'z')) ||  \
+                      (((c) >= 'A') && ((c) <= 'Z')) || \
+                      (((c) >= '0') && ((c) <= '9')) || \
+                       ((c) == ' ') || ((c) == '?') || \
+                       ((c) == '@') || ((c) == '.') || \
+                       ((c) == '!') || ((c) == '\'') || \
+                       ((c) == ',') || ((c) == '\"') ? 1 : 0)
+ #define isaquote(c)   ((c) == '\"' || (c) == '\'')
+ #define is8bit(c)     ((((int) (c)) & 0x80) ? 1 : 0)
+ #define iscontrol(c)  (iscntrl(((int) (c)) & 0x7f) ? 1 : 0)
+ #define forbidden(c)  (((c) == '\"') || ((c) == '\'') || ((c) == '$') ||\
+                        ((c) == ',')  || ((c) == '.')  || ((c) == '-') ||\
+                        ((c) == LPAREN) || ((c) == '/')|| ((c) == '`') ||\
+                        ((c) == '{') || ((c) == '\\') || (iscontrol((c))) ||\
+                        (((c) >= '0')  && ((c) <= '9')) || ((c) == '?'))
+ #define is_cletter(c)  ((((c) >= 'a') && ((c) <= 'z'))) ||\
+                        ((((c) >= 'A') && ((c) <= 'Z'))||\
+                       is8bit(c))
+ #define is_cnumber(c) ((c) >= '0' && (c) <= '9')
+ #define allwd_after_word(c) (((c) == ' ') || ((c) == '>') || is_cletter(c))
+ #define allwd_after_qsword(c)  (((c) != '\\') && ((c) != RPAREN))
+ #define before(word,i) (((i) > 0) ? (word)[(i) - 1] : 0)
+ #define next(w,i) ((((w)[(i)]) != 0) ? ((w)[(i) + 1]) : 0)
+ #define now(w,i)  ((w)[(i)])
+ #define is_qsword(c)  (((c) == ':') || ((c) == RPAREN) ? 1 : 0)
+ #define is_colon(c)   (((c) == ':') ? 1 : 0)
+ #define is_rarrow(c)  (((c) == '>') ? 1 : 0)
+ #define is_tilde(c)   (((c) == '~') ? 1 : 0)
+ #define is_dash(c)    (((c) == '-') ? 1 : 0)
+ #define is_pound(c)   (((c) == '#') ? 1 : 0)
+ #define is_a_digit(c) ((((c) >= '0') && ((c) <= '9')) ? 1 : 0)
+ #define is_allowed(c)  (is_cquote(c) || is_cword(c) || is_dash(c) || \
+                        is_pound(c))
+ #define qs_allowed(a)  (((a)->qstype != qsGdb) && ((a)->qstype != qsProg))
+ 
+ /* Internal justification functions */
+ QSTRING_S *is_quote(char **, char *, int);
+ QSTRING_S *qs_normal_part(QSTRING_S *);
+ QSTRING_S *qs_remove_trailing_spaces(QSTRING_S *);
+ QSTRING_S *trim_qs_from_cl(QSTRING_S *, QSTRING_S *, QSTRING_S *);
+ QSTRING_S *fix_qstring(QSTRING_S *, QSTRING_S *, QSTRING_S *);
+ QSTRING_S *fix_qstring_allowed(QSTRING_S *, QSTRING_S *, QSTRING_S *);
+ QSTRING_S *qs_add(char **, char *, QStrType, int, int, int, int);
+ QSTRING_S *remove_qsword(QSTRING_S *);
+ QSTRING_S *do_raw_quote_match(char **, char *, char *, char *, QSTRING_S **, QSTRING_S **);
+ void	 free_qs(QSTRING_S **);
+ int      word_is_prog(char *);
+ int      qstring_is_normal(QSTRING_S *);
+ int      exists_good_part(QSTRING_S *);
+ int      strcmp_qs(char *, char *);
+ int      count_levels_qstring(QSTRING_S *);
+ int      same_qstring(QSTRING_S *, QSTRING_S *);
+ int	 isaword(char *,int ,int);
+ int	 isamailbox(char *,int ,int);
+ int	 double_check_qstr(char *);
+ 
+ int
+ word_is_prog(char *word)
+ {
+   static char *list1[] = {"#include",
+ 			"#define",
+ 			"#ifdef",
+ 			"#ifndef",
+ 			"#elif",
+ 			"#if",
+ 			NULL};
+   static char *list2[] = {"#else",
+ 			"#endif",
+ 			 NULL};
+   int i, j = strlen(word), k, rv = 0;
+ 
+   for(i = 0; rv == 0 && list1[i] && (k = strlen(list1[i])) && k < j; i++)
+      if(!strncmp(list1[i], word, k) && ISspace(word[k]))
+        rv++;
+ 
+      if(rv)
+        return rv;
+ 
+    for(i = 0; rv == 0 && list2[i] && (k = strlen(list2[i])) && k <= j; i++)
+      if(!strncmp(list2[i], word, k) && (!word[k] || ISspace(word[k])))
+        rv++;
+ 
+    return rv;
+ }
+ 
+ /*
+  * This function creates a qstring pointer with the information that
+  * is_quote handles to it.
+  * Parameters:
+  * qs         - User supplied quote string
+  * word       - The line of text that the user is trying to read/justify
+  * beginw     - Where we need to start copying from
+  * endw       - Where we end copying
+  * offset     - Any offset in endw that we need to account for
+  * typeqs     - type of the string to be created
+  * neednext   - boolean, indicating if we need to compute the next field
+  *              of leave it NULL 
+  * 
+  * It is a mistake to call this function if beginw >= endw + offset.
+  * Please note the equality sign in the above inequality (this is because
+  * we always assume that qstring->value != "").
+  */ 
+ QSTRING_S *
+ qs_add(char **qs, char word[NSTRING], QStrType typeqs, int beginw, int endw, 
+ 	int offset, int neednext)
+ {
+     QSTRING_S *qstring, *nextqs;
+     int i;
+  
+     qstring = (QSTRING_S *) malloc (sizeof(QSTRING_S));
+     memset (qstring, 0, sizeof(QSTRING_S));
+     qstring->qstype = qsNormal;
+ 
+     if (beginw == 0){
+ 	beginw = endw + offset;
+ 	qstring->qstype = typeqs;
+     }
+ 
+     nextqs = neednext ? is_quote(qs, word+beginw, 1) : NULL;
+ 
+     qstring->value = (char *) malloc((beginw+1)*sizeof(char));
+     strncpy(qstring->value, word, beginw);
+     qstring->value[beginw] = '\0';
+ 
+     qstring->next = nextqs;
+ 
+     return qstring;
+ }
+ 
+ int
+ qstring_is_normal(QSTRING_S *cl)
+ { 
+    for (;cl && (cl->qstype == qsNormal); cl = cl->next);
+    return cl ? 0 : 1;
+ }
+ 
+ /*
+  * Given a quote string, this function returns the part that is the leading
+  * normal part of it. (the normal part is the part that is tagged qsNormal,
+  * that is to say, the one that is not controversial at all (like qsString
+  * for example).
+  */
+ QSTRING_S *
+ qs_normal_part(QSTRING_S *cl)
+ {
+ 
+   if (!cl)            /* nothing in, nothing out */
+      return cl;
+ 
+   if (cl->qstype != qsNormal)
+      free_qs(&cl);
+ 
+   if (cl)
+      cl->next = qs_normal_part(cl->next);
+ 
+   return cl;
+ }
+ 
+ /*
+  * this function removes trailing spaces from a quote string, but leaves the
+  * last one if there are trailing spaces
+  */ 
+ QSTRING_S *
+ qs_remove_trailing_spaces(QSTRING_S *cl)
+ {
+   QSTRING_S *rl = cl;
+   if (!cl)            /* nothing in, nothing out */
+      return cl;
+ 
+   if (cl->next)
+      cl->next = qs_remove_trailing_spaces(cl->next);
+   else{
+     if (value_is_space(cl->value))
+        free_qs(&cl);
+     else{
+        int i, l;
+        i = l = strlen(cl->value) - 1;
+        while (cl->value && cl->value[i]
+         && ISspace(cl->value[i]))
+            i--;
+         i += (i < l) ? 2 : 1;
+         cl->value[i] = '\0';
+     }
+   }
+   return cl;
+ }
+ 
+ /*
+  * This function returns if two strings are the same quote string.
+  * The call is not symmetric. cl must preceed the line nl. This function
+  * should be called for comparing the last part of cl and nl.
+  */
+ int
+ strcmp_qs(char *valuecl, char *valuenl)
+ {
+    int j;
+ 
+    for (j = 0; valuecl[j] && (valuecl[j] == valuenl[j]); j++);
+    return !strcmp(valuecl, valuenl)
+ 	 || (valuenl[j] && value_is_space(valuenl+j)
+ 			&& value_is_space(valuecl+j)
+ 			&& strlenis(valuecl+j) >= strlenis(valuenl+j))
+ 	 || (!valuenl[j] && value_is_space(valuecl+j));
+ }
+ 
+ int
+ count_levels_qstring(QSTRING_S *cl)
+ {
+   int count;
+   for (count = 0; cl ; count++, cl = cl->next);
+ 
+   return count;
+ }
+ 
+ int
+ value_is_space(char *value)
+ {
+   for (; value && *value && ISspace(*value); value++);
+ 
+   return value && *value ? 0 : 1;
+ }
+ 
+ void
+ free_qs(QSTRING_S **cl)
+ {
+   if (!(*cl))
+     return;
+ 
+   if ((*cl)->next)
+     free_qs(&((*cl)->next));
+ 
+   (*cl)->next = (QSTRING_S *) NULL;
+ 
+   if ((*cl)->value)
+      free((void *)(*cl)->value);
+    (*cl)->value = (char *) NULL;
+    free((void *)(*cl));
+    *cl = (QSTRING_S *) NULL;
+ }
+ 
+ /*
+  * This function returns the number of agreements between
+  * cl and nl. The call is not symmetric. cl must be the line
+  * preceding nl.
+  */
+ int
+ same_qstring(QSTRING_S *cl, QSTRING_S *nl)
+ {
+    int same = 0, done = 0;
+ 
+    for (;cl && nl && !done; cl = cl->next, nl = nl->next)
+        if (cl->qstype == nl->qstype
+          && (!strcmp(cl->value, nl->value)
+            || (!cl->next && strcmp_qs(cl->value, nl->value))))
+ 	same++;
+       else
+ 	done++;
+    return same;
+ }
+ 
+ QSTRING_S *
+ trim_qs_from_cl(QSTRING_S *cl, QSTRING_S *nl, QSTRING_S *pl)
+ {
+     QSTRING_S *cqstring = pl ? pl : nl;
+     QSTRING_S *tl = pl ? pl : nl;
+     int p, c;
+ 
+     if (qstring_is_normal(tl))
+ 	return tl;
+ 
+     p = same_qstring(pl ? pl : cl, pl ? cl : nl);
+ 
+     for (c = 1; c < p; c++, cl = cl->next, tl = tl->next);
+ 
+     /*
+      * cl->next and tl->next differ, it may be because cl->next does not
+      * exist or tl->next does not exist or simply both exist but are
+      * different. In this last case, it may be that cl->next->value is made
+      * of spaces. If this is the case, tl advances once more.
+      */
+ 
+     if (tl->next){
+ 	if (cl && cl->next && value_is_space(cl->next->value))
+ 	   tl = tl->next;
+ 	if (tl->next)
+ 	   free_qs(&(tl->next));
+     }
+ 
+     if (!p)
+        free_qs(&cqstring);
+ 
+     return cqstring;
+ }
+ 
+ /* This function trims cl so that it returns a real quote string based
+  * on information gathered from the previous and next lines. pl and cl are
+  * also trimmed, but that is done in another function, not here.
+  */
+ QSTRING_S *
+ fix_qstring(QSTRING_S *cl, QSTRING_S *nl, QSTRING_S *pl)
+ {
+    QSTRING_S *cqstring = cl, *nqstring = nl, *pqstring = pl;
+    int c, n;
+ 
+    if (qstring_is_normal(cl))
+      return cl;
+ 
+    c = count_levels_qstring(cl);
+    n = same_qstring(cl,nl);
+ 
+    if (!n){  /* no next line or no agreement with next line */
+       int p = same_qstring(pl, cl); /* number of agreements between pl and cl */
+       QSTRING_S *tl;              /* test line */
+ 
+       /*
+        * Here p <= c, so either p < c or p == c. If p == c, we are done,
+        * and return cl. If not, there are two cases, either p == 0 or
+        * 0 < p < c. In the first case, we do not have enough evidence
+        * to return anything other than the normal part of cl, in the second
+        * case we can only return p levels of cl.
+        */
+ 
+    if (p == c)
+ 	tl = cqstring;
+    else{
+       if (p){
+ 	   for (c = 1; c < p; c++)
+ 	      cl = cl->next;
+ 	   free_qs(&(cl->next));
+ 	   tl = cqstring;
+       }
+       else{
+ 	   int done = 0;
+ 	   QSTRING_S *al = cl;  /* another line */ 
+ 	/*
+ 	 * Ok, we really don't have enough evidence to return anything,
+ 	 * different from the normal part of cl, but it could be possible
+ 	 * that we may want to accept the not-normal part, so we better
+ 	 * make an extra test to determine what needs to be freed
+ 	 */
+ 	  while (pl && cl && cl->qstype == pl->qstype
+ 		    && !strucmp(cl->value, pl->value)){
+ 		cl = cl->next;
+ 		pl = pl->next;
+ 	  }
+           if (pl && cl && cl->qstype == pl->qstype
+                        && strcmp_qs(pl->value, cl->value))
+                cl = cl->next;  /* next level differs only in spaces */
+           while (!done){
+                while (cl && cl->qstype == qsNormal)
+                    cl = cl->next;
+                if (cl){
+                   if ((cl->qstype == qsString)
+                       && (cl->value[strlen(cl->value) - 1] == '>'))
+                      cl = cl->next;
+                   else done++;
+                }
+                else done++;
+           }
+           if (al == cl){
+              free_qs(&(cl));
+              tl = cl;
+           }
+           else {
+              while (al && (al->next != cl))
+                 al = al->next;
+              cl = al;
+              if (cl && cl->next)
+                 free_qs(&(cl->next));
+              tl = cqstring;
+           }
+        }
+       }
+       return tl;
+    }
+    if (n + 1 < c){  /* if there are not enough agreements */
+       int p = same_qstring(pl, cl); /* number of agreement between pl and cl */
+       QSTRING_S *tl; /* test line */
+        /*
+         * There's no way we can use cl in this case, but we can use
+         * part of cl, this is if pl does not have more agreements
+         * with cl.
+         */ 
+       if (p == c)
+        tl = cqstring;
+       else{
+        int m = p < n ? n : p;
+        for (c = 1; c < m; c++){
+          pl = pl ? pl->next : (QSTRING_S *) NULL;
+          nl = nl ? nl->next : (QSTRING_S *) NULL;
+          cl = cl->next;
+        }
+        if (p == n && pl && pl->next && nl && nl->next
+           && ((cl->next->qstype == pl->next->qstype)
+              || (cl->next->qstype == nl->next->qstype))
+           && (strcmp_qs(cl->next->value, pl->next->value)
+              || strcmp_qs(pl->next->value, cl->next->value)
+              || strcmp_qs(cl->next->value, nl->next->value)
+              || strcmp_qs(nl->next->value, cl->next->value)))
+          cl = cl->next;        /* next level differs only in spaces */
+        if (cl->next)
+           free_qs(&(cl->next));
+        tl = cqstring;
+       }
+       return tl;
+    }
+    if (n + 1 == c){
+       int p = same_qstring(pl, cl);
+       QSTRING_S *tl; /* test line */
+ 
+       /*
+        * p <= c, so p <= n+1, which means p < n + 1 or p == n + 1.
+        * If p < n + 1, then p <= n.
+        * so we have three possibilities:
+        *       p == n + 1 or p == n or p < n.
+        * In the first case we copy p == n + 1 == c levels, in the second
+        * and third case we copy n levels, and check if we can copy the
+        * n + 1 == c level.
+        */
+       if (p == n + 1)      /* p == c, in the above sense of c */
+        tl = cl;          /* use cl, this is enough evidence */
+       else{
+        for (c = 1; c < n; c++)
+          cl = cl->next;
+        /*
+         * Here c == n, we only have one more level of cl, and at least one
+         * more level of nl
+         */
+        if (cl->next->qstype == qsNormal)
+           cl = cl->next;
+        if (cl->next)
+           free_qs(&(cl->next));
+        tl = cqstring;
+       }
+       return tl;
+    }
+    if (n == c)  /* Yeah!!! */
+      return cqstring;
+ }
+ 
+ QSTRING_S *
+ fix_qstring_allowed(QSTRING_S *cl, QSTRING_S *nl, QSTRING_S *pl)
+ {
+   if(!cl)
+     return (QSTRING_S *) NULL;
+ 
+   if (qs_allowed(cl))
+       cl->next = fix_qstring_allowed(cl->next, (nl ? nl->next : NULL),
+                        (pl ? pl->next : NULL));
+   else
+      if((nl && cl->qstype == nl->qstype) || (pl && cl->qstype == pl->qstype)
+       || (!nl && !pl))
+       free_qs(&cl);
+   return cl;
+ }
+ 
+ /*
+  * This function flattens the quote string returned to us by is_quote. A
+  * crash in this function implies a bug elsewhere.
+  */
+ void
+ flatten_qstring(QSTRING_S *qs, char *buff, int bufflen)
+ { 
+    int i, j; 
+    if(!buff || bufflen <= 0)
+      return;
+ 
+    for (i = 0; qs; qs = qs->next)
+      for (j = 0; i < bufflen - 1
+                &&  (qs->value[j]) && (buff[i++] = qs->value[j]); j++);
+   buff[i] = '\0';
+ }
+ 
+ extern int list_len;
+ 
+ 
+ int
+ double_check_qstr(char *q)
+ {
+   if(!q || !*q)
+     return 0;
+ 
+   return (*q == '#') ? 1 : 0;
+ }
+ 
+ /*
+  * Given a string, we return the position where the function thinks that
+  * the quote string is over, if you are ever thinking of fixing something,
+  * you got to the right place. Memory freed by caller. Experience shows
+  * that it only makes sense to initialize memory when we need it, not at
+  * the start of this function.
+  */
+ QSTRING_S *
+ is_quote (char **qs,char *word, int been_here)
+ {
+    int i = 0, j, nxt, prev, finished = 0, offset;
+    unsigned char c;
+    QSTRING_S *qstring = (QSTRING_S *) NULL;
+ 
+    if (word == NULL || word[0] == '\0')
+       return (QSTRING_S *) NULL;
+ 
+    while (!finished){
+        /*
+         * Before we apply our rules, let's advance past the quote string
+         * given by the user, this will avoid not recognition of the
+         * user's indent string and application of the arbitrary rules
+         * below. Notice that this step may bring bugs into this
+         * procedure, but these bugs will only appear if the indent string
+         * is really really strange and the text to be justified
+         * cooperates a lot too, so in general this will not be a problem.
+         * If you are concerned about this bug, simply remove the
+         * following lines after this comment and before the "switch"
+         * command below and use a more normal quote string!.
+         */
+        for(j = 0; j < list_len; j++){
+ 	  if(!double_check_qstr(qs[j])){
+ 	    i += advance_quote_string(qs[j], word, i);
+ 	    if (!word[i]) /* went too far? */
+ 	      return qs_add(qs, word, qsNormal, 0, i, 0, 0);
+ 	  }
+ 	  else
+ 	    break;
+        }
+ 
+       switch (c = (unsigned char) now(word,i)){
+        case NBSP:
+        case TAB :
+        case ' ' : { QSTRING_S *nextqs, *d;
+ 
+                    for (; ISspace(word[i]); i++); /* FIX ME */
+                    nextqs = is_quote(qs,word+i, 1);
+                  /*
+                   * Merge qstring and nextqs, since this is an artificial
+                   * separation, unless nextqs is of different type.
+                   * What this means in practice is that if
+                   * qs->qstype == qsNormal and qs->next != NULL, then
+                   * qs->next->qstype != qsNormal.
+                   *
+                   * Can't use qs_add to merge because it could lead
+                   * to an infinite loop (e.g a line "^ ^").
+                   */
+                    i += nextqs && nextqs->qstype == qsNormal
+                        ? strlen(nextqs->value) : 0;
+                    qstring = (QSTRING_S *) malloc (sizeof(QSTRING_S));
+                    memset (qstring, 0, sizeof(QSTRING_S));
+                    qstring->value = (char *) malloc((i+1)*sizeof(char));
+                    strncpy(qstring->value, word, i);
+                    qstring->value[i] = '\0';
+                    qstring->qstype   = qsNormal;
+ 		   if(nextqs && nextqs->qstype == qsNormal){
+ 			d = nextqs->next;
+ 			nextqs->next = NULL;
+ 			qstring->next = d;
+ 			free_qs(&nextqs);
+ 		   }
+ 		   else
+ 		     qstring->next     = nextqs;
+ 
+ 		   return qstring;
+ 		 }
+                 break;
+        case RPAREN:            /* parenthesis ')' */
+                     if ((i != 0) || ((i == 0) && been_here))
+                        i++;
+                     else
+                        if (i == 0)
+                           return qs_add(qs, word, qsChar, i, i, 1, 1);
+                        else
+                           finished++;
+                    break;
+ 
+        case ':':                       /* colon */
+        case '~': nxt = next(word,i);
+                  if ((is_tilde(c) && (nxt == '/'))
+                        || (is_colon(c) && !is_cquote(nxt)
+                                        && !is_cword(nxt) && nxt != RPAREN))
+                     finished++;
+                  else if (is_cquote(c)
+                        || is_cquote(nxt)
+                        || (c != '~' && nxt == RPAREN)
+                        || (i != 0 && ISspace(nxt))
+                        || is_cquote(prev = before(word,i))
+                        || (ISspace(prev) && !is_tilde(c))
+                        || (is_tilde(c) && nxt != '/'))
+                      i++;
+                  else if (i == 0 && been_here)
+                       return qs_add(qs, word, qsChar, i, i, 1, 1);
+                  else
+                       finished++;
+                 break;
+ 
+        case '<' :
+        case '=' :
+        case '-' : offset = is_cquote(nxt = next(word,i)) ? 2
+                             : (nxt == c && is_cquote(next(word,i+1))) ? 3 : -1;
+ 
+                   if (offset > 0)
+                       return qs_add(qs, word, qsString, i, i, offset, 1);
+                   else
+                       finished++;
+                 break;
+ 
+        case '[' :
+        case '+' :      /* accept +>, *> */
+        case '*' :  if (is_rarrow(nxt = next(word, i)) || /* stars */
+                      (ISspace(nxt) && is_rarrow(next(word,i+1))))
+                         i++;
+                    else
+                       finished++;
+                 break;
+ 
+        case '^' :
+        case '!' :
+        case '%' : if (next(word,i) != c)
+                      return qs_add(qs, word, qsChar, i, i+1, 0, 1);
+                   else
+                      finished++;
+                 break;
+ 
+        case '_' : if(ISspace(next(word, i)))
+                        return qs_add(qs, word, qsChar, i, i+1, 0, 1);
+                   else
+                      finished++;
+                   break;
+ 
+        case '#' : { QStrType qstype = qsChar;
+                     if((nxt = next(word, i)) != c){
+                        if(isdigit((int) nxt))
+                          qstype = qsGdb;
+                        else
+                          if(word_is_prog(word))
+                             qstype = qsProg;
+                        return qs_add(qs, word, qstype, i, i+1, 0, 1);
+                     }
+                     else
+                        finished++;
+                     break;
+                   }
+ 
+          default:
+            if (is_cquote(c))
+               i++;
+            else if (is_cletter(c)){
+                for (j = i; (is_cletter(nxt = next(word,j)) || is_cnumber(nxt))
+                            && !(ISspace(nxt));j++);
+                  /*
+                   * The whole reason why we are splitting the quote
+                   * string is so that we will be able to accept quote
+                   * strings that are strange in some way. Here we got to
+                   * a point in which a quote string might exist, but it
+                   * could be strange, so we need to create a "next" field
+                   * for the quote string to warn us that something
+                   * strange is coming. We need to confirm if this is a
+                   * good choice later. For now we will let it pass.
+                   */
+                  if (isaword(word,i,j) || isamailbox(word,i,j)){
+                    int offset;
+                    QStrType qstype;
+ 
+                    offset = (is_cquote(c = next(word,j))
+                             || (c == RPAREN)) ? 2
+                                : ((ISspace(c)
+                                     && is_cquote(next(word,j+1))) ? 3 : -1);
+ 
+                    qstype = (is_cquote(c) || (c == RPAREN))
+                      ? (is_qsword(c) ? qsWord : qsString)
+                      : ((ISspace(c) && is_cquote(next(word,j+1)))
+                         ? (is_qsword(next(word,j+1))
+                            ? qsWord : qsString)
+                                  : qsString);
+ 
+                    /*
+                     * qsWords are valid quote strings only when
+                     * they are followed by text.
+                     */
+                    if (offset > 0 && qstype == qsWord &&
+                        !allwd_after_qsword(now(word,j + offset)))
+                        offset = -1;
+ 
+                    if (offset > 0)
+                        return qs_add(qs, word, qstype, i, j, offset, 1);
+                  }
+                  finished++;
+            }
+            else{
+ 	       if(i > 0)
+ 		return qs_add(qs, word, qsNormal, 0, i, 0, 1);
+ 	       else if(!forbidden(c))
+                   return qs_add(qs, word, qsChar, 0, 1, 0, 1);
+                else    /* chao pescao */
+                   finished++;
+            }
+        break;
+       }  /* End Switch */
+     }  /* End while */
+     if (i > 0)
+        qstring = qs_add(qs, word, qsNormal, 0, i, 0, 0);
+     return qstring;
+ }
+ 
+ int
+ isaword(char word[NSTRING], int i, int j)
+ {
+   return i <= j && is_cletter(word[i]) ?
+           (i < j ? isaword(word,i+1,j) : 1) : 0;
+ }
+ 
+ int
+ isamailbox(char word[NSTRING], int i, int j)
+ {
+   return i <= j && (is_cletter(word[i]) || is_a_digit(word[i])
+                  || word[i] == '.')
+        ? (i < j ? isamailbox(word,i+1,j) : 1) : 0;
+ }
+ 
+ /*
+    This routine removes the last part that is qsword or qschar that is not
+    followed by a normal part. This means that if a qsword or qschar is
+    followed by a qsnormal (or qsstring), we accept the qsword (or qschar)
+    as part of a quote string.
+  */
+ QSTRING_S *
+ remove_qsword(QSTRING_S *cl)
+ {
+      QSTRING_S *np = cl;
+      QSTRING_S *cp = np;               /* this variable trails cl */
+ 
+      while(1){
+         while (cl && cl->qstype == qsNormal)
+             cl = cl->next;
+ 
+         if (cl){
+          if (((cl->qstype == qsWord) || (cl->qstype == qsChar))
+                && !exists_good_part(cl)){
+              if (np == cl)     /* qsword or qschar at the beginning */
+                 free_qs(&cp);
+              else{
+                 while (np->next != cl)
+                     np = np->next;
+                 free_qs(&(np->next));
+             }
+             break;
+          }
+          else
+             cl = cl->next;
+         }
+         else
+          break;
+     }
+     return cp;
+ }
+ 
+ int
+ exists_good_part (QSTRING_S *cl)
+ {
+    return (cl ? (((cl->qstype != qsWord) && (cl->qstype != qsChar)
+                  && qs_allowed(cl) && !value_is_space(cl->value))
+               ? 1 : exists_good_part(cl->next))
+ 	      : 0);
+ }
+ 
+ int
+ line_isblank(char **q, char *GLine, char *NLine, char *PLine, int buflen)
+ {
+     int n = 0;
+     QSTRING_S *cl;
+     char qstr[NSTRING];
+ 
+     cl = do_raw_quote_match(q, GLine, NLine, PLine, NULL, NULL);
+ 
+     flatten_qstring(cl, qstr, NSTRING);
+ 
+     free_qs(&cl);
+ 
+     for(n = strlen(qstr); n < buflen && GLine[n]; n++)
+        if(!ISspace((unsigned char) GLine[n]))
+          return(FALSE);
+ 
+     return(TRUE);
+ }
+ 
+ QSTRING_S *
+ do_raw_quote_match(char **q, char *GLine, char *NLine, char *PLine, QSTRING_S **nlp, QSTRING_S **plp)
+ {
+    QSTRING_S *cl, *nl = NULL, *pl = NULL;
+    char nbuf[NSTRING], pbuf[NSTRING], buf[NSTRING];
+    int emptypl = 0, emptynl = 0;
+ 
+    if (!(cl = is_quote(q, GLine, 0)))  /* if nothing in, nothing out */
+       return cl;
+ 
+    nl = is_quote(q, NLine, 0);         /* Next Line     */
+    if (nlp) *nlp = nl;
+    pl = is_quote(q, PLine, 0);         /* Previous Line */
+    if (plp) *plp = pl;
+    /*
+     * If there's nothing in the preceeding or following line
+     * there is not enough information to accept it or discard it. In this
+     * case it's likely to be an isolated line, so we better accept it
+     * if it does not look like a word.
+     */ 
+    flatten_qstring(pl, pbuf, NSTRING);
+    emptypl = (!PLine || !PLine[0] ||
+                (pl && value_is_space(pbuf)) && !PLine[strlen(pbuf)]) ? 1 : 0;
+    if (emptypl){
+       flatten_qstring(nl, nbuf, NSTRING);
+       emptynl = (!NLine || !NLine[0] ||
+                (nl && value_is_space(nbuf) && !NLine[strlen(nbuf)])) ? 1 : 0;
+       if (emptynl){
+        cl = remove_qsword(cl);
+        if((cl = fix_qstring_allowed(cl, NULL, NULL)) != NULL)
+           cl = qs_remove_trailing_spaces(cl);
+        free_qs(&nl);
+        free_qs(&pl);
+        if(nlp) *nlp = NULL;
+        if(plp) *plp = NULL;
+ 
+        return cl;
+       }
+    }
+ 
+    /*
+     * If either cl, nl or pl contain suspicious characters that may make
+     * them (or not) be quote strings, we need to fix them, so that the
+     * next pass will be done correctly.
+     */
+ 
+    cl = fix_qstring(cl, nl, pl);
+    nl = trim_qs_from_cl(cl, nl, NULL);
+    pl = trim_qs_from_cl(cl, NULL, pl);
+    if((cl = fix_qstring_allowed(cl, nl, pl)) != NULL){
+      nl = trim_qs_from_cl(cl, nl, NULL);
+      pl = trim_qs_from_cl(cl, NULL, pl);
+    }
+    else{
+      free_qs(&nl);
+      free_qs(&pl);
+    }
+    if(nlp) 
+       *nlp = nl;
+    else
+      free_qs(&nl);
+    if(plp)
+      *plp = pl;
+    else
+      free_qs(&pl);
+    return cl;
+ }
+ 
+ QSTRING_S *
+ do_quote_match(char **q, char *GLine, char *NLine, char *PLine, char *rqstr, 
+ int rqstrlen, int plb)
+ {
+     QSTRING_S *cl, *nl = NULL, *pl = NULL;
+     int c, n, p,i, j, NewP, NewC, NewN, clength, same = 0;
+     char nbuf[NSTRING], pbuf[NSTRING], buf[NSTRING];
+ 
+     if(rqstr)
+       *rqstr = '\0';
+ 
+     /* if nothing in, nothing out */
+     cl = do_raw_quote_match(q, GLine, NLine, PLine, &nl, &pl);
+     if(cl == NULL){
+       free_qs(&nl);
+       free_qs(&pl);
+       return cl;
+     }
+ 
+     flatten_qstring(cl, rqstr, rqstrlen);
+     flatten_qstring(cl,  buf, NSTRING);
+     flatten_qstring(nl, nbuf, NSTRING);
+     flatten_qstring(pl, pbuf, NSTRING);
+ 
+     /*
+      * Once upon a time, is_quote used to return the length of the quote
+      * string that it had found. One day, not long ago, black hand came
+      * and changed all that, and made is_quote return a quote string
+      * divided in several fields, making the algorithm much more
+      * complicated. Fortunately black hand left a few comments in the
+      * source code to make it more understandable. Because of this change
+      * we need to compute the lengths of the quote strings separately
+      */
+      c =  buf &&  buf[0] ? strlen(buf)  : 0;
+      n = nbuf && nbuf[0] ? strlen(nbuf) : 0;
+      p = pbuf && pbuf[0] ? strlen(pbuf) : 0;
+      /*
+       * When quote strings contain only blank spaces (ascii code 32) the
+       * above count is equal to the length of the quote string, but if
+       * there are TABS, the length of the quote string as seen by the user
+       * is different than the number that was just computed.  Because of
+       * this we demand a recount (hmm.. unless you are in Florida, where
+       * recounts are forbidden)
+       */
+      NewP = strlenis(pbuf);
+      NewC = strlenis(buf);
+      NewN = strlenis(nbuf);
+ 
+      /*
+       * For paragraphs with spaces in the first line, but no space in the
+       * quote string of the second line, we make sure we choose the quote
+       * string without a space at the end of it.
+       */
+      if ((NLine && !NLine[0])
+        && ((PLine && !PLine[0])
+             || (((same = same_qstring(pl, cl)) != 0)
+                        && (same != count_levels_qstring(cl)))))
+        cl = qs_remove_trailing_spaces(cl);
+      else
+        if (NewC > NewN){
+        int agree = 0;
+          for (j = 0; (j < n) && (GLine[j] == NLine[j]); j++);
+        clength = j;
+        /* clength is the common length in which Gline and Nline agree */
+        /* j < n means that they do not agree fully */
+        /* GLine = "   \tText"
+           NLine = "   Text" */
+        if(j == n)
+           agree++;
+        if (clength < n){ /* see if buf and nbuf are padded with spaces and tabs */
+           for (i = clength; i < n && ISspace(NLine[i]); i++);
+           if (i == n){/* padded NLine until the end of spaces? */
+              for (i = clength; i < c && ISspace(GLine[i]); i++);
+                if (i == c) /* Padded CLine until the end of spaces? */
+                   agree++;
+           }
+        }
+        if (agree){
+ 	  for (j = clength; j < c && ISspace(GLine[j]); j++);
+ 	  if (j == c){
+       /*
+        * If we get here, it means that the current line has the same
+        * quote string (visually) than the next line, but both of them
+        * are padded with different amount of TABS or spaces at the end.
+        * The current line (GLine) has more spaces/TABs than the next
+        * line. This is the typical situation that is found at the
+        * begining of a paragraph. We need to check this, however, by
+        * checking the previous line. This avoids that we confuse
+        * ourselves with being in the last line of a paragraph.
+        * Example when it should not free_qs(cl)
+        * "    Text in Paragraph 1" (PLine)
+        * "    Text in Paragraph 1" (GLine)
+        * "  Other Paragraph Number 2" (NLine)
+        *
+        * Example when it should free_qs(cl):
+        * ":) "                (PLine) p = 3, j = 3
+        * ":)   Text"          (GLine) c = 5
+        * ":) More text"       (NLine) n = 3
+        *
+        * Example when it should free_qs(cl):
+        * ":) "                (PLine) p =  3, j = 3
+        * ":) > > >   Text"    (GLine) c = 11
+        * ":) > > > More text" (NLine) n =  9
+        *
+        * Example when it should free_qs(cl):
+        * ":) :) "             (PLine) p =  6, j = 3
+        * ":) > > >   Text"    (GLine) c = 11
+        * ":) > > > More text" (NLine) n =  9
+        *
+        * Example when it should free_qs(cl):
+        * ":) > > >     "      (PLine) p = 13, j = 11
+        * ":) > > >   Text"    (GLine) c = 11
+        * ":) > > > More text" (NLine) n =  9
+        *
+        * The following example is very interesting. The "Other Text"
+        * line below should free the quote string an make it equal to the
+        * quote string of the line below it, but any algorithm trying
+        * to advance past that line should make it stop there, so
+        * we need one more check, to check the raw quote string and the
+        * processed quote string at the same time.
+        * FREE qs in this example.
+        * "   Some Text"       (PLine) p = 3, j = 0
+        * "\tOther Text"       (GLine) c = 1
+        * "   More Text"       (NLine) n = 3
+        *
+        */
+            for (j = 0; (j < p) && (GLine[j] == PLine[j]); j++);
+             if ((p != c || j != p) && NLine[n])
+                if(!get_indent_raw_line(q, PLine, nbuf, NSTRING, p, plb)
+                  || NewP + strlenis(nbuf) != NewC){
+                  free_qs(&cl);
+                  free_qs(&pl);
+                  return nl;
+                }
+             }
+          }
+        }
+ 
+      free_qs(&nl);
+      free_qs(&pl);
+ 
+      return cl;
+ }
+ 
+ /*
+  * Given a line, an initial position, and a quote string, we advance the
+  * current line past the quote string, including arbitraty spaces
+  * contained in the line, except that it removes trailing spaces. We do
+  * not handle TABs, if any, contained in the quote string. At least not
+  * yet.
+  *
+  * Arguments: q - quote string
+  *          l - a line to process
+  *          i - position in the line to start processing. i = 0 is the
+  *              begining of that line.
+  */
+ int
+ advance_quote_string(char *q, char l[NSTRING], int i)
+ {
+     int n = 0, j = 0, is = 0, es = 0;
+     int k, m, p, adv;
+     char qs[NSTRING] = {'\0'};
+     if(!q || !*q)
+       return(0);
+     for (p = strlen(q); (p > 0) && (q[p - 1] == ' '); p--, es++);
+     if (!p){  /* string contains only spaces */
+        for (k = 0; ISspace(l[i + k]); k++);
+        k -= k % es;
+        return k;
+     }
+     for (is = 0; ISspace(q[is]); is++); /* count initial spaces */ 
+     for (m = 0 ; is + m < p ; m++)
+       qs[m] = q[is + m];   /* qs = quote string without any space at the end */
+                      /* advance as many spaces as there are at the begining */
+     for (k = 0; ISspace(l[i + j]); k++, j++);
+                       /* now find the visible string in the line */
+     for (m = 0; qs[m] && l[i + j] == qs[m]; m++, j++);
+     if (!qs[m]){      /* no match */
+       /*
+        * So far we have advanced at least "is" spaces, plus the visible
+        * string "qs". Now we need to advance the trailing number of
+        * spaces "es". If we can do that, we have found the quote string.
+        */
+       for (p = 0; ISspace(l[i + j + p]); p++);
+       adv = advance_quote_string(q, l, i + j + ((p < es) ? p : es));
+       n = ((p < es) ? 0 : es) + k + m + adv;
+     }
+     return n;
+ }
+ 
+ /*
+  * This function returns the effective length in screen of the quote
+  * string. If the string contains a TAB character, it is added here, if
+  * not, the length returned is the length of the string
+  */
+ int strlenis(char *qstr)
+ {
+   int i, rv = 0; 
+   for (i = 0; qstr && qstr[i]; i++)
+        rv += ((qstr[i] == TAB) ? (~rv & 0x07) + 1 : 1);
+   return rv;
+ }
+ 
+ int
+ is_indent (char word[NSTRING], int plb)
+ {
+   int i = 0, finished = 0, c, nxt, j, k, digit = 0, bdigits = -1, alpha = 0;
+ 
+    if (!word || !word[0])
+       return i;
+ 
+    for (i = 0, j = 0; ISspace(word[i]); i++, j++);
+    while ((i < NSTRING - 2) && !finished){
+       switch (c = now(word,i)){
+           case NBSP:
+           case TAB :
+           case ' ' : for (; ISspace(word[i]); i++);
+                      if (!is_indent_char(now(word,i)))
+                        finished++;
+                   break;
+ 
+            case '+' :
+            case '.' :
+            case ']' :
+            case '*' :
+            case '}' :
+            case '-' :
+            case RPAREN:
+                   nxt = next(word,i);
+                   if ((c == '.' && allowed_after_period(nxt) && alpha)
+                        || (c == '*' && allowed_after_star(nxt))
+                        || (c == '}' && allowed_after_braces(nxt))
+                        || (c == '-' && allowed_after_dash(nxt))
+                        || (c == '+' && allowed_after_dash(nxt))
+                        || (c == RPAREN && allowed_after_parenth(nxt))
+                        || (c == ']' && allowed_after_parenth(nxt)))
+                      i++;
+                   else
+                      finished++;
+                   break;
+ 
+             default : if (is_a_digit(c) && plb){
+                         if (bdigits < 0)
+                            bdigits = i;  /* first digit */
+                         for (k = i; is_a_digit(now(word,k)); k++);
+                         if (k - bdigits > 2){ /* more than 2 digits? */
+                            i = bdigits; /* too many! */
+                            finished++;
+                         }
+                         else{
+                            if(allowed_after_digit(now(word,k),word,k)){
+                              alpha++;
+                              i = k;
+                            }
+                            else{
+                              i = bdigits;
+                              finished++;
+                            }
+                         }
+                       }
+                       else
+                         finished++;
+                    break;
+ 
+       }
+    }
+    if (i == j)
+       i = 0;  /* there must be something more than spaces in an indent string */
+    return i;
+ }
+ 
+ int
+ get_indent_raw_line(char **q, char *GLine, char *buf, int buflen, int k, int plb)
+ {
+      int i, j;
+      char testline[1024];
+ 
+      if(k > 0){
+ 	for(j = 0; GLine[j] != '\0'; j++){
+ 	   testline[j] = GLine[j];
+ 	   testline[j+1] = '\0';
+ 	   if(strlenis(testline) >= strlenis(buf))
+ 	     break;
+ 	}
+ 	k = ++j;     /* reset k */
+      }
+      i = is_indent(GLine+k, plb);
+ 
+      for (j = 0; j < i && j < buflen && (buf[j] = GLine[j + k]); j++);
+      buf[j] = '\0';
+ 
+      return i;
+ }
+ 
+ /* support for remembering quote strings across messages */
+ char **allowed_qstr = NULL;
+ int list_len = 0;
+ 
+ void
+ free_allowed_qstr(void)
+ {
+   int i;
+   char **q = allowed_qstr;
+ 
+   if(q == NULL)
+     return;
+ 
+   for(i = 0; i < list_len; i++)
+     fs_give((void **)&q[i]);
+ 
+   fs_give((void **)q);
+   list_len = 0;
+ }
+ 
+ void
+ add_allowed_qstr(void *q, int type)
+ {
+   int i;
+ 
+   if(allowed_qstr == NULL){
+      allowed_qstr =  malloc(sizeof(char *));
+      list_len = 0;
+   }
+ 
+   if(type == 0){
+     allowed_qstr[list_len] = malloc((1+strlen((char *)q))*sizeof(char));
+     strcpy(allowed_qstr[list_len], (char *)q);
+   }
+   else
+     allowed_qstr[list_len] = (char *) ucs4_to_utf8_cpystr((UCS *)q);
+ 
+   fs_resize((void **)&allowed_qstr, (++list_len + 1)*sizeof(char *));
+   allowed_qstr[list_len] = NULL;
+ }
+ 
+ void
+ record_quote_string (QSTRING_S *qs)
+ {
+   int i, j, k;
+ 
+   for(; qs && qs->value; qs = qs->next){
+     j = 0;
+     for (; ;){
+        k = j;
+        for(i = 0; i < list_len; i++){
+           j += advance_quote_string(allowed_qstr[i], qs->value, j);
+           for(; ISspace(qs->value[j]); j++);
+        }
+        if(k == j)
+ 	 break;
+     }
+     if(qs->value[j] != '\0')
+ 	add_allowed_qstr((void *)(qs->value + j), 0);
+   }
+ }
+ 
+ /* type utf8: code 0; ucs4: code 1. */
+ char **
+ default_qstr(void *q, int type)
+ {
+   if(allowed_qstr == NULL)
+     add_allowed_qstr(q, type);
+ 
+   return allowed_qstr;
+ }
+ 
diff -rc alpine-2.11/pith/osdep/color.h alpine-2.11.I.USE/pith/osdep/color.h
*** alpine-2.11/pith/osdep/color.h	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/osdep/color.h	2013-12-01 16:36:01.000000000 -0700
***************
*** 17,22 ****
--- 17,40 ----
  #ifndef PITH_OSDEP_COLOR_INCLUDED
  #define PITH_OSDEP_COLOR_INCLUDED
  
+ /*
+  * struct that will help us determine what the quote string of a line
+  * is. The "next" field indicates the presence of a possible continuation.
+  * The idea is that if a continuation fails, we free it and check for the
+  * remaining structure left
+  */
+ 
+ typedef enum {qsNormal, qsString, qsWord, qsChar, qsGdb, qsProg, qsText} QStrType;
+ 
+ typedef struct QSTRING {
+ 	char		*value;		/* possible quote string */
+ 	QStrType	 qstype;	/* type of quote string  */
+ 	struct QSTRING	*next;		/* possible continuation */
+ } QSTRING_S;
+ 
+ #define UCH(c) ((unsigned char) (c))
+ #define NBSP UCH('\240')
+ #define ISspace(c) (UCH(c) == ' ' || UCH(c) == TAB || UCH(c) == NBSP)
  
  #define RGBLEN 11
  #define MAXCOLORLEN 11			/* longest string a color can be */
***************
*** 93,98 ****
  char	   *pico_get_last_bg_color(void);
  char	   *color_to_canonical_name(char *);
  int	    pico_count_in_color_table(void);
! 
  
  #endif /* PITH_OSDEP_COLOR_INCLUDED */
--- 111,124 ----
  char	   *pico_get_last_bg_color(void);
  char	   *color_to_canonical_name(char *);
  int	    pico_count_in_color_table(void);
! int 	    is_indent(char *, int);
! int	    get_indent_raw_line (char **, char *, char *, int, int, int);
! int  	    line_isblank(char **, char *, char *, char *, int);
! int	    strlenis(char *);
! int	    value_is_space(char *);
! int	    advance_quote_string(char *, char *, int);
! void	    free_allowed_qstr(void);
! void	    add_allowed_qstr(void *, int);
! void	    record_quote_string (QSTRING_S *);
  
  #endif /* PITH_OSDEP_COLOR_INCLUDED */
diff -rc alpine-2.11/pith/pattern.c alpine-2.11.I.USE/pith/pattern.c
*** alpine-2.11/pith/pattern.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/pattern.c	2013-12-01 16:34:08.000000000 -0700
***************
*** 1756,1762 ****
  	    SortOrder def_sort;
  	    int       def_sort_rev;
  
! 	    if(decode_sort(p, &def_sort, &def_sort_rev) != -1){
  		action->sort_is_set = 1;
  		action->sortorder = def_sort;
  		action->revsort   = (def_sort_rev ? 1 : 0);
--- 1756,1762 ----
  	    SortOrder def_sort;
  	    int       def_sort_rev;
  
! 	    if(decode_sort(p, &def_sort, &def_sort_rev, 0) != -1){
  		action->sort_is_set = 1;
  		action->sortorder = def_sort;
  		action->revsort   = (def_sort_rev ? 1 : 0);
***************
*** 5483,5488 ****
--- 5483,5497 ----
  		break;
  	      
  	      case '#':
+ #ifndef _WINDOWS
+ 		if(!struncmp(patfolder, "#md/", 4)
+ 		       || !struncmp(patfolder, "#mc/", 4)){
+ 		  maildir_file_path(patfolder, tmp1, sizeof(tmp1));
+ 		  if(!strcmp(patfolder, stream->mailbox))
+ 		     match++;
+ 		  break;
+ 		}
+ #endif
  	        if(!strcmp(patfolder, stream->mailbox))
  		  match++;
  
***************
*** 7903,7909 ****
      int           we_cancel = 0, width;
      CONTEXT_S	 *save_context = NULL;
      char	  buf[MAX_SCREEN_COLS+1], sbuf[MAX_SCREEN_COLS+1];
!     char         *save_ref = NULL;
  #define	FILTMSG_MAX	30
  
      if(!stream)
--- 7912,7918 ----
      int           we_cancel = 0, width;
      CONTEXT_S	 *save_context = NULL;
      char	  buf[MAX_SCREEN_COLS+1], sbuf[MAX_SCREEN_COLS+1];
!     char         *save_ref = NULL, *save_dstfldr = NULL, *save_dstfldr2 = NULL;
  #define	FILTMSG_MAX	30
  
      if(!stream)
***************
*** 7937,7942 ****
--- 7946,7961 ----
      if(F_OFF(F_QUELL_FILTER_MSGS, ps_global))
        we_cancel = busy_cue(buf, NULL, 0);
  
+ #ifndef _WINDOWS
+     if(!struncmp(dstfldr, "#md/", 4) || !struncmp(dstfldr, "#mc/", 4)){  
+ 	char tmp1[MAILTMPLEN];
+ 	maildir_file_path(dstfldr, tmp1, sizeof(tmp1));
+ 	save_dstfldr2 = dstfldr;
+ 	save_dstfldr = cpystr(tmp1);
+ 	dstfldr = save_dstfldr;
+    }
+ #endif
+ 
      if(!is_absolute_path(dstfldr)
         && !(save_context = default_save_context(ps_global->context_list)))
        save_context = ps_global->context_list;
***************
*** 8000,8005 ****
--- 8019,8029 ----
      if(we_cancel)
        cancel_busy_cue(buf[0] ? 0 : -1);
  
+     if(save_dstfldr){
+ 	fs_give((void **)&save_dstfldr);
+ 	dstfldr = save_dstfldr2;
+     }
+ 
      return(buf[0] != '\0');
  }
  
diff -rc alpine-2.11/pith/pineelt.h alpine-2.11.I.USE/pith/pineelt.h
*** alpine-2.11/pith/pineelt.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/pineelt.h	2013-12-01 16:39:47.000000000 -0700
***************
*** 40,45 ****
--- 40,46 ----
  	PINETHRD_S  *pthrd;
  	PARTEX_S    *exceptions;
  	ICE_S       *ice;
+ 	char	    *firsttext;
  	/* per-message pine state bits */
  	unsigned int hidden:1;
  	unsigned int excluded:1;
diff -rc alpine-2.11/pith/pine.hlp alpine-2.11.I.USE/pith/pine.hlp
*** alpine-2.11/pith/pine.hlp	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/pine.hlp	2013-12-01 16:41:04.000000000 -0700
***************
*** 89,94 ****
--- 89,95 ----
      ALPINE_VERSION
      ALPINE_REVISION
      ALPINE_COMPILE_DATE
+     ALPINE_PATCHLEVEL
      ALPINE_TODAYS_DATE
      C_CLIENT_VERSION
      _LOCAL_FULLNAME_
***************
*** 159,164 ****
--- 160,173 ----
  </DIV>
  
  <P>
+ This version was modified from its original source code. More information 
+ about some of the patches applied to this version can be found <A HREF="h_patches">here</A>.
+ <!--chtml if pinemode="running"-->
+ The patch level of this version, including creation date of the patch is:
+ <!--#echo var=ALPINE_PATCHLEVEL-->.
+ <!--chtml endif-->
+ 
+ <P>
  Alpine is an &quot;Alternatively Licensed Program for Internet
  News and Email&quot; produced until 2008 by the University of Washington.
  It is intended to be an easy-to-use program for
***************
*** 3194,3202 ****
--- 3203,3213 ----
  <li><a href="h_config_alt_role_menu">FEATURE: <!--#echo var="FEAT_alternate-role-menu"--></a>
  <li><a href="h_config_force_low_speed">FEATURE: <!--#echo var="FEAT_assume-slow-link"--></a>
  <li><a href="h_config_auto_read_msgs">FEATURE: <!--#echo var="FEAT_auto-move-read-msgs"--></a>
+ <li><a href="h_config_auto_read_msgs_rules">FEATURE: <!--#echo var="FEAT_auto-move-read-msgs-using-rules"--></a>
  <li><a href="h_config_auto_open_unread">FEATURE: <!--#echo var="FEAT_auto-open-next-unread"--></a>
  <li><a href="h_config_auto_unselect">FEATURE: <!--#echo var="FEAT_auto-unselect-after-apply"--></a>
  <li><a href="h_config_auto_unzoom">FEATURE: <!--#echo var="FEAT_auto-unzoom-after-apply"--></a>
+ <li><a href="h_config_circular_tab">FEATURE: <!--#echo var="FEAT_enable-circular-tab"--></a>
  <li><a href="h_config_auto_zoom">FEATURE: <!--#echo var="FEAT_auto-zoom-after-select"--></a>
  <li><a href="h_config_use_boring_spinner">FEATURE: <!--#echo var="FEAT_busy-cue-spinner-only"--></a>
  <li><a href="h_config_check_mail_onquit">FEATURE: <!--#echo var="FEAT_check-newmail-when-quitting"--></a>
***************
*** 3296,3301 ****
--- 3307,3313 ----
  <li><a href="h_config_full_auto_expunge">FEATURE: <!--#echo var="FEAT_expunge-without-confirm-everywhere"--></a>
  <li><a href="h_config_no_fcc_attach">FEATURE: <!--#echo var="FEAT_fcc-without-attachments"--></a>
  <li><a href="h_config_force_arrow">FEATURE: <!--#echo var="FEAT_force-arrow-cursor"--></a>
+ <li><a href="h_config_ignore_size">FEATURE: <!--#echo var="FEAT_ignore-size-changes"--></a>
  <li><a href="h_config_forward_as_attachment">FEATURE: <!--#echo var="FEAT_forward-as-attachment"--></a>
  <li><a href="h_config_preserve_field">FEATURE: <!--#echo var="FEAT_preserve-original-fields"--></a>
  <li><a href="h_config_quell_empty_dirs">FEATURE: <!--#echo var="FEAT_quell-empty-directories"--></a>
***************
*** 3309,3314 ****
--- 3321,3327 ----
  <li><a href="h_config_add_ldap">FEATURE: <!--#echo var="FEAT_ldap-result-to-addrbook-add"--></a>
  <li><a href="h_config_maildrops_preserve_state">FEATURE: <!--#echo var="FEAT_maildrops-preserve-state"--></a>
  <li><a href="h_config_mark_fcc_seen">FEATURE: <!--#echo var="FEAT_mark-fcc-seen"--></a>
+ <li><a href="h_config_mark_for_group">FEATURE: <!--#echo var="FEAT_mark-for-me-in-group"--></a>
  <li><a href="h_config_mark_for_cc">FEATURE: <!--#echo var="FEAT_mark-for-cc"--></a>
  <li><a href="h_config_mulnews_as_typed">FEATURE: <!--#echo var="FEAT_mult-newsrc-hostnames-as-typed"--></a>
  <li><a href="h_config_news_uses_recent">FEATURE: <!--#echo var="FEAT_news-approximates-new-status"--></a>
***************
*** 3511,3516 ****
--- 3524,3530 ----
  <li><a href="h_config_image_viewer">OPTION: <!--#echo var="VAR_image-viewer"--></a>
  <li><a href="h_config_inbox_path">OPTION: <!--#echo var="VAR_inbox-path"--></a>
  <li><a href="h_config_archived_folders">OPTION: <!--#echo var="VAR_incoming-archive-folders"--></a>
+ <li><a href="h_config_sleep">OPTION: <!--#echo var="VAR_sleep-interval-length"--></a>
  <li><a href="h_config_incoming_interv">OPTION: <!--#echo var="VAR_incoming-check-interval"--></a>
  <li><a href="h_config_incoming_second_interv">OPTION: <!--#echo var="VAR_incoming-check-interval-secondary"--></a>
  <li><a href="h_config_incoming_list">OPTION: <!--#echo var="VAR_incoming-check-list"--></a>
***************
*** 3563,3568 ****
--- 3577,3583 ----
  <li><a href="h_config_print_cat">OPTION: <!--#echo var="VAR_personal-print-category"--></a>
  <li><a href="h_config_print_command">OPTION: <!--#echo var="VAR_personal-print-command"--></a>
  <li><a href="h_config_post_char_set">OPTION: <!--#echo var="VAR_posting-character-set"--></a>
+ <li><a href="h_config_special_text_to_color">OPTION: <!--#echo var="VAR_h_config_special_text_to_color"--></a>
  <li><a href="h_config_postponed_folder">OPTION: <!--#echo var="VAR_postponed-folder"--></a>
  <li><a href="h_config_print_font_char_set">OPTION: Print-Font-Char-Set</a>
  <li><a href="h_config_print_font_name">OPTION: Print-Font-Name</a>
***************
*** 3591,3599 ****
--- 3606,3616 ----
  <li><a href="h_config_sending_filter">OPTION: <!--#echo var="VAR_sending-filters"--></a>
  <li><a href="h_config_sendmail_path">OPTION: <!--#echo var="VAR_sendmail-path"--></a>
  <li><a href="h_config_signature_color">OPTION: Signature Color</a>
+ <li><a href="h_config_special_text_color">OPTION: Special Text Color</a>
  <li><a href="h_config_signature_file">OPTION: <!--#echo var="VAR_signature-file"--></a>
  <li><a href="h_config_smtp_server">OPTION: <!--#echo var="VAR_smtp-server"--></a>
  <li><a href="h_config_sort_key">OPTION: <!--#echo var="VAR_sort-key"--></a>
+ <li><a href="h_config_thread_sort_key">OPTION: <!--#echo var="VAR_thread-sort-key"--></a>
  <li><a href="h_config_speller">OPTION: <!--#echo var="VAR_speller"--></a>
  <li><a href="h_config_sshcmd">OPTION: <!--#echo var="VAR_ssh-command"--></a>
  <li><a href="h_config_ssh_open_timeo">OPTION: <!--#echo var="VAR_ssh-open-timeout"--></a>
***************
*** 4453,4458 ****
--- 4470,4479 ----
  	message in the thread was sent to you as a cc:. This symbol will only show up if
  	the feature
  	&quot;<A HREF="h_config_mark_for_cc"><!--#echo var="FEAT_mark-for-cc"--></A>&quot; is turned on (which is the default).
+   <LI> &quot;.&quot; for messages that were sent to you as part of a group message, regardless
+        of if all addresses in the To: field are yours or not. This symbol will only show up if
+ 	the feature
+ 	&quot;<A HREF="h_config_mark_for_group"><!--#echo var="FEAT_mark-for-me-in-group"--></A>&quot; is turned on (which is the default).
    <LI> &quot;X&quot; for selected.  You have selected at least one message in the thread by using the
  	&quot;select&quot; command.  (Some systems may optionally allow selected
  	messages to be denoted by the index line being displayed in bold
***************
*** 4612,4617 ****
--- 4633,4642 ----
  	message was sent to you as a cc:. This symbol will only show up if
  	the feature
  	&quot;<A HREF="h_config_mark_for_cc"><!--#echo var="FEAT_mark-for-cc"--></A>&quot; is turned on (which is the default).
+   <LI> &quot;.&quot; for messages that were sent to you as part of a group message, regardless
+        of if all addresses in the To: field are yours or not. This symbol will only show up if
+ 	the feature
+ 	&quot;<A HREF="h_config_mark_for_group"><!--#echo var="FEAT_mark-for-me-in-group"--></A>&quot; is turned on (which is the default).
    <LI> &quot;X&quot; for selected.  You have selected the message by using the
  	&quot;select&quot; command.  (Some systems may optionally allow selected
  	messages to be denoted by the index line being displayed in bold
***************
*** 5526,5531 ****
--- 5551,5713 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ======= h_thread_index_sort_arrival =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Arrival</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Arrival</H1>
+ 
+ The <EM>Arrival</EM> sort option arranges threads according to the last 
+ time that a message was added to it. In this order the last thread 
+ contains the most recent message in the folder.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_date =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Date</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Date</H1>
+ 
+ The <EM>Date</EM> sort option in the THREAD&nbsp;INDEX screen sorts
+ threads by the date in which messages were sent. The thread containing the
+ last message in this order is displayed last.
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_subj =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Subject</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Subject</H1>
+ 
+ The <EM>Subject</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_ordsubj =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: OrderedSubject</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: OrderedSubject</H1>
+ 
+ The <EM>OrderedSubject</EM> sort option in the THREAD&nbsp;INDEX screen is
+ the same as sorting by <A HREF="h_thread_index_sort_subj">Subject</A>.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_thread =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Thread</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Thread</H1>
+ 
+ The <EM>Thread</EM> sort option in the THREAD&nbsp;INDEX screen sorts all 
+ messages by the proposed algorithm by Crispin and Murchison. In this 
+ method of sorting once threads have been isolated they are sorted by the 
+ date of their parents, or if that is missing, the first message in that 
+ thread.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_from =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: From</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: From</H1>
+ 
+ The <EM>From</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_size =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Size</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Size</H1>
+ 
+ The <EM>Size</EM> sort option sorts threads by their size (the number
+ of messages in the thread). This could be used to find conversations
+ where no reply has been sent by any of the participants in the thread
+ (e.g. those whose length is equal to one). Longer threads appear
+ below shorter ones.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_score =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Score</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Score</H1>
+ 
+ The <EM>Score</EM> sort option means that threads are sorted according to 
+ the maximum score of a message in that thread. A thread all of whose 
+ messages contain a smaller score than a message in some other thread is 
+ placed in an earlier place in the list of messages for that folder; that 
+ is, threads with the highest scores appear at the bottom of the index 
+ list.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_to =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: To</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: To</H1>
+ 
+ The <EM>To</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ======= h_thread_index_sort_cc =======
+ <HTML>
+ <HEAD>
+ <TITLE>SORT OPTION: Cc</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>SORT OPTION: Cc</H1>
+ 
+ The <EM>Cc</EM> sort option has not been defined yet.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ======= h_index_cmd_whereis =======
  <HTML>
  <HEAD>
***************
*** 6749,6754 ****
--- 6931,6976 ----
  &quot;type the character ^&quot;.
  
  <P>
+ This version of Alpine contains an enhanced algorithm for justification,
+ which allows you to justify text that contains more complicated quote
+ strings. This algorithm is based on pragmatics, rather than on a theory,
+ and seems to work well with most messages. Below you will find technical
+ information on how this algorithm works.
+ 
+ <P>
+ When justifying, Alpine goes through each line of the text and tries to
+ determine for each line what the quote string of that line is. The quote
+ string you provided is always recognized. Among other characters 
+ recognized is &quot;&gt;&quot;.
+ 
+ <P>
+ Some other constructions of quote strings are recognized only if they
+ appear enough in the text. For example &quot;Peter :&quot; is only
+ recognized if it appears in two consecutive lines.
+ 
+ <P> 
+ Additionaly, Alpine recognizes indent-strings and justifies text in a
+ paragraph to the right of indent-string, padding with spaces if necessary.
+ An indent string is one which you use to delimit elements of a list. For
+ example, if you were to write a list of groceries, one may write:
+ 
+ <UL>
+ <LI> Fruit
+ <LI> Bread
+ <LI> Eggs
+ </UL>
+ 
+ <P> 
+ In this case the character &quot;*&quot; is the indent-string. Aline
+ recognizes numbers (0, 1, 2.5, etc) also as indent-strings, and certain
+ combinations of spaces, periods, and parenthesis. In any case, numbers are
+ recognized <B>ONLY</B> if the line preceeding the given line is empty or
+ ends in one of the characters &quot;.&quot; or &quot;:&quot;.
+ In addition to the explanation of what constitutes a paragraph above, a
+ new paragraph is recognized when an indent-string is found in it (and
+ validated according to the above stated rules).
+ 
+ <P>
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
***************
*** 18311,18316 ****
--- 18533,18539 ----
  <A HREF="h_config_index_format">&quot;<!--#echo var="VAR_index-format"-->&quot;</A> option,
  in the <A HREF="h_config_reply_intro">&quot;<!--#echo var="VAR_reply-leadin"-->&quot;</A> option,
  in signature files,
+ in the <A HREF="h_config_reply_leadin_rules">&quot;new-rules&quot; option</A>,
  in template files used in
  <A HREF="h_rules_roles">&quot;roles&quot;</A>, and in the folder name
  that is the target of a Filter Rule.
***************
*** 18323,18329 ****
  <P>
  <P>
  
! <H1><EM>Tokens Available for all Cases (except Filter Rules)</EM></H1>
  
  <DL>
  <DT>SUBJECT</DT>
--- 18546,18552 ----
  <P>
  <P>
  
! <H1><EM>Tokens Available for all Cases (except Filter Rules or in some cases for new-rules)</EM></H1>
  
  <DL>
  <DT>SUBJECT</DT>
***************
*** 18356,18361 ****
--- 18579,18593 ----
  For example, &quot;mailbox@domain&quot;.
  </DD>
  
+ <DT>ADDRESSTO</DT>
+ <DD>
+ This is similar to the &quot;TO&quot; token, only it is always the
+ email address of all people listed in the TO: field of the messages. Addresses
+ are separated by a blank space. Example, &quot;mailbox@domain&quot; when
+ the e-mail message contains only one person in the To: field, or
+ &quot;peter@flintstones.com president@world.com&quot;.
+ </DD>
+ 
  <DT>MAILBOX</DT>
  <DD>
  This is the same as the &quot;ADDRESS&quot; except that the 
***************
*** 18403,18408 ****
--- 18635,18649 ----
  message's &quot;Cc:&quot; header field.
  </DD>
  
+ <DT>ADDRESSCC</DT>
+ <DD>
+ This is similar to the &quot;CC&quot; token, only it is always the
+ email address of all people listed in the Cc: field of the messages. Addresses
+ are separated by a blank space. Example: &quot;mailbox@domain&quot; when
+ the e-mail message contains only one person in the Cc: field, or
+ &quot;peter@flintstones.com president@world.com&quot;.
+ </DD>
+ 
  <DT>RECIPS</DT>
  <DD>
  This token represents the personal names (or email addresses if the names
***************
*** 18411,18416 ****
--- 18652,18665 ----
  the message's &quot;Cc:&quot; header field.
  </DD>
  
+ <DT>ADDRESSRECIPS</DT>
+ <DD>
+ This token represent the e-mail addresses of the people in the To: and
+ Cc: fields, exactly in that order separated by a space. It is almost obtained
+ by concatenating the ADDRESSTO and ADDRESSCC tokens.
+ </DD>
+ 
+ 
  <DT>NEWSANDRECIPS</DT>
  <DD>
  This token represents the newsgroups from the
***************
*** 18756,18762 ****
  The first character is either blank,
  a '*' for message marked Important, or a '+' indicating a message
  addressed directly to you (as opposed to your having received it via a
! mailing list, for example).
  When the feature
  &quot;<A HREF="h_config_mark_for_cc"><!--#echo var="FEAT_mark-for-cc"--></A>&quot;
  is set, if the first character would have been
--- 19005,19015 ----
  The first character is either blank,
  a '*' for message marked Important, or a '+' indicating a message
  addressed directly to you (as opposed to your having received it via a
! mailing list, for example). The symbol '.' will be used
! for messages that were sent to you as part of a group message, regardless
! of if all addresses in the To: field are yours or not. This symbol will only show up if
! the feature
! &quot;<A HREF="h_config_mark_for_group"><!--#echo var="FEAT_mark-for-me-in-group"--></A>&quot; is turned on (which is the default).
  When the feature
  &quot;<A HREF="h_config_mark_for_cc"><!--#echo var="FEAT_mark-for-cc"--></A>&quot;
  is set, if the first character would have been
***************
*** 18892,18897 ****
--- 19145,19158 ----
  <P>
  </DD>
  
+ <DT>SIZETHREAD</DT>
+ <DD>
+ This token represents the total size of the thread for a collapsed thread
+ or the size of the branch for an expanded thread. The field is omitted for
+ messages that are not top of threads nor branches and it defaults to
+ the SIZE token when your folders is not sorted by thread.
+ </DD>
+ 
  <DT>SIZENARROW</DT>
  <DD>
  This token represents the total size, in bytes, of the message.
***************
*** 19507,19512 ****
--- 19768,19845 ----
  </DL>
  
  <P>
+ <H1><EM>Tokens Available Only for New-Rules</EM></H1>
+ 
+ <DL>
+ <DT>FOLDER</DT>
+ <DD>
+ Name of the folder where the rule will be applied
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>COLLECTION</DT>
+ <DD>
+ Name of the collection list where the rule will be applied.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>ROLE</DT>
+ <DD>
+ Name of the Role used to reply a message.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>BCC</DT>
+ <DD>
+ Not implemented yet, but it will be implemented in future versions. It will
+ be used for <A HREF="h_config_compose_rules">compose</A>
+ <A HREF="h_config_reply_rules">reply</A>
+ <A HREF="h_config_forward_rules">forward</A>
+ rules.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>LCC</DT>
+ <DD>
+ This is the value of the Lcc: field at the moment that you start the composition.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>FORWARDFROM</DT>
+ <DD>
+ This corresponds to the personal name (or address if there's no personal
+ name) of the person who sent the message that you are forwarding.
+ </DD>
+ </DL>
+ 
+ <DL>
+ <DT>FORWARDADDRESS</DT>
+ <DD>
+ This is the address of the person that sent the message that you
+ are forwarding.
+ </DD>
+ </DL>
+ 
+ 
+ 
+ 
+ <DL>
+ <DT>FLAG</DT>
+ <DD> 
+ A string containing the value of all the flags associated to a specific
+ message. The possible values of allowed flags are "*" for Important, "N"
+ for recent or new, "U" for unseen or unread, "R" for seen or read, "A" for
+ answered and "D" for deleted. See an example of its use in the 
+ <A HREF="h_config_new_rules">new rules</A> explanation and example help.
+ </DD>
+ </DL>
+ 
+ <P>
  <H1><EM>Token Available Only for Templates and Signatures</EM></H1>
  
  <DL>
***************
*** 20431,20436 ****
--- 20764,20816 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_sleep ======
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_sleep-interval-length"--> (UNIX Alpine only)</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_sleep-interval-length"--> (UNIX Alpine only)</H1>
+ 
+ <P>
+ When you open an attachment, Alpine goes through a list of viewers either 
+ in your .mailcap file, or some other mailcap file in your system. The 
+ normal behavior is that Alpine opens a local copy of the attachment, which 
+ is removed from the system <B>after</B> the viewer has completed 
+ displaying it. For example, if you open an attachment on a viewer and 
+ later close the viewer, then control will return to the system and the 
+ copy of the attachment will be removed from the system. This is the normal 
+ behavior and has been accepted for years as the correct behavior.
+ 
+ <P>
+ However, if an instance of the viewer is already open, the viewer may 
+ return control to the system <B>before</B> it reads the copy of the 
+ attachment. Given that Alpine removes the copy of the attachment after 
+ control is returned to the system, this may cause Alpine to remove the 
+ copy of the attachment <B>before</B> it is actually opened by the viewer.
+ 
+ <P>
+ Since Alpine has no control over when a viewer returns from opening a file, 
+ and viewers should not return before they read the file, Alpine has no control
+ over when the viewer will read the file and avoid the problem described above.
+ 
+ <P>
+ The value of this option is the number of seconds that Alpine will wait
+ between the time that the viewer returns control to the system and the 
+ when it will remove it from the system. You will not notice this
+ delay, since this will happen in the background. The default value is
+ 0 which means that no delay will occur, and it is a value which may trigger
+ the problem described above with some viewers. By modifying the value of
+ this option you can set Alpine to wait longer. A reasonable small value is 5, 
+ which works with all viewers tested to date. The maximum value is 120 
+ (2 minutes).
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_incoming_interv ======
  <HTML>
  <HEAD>
***************
*** 21495,21500 ****
--- 21875,21976 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_maildir_location ======
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_maildir-location"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_maildir-location"--></H1>
+ 
+ <P>
+ This option should be used only if you have a Maildir folder which you
+ want to use as your INBOX. If this is not your case (or don't know what
+ this is), you can safely ignore this option.
+ 
+ <P>
+ This option overrides the default directory Pine uses to find the location of
+ your INBOX, in case this is in Maildir format. The default value of this
+ option is "Maildir", but in some systems, this directory could have been
+ renamed (e.g. to ".maildir"). If this is your case use this option to change
+ the default.
+ 
+ <P>
+ The value of this option is prefixed with the "~/" string to determine the
+ full path to your INBOX.
+ 
+ <P>
+ You should probably <A HREF="h_config_maildir">read</A> a few tips that 
+ teach you how to configure your maildir for optimal performance. This
+ version also has <A HREF="h_config_courier_list">support</A> for the 
+ Courier style file system when a maildir collection is accessed locally.
+ 
+ <P><UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL>
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_maildir =====
+ <HTML>
+ <HEAD>
+ <TITLE>Maildir Support</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>Maildir Support</H1>
+ 
+ This version of Alpine has been enhanced with Maildir support. This text is 
+ intended to be a reference on its support.
+ <P>
+ 
+ A Maildir folder is a directory that contains three directories called 
+ cur, tmp and new. A program that delivers mail (e.g. postfix) will put new 
+ mail in the new directory. A program that reads mail will look for for old 
+ messages in the cur directory, while it will look for new mail in the new 
+ directory.
+ <P>
+ 
+ In order to use maildir support it is better to set your inbox-path to the 
+ value &quot;#md/inbox&quot; (without quotes). This assumes that your mail 
+ delivery agent is delivering new mail to ~/Maildir/new. If the directory 
+ where new mail is being delivered is not called "Maildir", you can set the 
+ name of the subdirectory of home where it is being delivered in the <A 
+ HREF="h_config_maildir_location"><!--#echo var="VAR_maildir-location"--></A> configuration 
+ variable. Most of the time you will not have to worry about the 
+ <!--#echo var="VAR_maildirlocation"--> variable, because it will probably be set by your 
+ administrator in the pine.conf configuration file.
+ <P>
+ 
+ One of the advantages of the Maildir support of this version of Alpine is 
+ that you do not have to stop using folders in another styles (mbox, mbx, 
+ etc.). This is desirable since the usage of a specific mail storage system 
+ is a personal decision. Folders in the maildir format that are part of the 
+ Mail collection will be recognized without any extra configuration of your 
+ part. If your mail/ collection is located under the mail/ directory, then 
+ creating a new maildir folder in this collection is done by pressing "A" 
+ and entering the string "#driver.md/mail/newfolder". Observe that adding a 
+ new folder as "newfolder" may not create such folder in maildir format.
+ 
+ <P>
+ If you would like to have all folders created in the maildir format by 
+ default, you do so by adding a Maildir Collection. In order to convert 
+ your current mail/ collection into a maildir collection, edit the 
+ collection and change the path variable from &quot;mail/&quot; to 
+ &quot;#md/mail&quot;. In a maildir collection folders of any other format 
+ are ignored.
+ 
+ <P> Finally, This version also has 
+ <A HREF="h_config_courier_list">support</A> for the Courier style file system 
+ when a maildir collection is accessed locally.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_literal_sig =====
  <HTML>
  <HEAD>
***************
*** 22257,22262 ****
--- 22733,22777 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_thread_sort_key =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_thread-sort-key--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_thread-sort-key--></TITLE></H1>
+ 
+ This option determines the order in which threads will be displayed. You 
+ can choose from the options listed below. Each folder is sorted in one of 
+ the sort orders displayed below first, then the thread containing the last 
+ message of that sorted list is put at the end of the index. All messages 
+ of that thread are &quot;removed&quot; from the sorted list and the 
+ process is repeated with the remaining messages in that list.
+ 
+ <P>
+ <UL>
+  <LI> <A HREF="h_thread_index_sort_arrival">Arrival</A>
+  <LI> <A HREF="h_thread_index_sort_date">Date</A>
+ <!-- <LI> <A HREF="h_thread_index_sort_subj">Subject</A>
+  <LI> <A HREF="h_thread_index_sort_ordsubj">OrderedSubj</A>-->
+  <LI> <A HREF="h_thread_index_sort_thread">Thread</A>
+ <!-- <LI> <A HREF="h_thread_index_sort_from">From</A> -->
+  <LI> <A HREF="h_thread_index_sort_size">Size</A> 
+  <LI> <A HREF="h_thread_index_sort_score">Score</A>
+ <!-- <LI> <A HREF="h_thread_index_sort_to">To</A>
+  <LI> <A HREF="h_thread_index_sort_cc">Cc</A>-->
+ </UL>
+ 
+ <P> Each type of sort may also be reversed. Normal default is by
+ &quot;Thread&quot;.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_other_startup =====
  <HTML>
  <HEAD>
***************
*** 22527,22532 ****
--- 23042,23938 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_procid =====
+ <HTML>
+ <HEAD>
+ <TITLE>Token: PROCID</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>TOKEN: PROCID explained</H1>
+ 
+ <P>
+ The PROCID token is a way in which the user and the program can differentiate
+ between different parts of a program. It allows the user to tell the
+ program when to use a specific rule, and only use it at that specific
+ moment.
+ 
+ <P> The normal way in which this is done is by adding a new configuration 
+ variable. The idea behind the PROCID token is that instead of adding a new 
+ configuration variable (which means the user has to go through more 
+ configuration variables just to tune the program to his liking), we reuse 
+ an old variable and let the user look inside that variable for the desired
+ behavior, which is actually set by setting the PROCID token.
+ 
+ <P>
+ Consider the following examples for forward-rules:
+ 
+ <P>
+ _ROLE_ == {work} =&gt; _SUBJECT_ := _COPY_{[tag] _SUBJECT_}
+ 
+ <P>
+ and
+ 
+ <P>
+ _ROLE_ == {work} =&gt; _LCC_ := _TRIM_{_FORWARDFROM_ &lt;_FORWARDADDRESS_&gt;}
+ 
+ <P>
+ both are triggered by the same condition. Since both are configured in the 
+ same variable, only one of them will be executed all the time (whichever 
+ is first). Therefore in order to differentiate, we add a _PROCID_ token. 
+ So, for example, the first example above will be executed only when we are 
+ determining the subject. In this case, the following rule will accomplish 
+ this task
+ 
+ <P>
+ _PROCID_ == {fwd-subject} && _ROLE_ == {work} =&gt; _SUBJECT_ := _COPY_{[tag] _SUBJECT_}
+ 
+ <P>
+ In this case, this rule will be tested fully only when we are determining 
+ the subject line of a forwarded message, not otherwise.
+ 
+ <P>
+ It is wise to add the _PROCID_ token as the first condition in a rule, so 
+ that other conditions will not be tested in a long list of rules.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_compose_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_compose-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_compose-rules"--></H1>
+ 
+ <P> At this time, this option is used to generate values for signature
+ files that is not possible to do with the use of 
+ <A HREF="h_rules_roles">roles</A>.
+ 
+ <P> For example, you can have a rule like:<BR>
+ _TO_ >> {Peter Flinstones} => _SIGNATURE_{~/.petersignature}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_forward_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_forward-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_forward-rules"--></H1>
+ 
+ <P> This option has several uses. This feature uses the PROCID function
+ to identify different features of forwarding. You can read more about PROCID
+ by following <A HREF="h_config_procid">this link</A>.
+ 
+ <P> If you want to edit the subject of a forwarded message, use the
+ PROCID <I>fwd-subject</I>. For example you could have a rule like
+ 
+ <P>
+ _ROLE_ == {admin} && _SUBJECT_ !&gt; {[tag] } =&gt; _COPY_{[tag] _SUBJECT_}
+ 
+ <P> Another way in which this option can be used, is to trim the values of 
+ some fields. For this application the PROCID is <I>fwd-lcc</I>. For 
+ example it can be used in the following way:
+ 
+ <P>
+ _ROLE_ == {work} => _LCC_ := _TRIM_{_FORWARDFROM_ &lt;_FORWARDADDRESS_&gt;}
+ 
+ <P> Other functions that can be used in this option are _EXEC_ and _REXTRIM_.
+ 
+ <P> You can also use the _EXEC_ function. The documentation for this function
+ is in the 
+ <A HREF="h_config_resub_rules"><!--#echo var="VAR_reply-subject-rules"--></A>
+ help text.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_index_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_index-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_index-rules"--></H1>
+ 
+ <P> This option is used to supersede the value of the option <A
+ HREF="h_config_index_format"><!--#echo var="VAR_index-format"--></A> for specific folders. In
+ this form you can have different index-formats for different folders. For
+ example an entry here may be:
+ 
+ <P>
+ _FOLDER_ == {INBOX} => _INDEX_{IMAPSTATUS DATE FROM(33%) SIZE SUBJECT(67%)}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_pretty_command =====
+ <HTML>
+ <HEAD>
+ <TITLE>Pretty-Command Explained</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>Pretty Command Explained</H1>
+ 
+ <P> This text explains how to encode keys so that they will be recognized 
+ by Alpine in the _PKEY_ token. Most direct keystrokes are recognized in the 
+ same way. For example, the key ~ is recognized by the same character. The 
+ issue is how control, or functions keys are recognized. The internal code 
+ is most times easy to find out. If the key you want to use is not already 
+ recognized by Alpine simply press it. Alpine will print its code. For example, 
+ the return key is not recognized in this screen, so if you press it, you 
+ will see the following message.
+ 
+ <P> [Command &quot;RETURN&quot; not defined for this screen. Use ? for help]
+ 
+ <P> from here you can guess that the code for the return command is 
+ RETURN. You can try other commands, like Control-C, the TAB key, F4, etc. 
+ to see their codes.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_key_macro_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_key-definition-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_key-definition-rules"--></H1>
+ 
+ <P> This option can be used to define macros, that is, to define a key that
+ when pressed executes a group of predetermined keystrokes. Since Alpine is
+ a menu driven program, sometimes the same key may have different meanings
+ in different screens, so a global redefinition of a key although possible
+ is not advisable. 
+ 
+ <P> <B>Always use the _SCREEN_ token as defined below.</B>. You have been
+ warned!
+ 
+ <P> In each screen, every time you press a recognized key, a command is 
+ activated. In order to understand this feature, think of commands instead 
+ of keystrokes. For example, you can think of the sort by thread command. 
+ This command is associated to the keystrokes $ and h. You may want to 
+ associate this command to a specific keystroke, like ~, so every time you
+ press the ~ key, Alpine understand the $ and h keystrokes, which activates
+ the sort by thread command.
+ 
+ <P> Therefore, in order to use this option you must think of three 
+ components. The screen where you will use the macro, the keystroke you 
+ want to use and the set of keystrokes used by Alpine to accomplish the task 
+ you want to accomplish. We will talk about these three components in what 
+ follows.
+ 
+ <P> First you must decide in which screen the macro will be used. This 
+ feature is currently only available for the screen where your messages
+ are listed in index form (<A HREF="h_mail_index">MESSAGE INDEX</A>),
+ the screen where your message is displayed
+ (<A HREF="h_mail_view">MESSAGE TEXT</A>) and the screen where the list of
+ folders is displayed (<A HREF="h_folder_maint">FOLDER LIST</A>). The 
+ internal names of these screens for this patch are &quot;index&quot;, 
+ &quot;text&quot; and 
+ &quot;folder&quot; respectively. Please note that the internal names are 
+ all in lowercase and are case sensitive.
+ 
+ <P> In order to define the screen, you use the _SCREEN_ token, so for 
+ example, you can write _SCREEN_ == {index}.
+ 
+ <P> Second you must think of which key you will use to activate the macro. 
+ Here you can use any key of your choice. The token you use to designate a 
+ key is the _PKEY_ token (PKEY stands for &quot;pressed key&quot;). For 
+ example you could use _PKEY_ == {~}, to designate the &quot;~&quot; 
+ key to activate the command. Some keystrokes (like control, or 
+ function keys) are encoded in special ways. You should read the 
+ <A HREF="h_config_pretty_command">full explanation</A> on how to find
+ out the encoding for each keystroke.
+ 
+ <P> Last, you must think of the list of keys you will use to accomplish 
+ the task you want Alpine to perform. Say for example you want to have the 
+ folder sorted by thread. That means you want Aline to execute the keys 
+ &quot;$&quot; and &quot;h&quot;. You use the _COMMAND_ function to specify 
+ this. The syntax in this case is _COMMAND_{$,h}.
+ 
+ <P> Observe that in the above example the different inputs are separated 
+ by commas. This is the standard way in which the
+ <A HREF="h_config_init_cmd_list"><!--#echo var="VAR_initial-keystroke-list"--></A> command works from 
+ the command line. Due to restrictions in the way Alpine works, a comma is a 
+ special character, which when added to a configuration option like this 
+ will cause the configuration to split into several lines in the 
+ configuration screen. This has the effect of producing several 
+ configuration options, all of which are incorrect. This is undesirable 
+ because what you want is to have it all in one line. In order to force the 
+ configuration into one line you must quote the comma. The best way to 
+ accomplish this is by quoting the full definition of the rule. For 
+ example.
+ 
+ <P>
+ &quot;_SCREEN_ == {index} && _PKEY_ == {~} => _COMMAND_{$,h}&quot;
+ 
+ <P> Another way to accomplish the same effect is by quoting the command and 
+ not using quotes for the full command, nor commas to separate the 
+ keystrokes in the command, for example
+ 
+ <P>
+ _SCREEN_ == {index} && _PKEY_ == {~} => _COMMAND_{&quot;$h&quot;}
+ 
+ <P> For more information on how to define the argument of the _COMMAND_
+ token see the help of 
+ <A HREF="h_config_init_cmd_list"><!--#echo var="VAR_initial-keystroke-list"--></A>.
+ 
+ <P> Because the $ command can also be used as the first character in the
+ definition of an environemnt variable, no expansion of environment variables
+ is done when parsing this variable. The $ character does not need quoting
+ and quoting it will make Alpine fail to produce the correct result.
+ 
+ <P> This configuration option is just one of many that allow you to 
+ override the value of some global configurations within Alpine. There is a 
+ help text explaining how to define all of them, which you can read by 
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_replace_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_replace-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_replace-rules"--></H1>
+ 
+ <P> This option is used to have Alpine print different values for specific 
+ tokens in the <A HREF="h_config_index_format"><!--#echo var="VAR_index-format"--></A>. For example you
+ can replace strings like "To: newsgroup" by your name.
+ 
+ <P> Here are examples of possible rules:
+ 
+ <P>_FOLDER_ != {sent-mail} && _NICK_ != {} =&gt; _FROM_ := _REPLACE_{_FROM_ (_NICK_)}
+ 
+ <P> or if you receive messages with tags that contain arbitrary numbers, and
+ you want them removed from the index (but not from the subject), use a rule
+ like the following
+ 
+ <P>_FOLDER_ == {INBOX} =&gt; _SUBJECT_ := _REXTRIM_{&#92;&#91;some-tag-here &#35;&#91;0-9&#93;.*&#92;&#93;}
+ 
+ <P> You can also use this configuration option to remove specific strings of
+ the index display screen, so that you can trim unnecessary information in
+ your index, like the reply leadin string in the OPENINGTEXTNQ token of the index.<BR>
+ 
+ <P>_FOLDER_ == {some-folder} => _OPENINGTEXTNQ_ := _REXTRIM_{On.*wrote: }
+ 
+ <P> You can also use the _EXEC_ function. The documentation for this function
+ is in the 
+ <A HREF="h_config_resub_rules"><!--#echo var="VAR_reply-subject-rules"--></A>
+ help text.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_reply_leadin_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_reply-leadin-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_reply-leadin-rules"--></H1>
+ 
+ <P> This option is used to have Alpine generate a different 
+ <A HREF="h_config_reply_intro"><!--#echo var="VAR_reply-leadin"--></A> string dependent either on
+ the person you are replying to, or the folder where the message is being
+ replied is in, or both.
+ 
+ <P> Here there are examples of how this can be used. One can use the definition
+ below to post to newsgroups and the pine-info mailing list, say:
+ <P>
+ _FOLDER_ << {pine-info;_NEWS_} => _REPLY_{*** _FROM_ _ADDRESS_("_FROM_"  "" "(_ADDRESS_) ")wrote in_NEWS_("" " the" "") _FOLDER_ _NEWS_("" "list " "")_SMARTDATE_("Today" "today" "on _LONGDATE_"):}
+ 
+ <P> Here there is an example that one can use to change the reply indent string
+ to reply people that speak spanish.
+ <P>
+ _FROM_{Condorito;Quico} => _REPLY_{*** _FROM_ (_ADDRESS_) escribi&oacute; _SMARTDATE_("Today" "hoy" "en _LONGDATE_"):}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_resub_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_reply-subject-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_reply-subject-rules"--></H1>
+ 
+ <P> This option is used to have Alpine generate a different subject when
+ replying rather than the one Alpine would generate automatically. 
+ 
+ <P> Here there are a couple of examples about how to use this
+ configuration option:
+ 
+ <P> In order to have messages with empty subject to be replied with the message
+ "your message" use the rule<BR>
+ <center>_SUBJECT_ == {} => _RESUB_{Re: your message}</center>
+ 
+ <P> If you want to trim some parts of the subject when you reply use the
+ rule<BR> 
+ <center>_SUBJECT_ >> {[one];two} => _SUBJECT_ := _TRIM_{[;];two}</center> 
+ 
+ <P>this rule removes the brackets "[" and "]" whenever the string "[one]"
+ appears in it, it also removes the word "two" from it.
+ 
+ <P>Another example where you may want to use this rule is when you 
+ correspond with people that change the reply string from &quot;Re:&quot; 
+ to &quot;AW:&quot; or &quot;Sv:&quot;. In this case a rule like<BR>
+ <center>_SUBJECT_ >> {Sv: ;AW: } => _SUBJECT_ := _TRIM_{Sv: ;AW: }</center> 
+ <P>
+ would eliminate undesired strings in replies.
+ 
+ <P> Another interesting use of this option is the use of the _EXEC_ function.
+ This function takes as an argument a program or a script. This program
+ must take as the input a file, and write its output to that file. For example,
+ below is a sample of a script that removes the letter &quot;a&quot; of a file.
+ 
+ <PRE>
+ #!/bin/sh
+ sed 's/a//g' $1 > /tmp/mytest
+ mv /tmp/mytest $1
+ </PRE>
+ 
+ <P>
+ As you can see this script took &quot;$1&quot; as input file, the sed program
+ wrote its output to /tmp/mytest, and then the move program moved the file
+ /tmp/mytest to the input file &quot;$1&quot;. This is the kind of behavior
+ that your program is expected to have.
+ 
+ <P>
+ The content of the input file (&quot;$1&quot; above) is the value of a token
+ like _SUBJECT_. In order to indicate this, we use the notation
+ 
+ <P>
+ _SUBJECT_ := _EXEC_{/path/to/script}
+ 
+ <P> for the action. So for example
+ 
+ <P>
+ _FOLDER_ := {sent-mail} =&gt; _SUBJECT_ := _EXEC_{/path/to/script}
+ 
+ <P> is a valid rule.
+ 
+ <P> You can also use this configuration option to customize reply subjects
+ according to the sender of the message.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_sort_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_sort-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_sort-rules"--></H1>
+ 
+ <P> This option is used to have Alpine sort different folders in different orders
+ and thus override the value already set in the
+ <A HREF="h_config_sort_key"><!--#echo var="VAR_sort-key"--></A> configuration option.
+ 
+ <P> Here's an example of the way it can be used. In this case all incoming
+ folders are mailing lists, except for INBOX, so we sort INBOX by arrival
+ (which is the default type of sort), but we want all the rest of mailing
+ lists and newsgroups to be sorted by thread.
+ 
+ <P>
+ _COLLECTION_ >> {Incoming-Folders;News} && _FOLDER_ != {INBOX} => _SORT_{tHread}
+ 
+ <P> Another example could be<BR>
+ _FOLDER_ == {Mailing List} => _SORT_{Reverse tHread}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_save_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_save-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_save-rules"--></H1>
+ 
+ <P> This option is used to specify which folder should be used to save a
+ message depending either on the folder the message is in, who the message
+ is from, or text that the message contains in specific headers (Cc:,
+ Subject:, etc).
+ 
+ <P> If this option is set and the 
+ <A HREF="h_config_auto_read_msgs"><!--#echo var="FEAT_auto-move-read-msgs"--></A> configuration
+ option is also enabled then these definitions will be used to move messages
+ from your INBOX when exiting Alpine.
+ 
+ <P>Here there are some examples<BR>
+ _FLAG_ >> {D} -> Trash<BR>
+ _FROM_ == {U2} -> Bono<BR>
+ _FOLDER_ == {comp.mail.pine} -> pine-stuff<BR>
+ _NICK_ != {} -> _NICK_/_NICK_<BR>
+ _DATEISO_ >> {02-10;02-11} -> archive-oct-nov-2002
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_reply_indent_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_reply-indent-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_reply-indent-rules"--></H1>
+ 
+ <P> This option is used to specify which reply-indent-string is to be used
+ when replying to an e-mail. If none of the rules are successful, the result in
+ the variable <a href="h_config_reply_indent_string"><!--#echo var="VAR_reply-indent-string"--></a>
+ is used.
+ 
+ <P> The associated function to this configuration option is called "RESTR" (for
+ REply STRing). Some examples of its use are:<BR>
+ _FROM_ == {Your Boss} => _RESTR_{"> "}<BR>
+ _FROM_ == {My Wife} => _RESTR_{":* "}<BR>
+ _FROM_ == {Perter Flinstone;Wilma Flinstone} => _RESTR_{"_INIT_ > "}<BR>
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_smtp_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_smtp-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_smtp-rules"--></H1>
+ 
+ <P> This option is used to specify which SMTP server should be used when
+ sending a message, if this rule is not defined, or the execution of the rule
+ results in no server selected, then Alpine will look for 
+ the value from the role that is being used to compose the message. If no smtp
+ server is defined in that role or you are not using a role, then Alpine will get
+ the name of the server from the
+ <A HREF="h_config_smtp_server">&quot;<!--#echo var="VAR_smtp-server"-->&quot;</A> configuration
+ option according to the rules used in that variable.
+ 
+ <P> The function associated to this configuration option is _SMTP_, an example
+ of the use of this function is<BR>
+ _ADDRESSTO_ == {peter@bedrock.com} => _SMTP_{smtp.bedrock.com}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_startup_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_startup-rules"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_startup-rules"--></H1>
+ 
+ <P> This option is used when a folder is being opened. You can use it to specify its <A 
+ HREF="h_config_inc_startup"><!--#echo var="VAR_incoming-startup-rule"--></A> and override 
+ Alpine's global value set for all folders.
+ 
+ <P> An example of the usage of this option is:<BR>
+ _FOLDER_ == {Lynx;pine-info;_NEWS_} => _STARTUP_{first-unseen}
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>&lt;End of help on this topic&gt;
+ 
+ </BODY>
+ </HTML>
+ ====== h_config_new_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: New Rules Explained</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: New Rules Explained</H1>
+ 
+ This is a quite powerful option. Here you can define rules that override
+ the values of any other option you have set in Alpine.
+ 
+ <P>
+ For example, you can set your folders to be sorted in a certain way when 
+ you open them (say by Arrival). You may want, however, your newsgroups to 
+ be sorted by thread. The set of &quot;rules&quot; options allows you to 
+ configure this and many other options, including the index-format for 
+ specific folders, the way the subject is displayed in the index screen or 
+ the reply-leadin-string, to name a few.
+ 
+ <P>
+ Every rule has three parts: a condition, a separator and an action. The
+ action is what will happen if the condition of the rule is satisified.
+ 
+ <P>
+   Here is an example:
+ 
+ <P>
+    _FROM_ == {Fred Flinstone} =&gt; _SAVE_{Fred}
+ 
+ <P>
+   Here the separator is "=&gt;". Whatever is to the left of the separator 
+ is the condition (that is _FROM_ == {Fred Flinstone}) and to the right is 
+ the action (_SAVE_{Fred}). The condition means that the rule will be 
+ applied only if the message that you are reading is from &quot;Fred 
+ Flinstone&quot;, and the action will be that you will be offered to save 
+ it in the folder &quot;Fred&quot;, whenever you press the letter 
+ &quot;S&quot; to save a message.
+ 
+ <P>
+   The separator is always &quot;=&gt;&quot;, with one exception to be seen 
+ later. But for the most part this will be the only one you will ever need.
+ 
+ <P>
+   Now let us see how to do it. There are 13 functions already defined for 
+ you. These are: _EXEC_, _INDEX_, _REPLACE_, _REPLY_, _RESUB_, _SAVE_, 
+ _SIGNATURE_, _SORT_, _STARTUP_, _TRIM_, _REXTRIM_, _THREADSTYLE and 
+ _THREADINDEX_. The parameter of a function has to be enclosed between 
+ &quot;{&quot; and &quot;}&quot;, so for example you can specify 
+ _SAVE_{saved-messages} as a valid sentence.
+ 
+ <P>
+   Later in the document you will find examples. Here is a short 
+ description of what each function does:
+ 
+ <P>
+ <UL>
+ <LI> _EXEC_ : This function takes as an argument a program. This program 
+ gets as the input a file and must rewrite its output to that file, which 
+ is then taken as the value to replace from the contents of that file. You 
+ can use this function with 
+ <A HREF="h_config_resub_rules"><!--#echo var="VAR_reply-subject-rules"--></A>, 
+ <A HREF="h_config_replace_rules"><!--#echo var="VAR_replace-rules"--></A> and 
+ <A HREF="h_config_forward_rules"><!--#echo var="VAR_forward-rules"--></A>. 
+ See the help of those options for examples of how to use this function
+ and configure these rules.
+ <BR>&nbsp;<BR>
+ <LI> _INDEX_ : This function takes as an argument an index-format, and
+ makes that the index-format for the specified folder.
+ <BR>&nbsp;<BR>
+ <LI> _REPLACE_ : This function replaces the subject/from of the given e-mail by
+ another subject/from only when displaying the index.
+ <BR>&nbsp;<BR>
+ <LI> _REPLY_ : This function takes as an argument a definition of a
+ reply-leadin-string and makes this the reply-leading-string of the
+ specified folder or person.
+ <BR>&nbsp;<BR>
+ <LI> _RESTR_ : This function takes as an argument the value of the 
+ reply-indent-string to be used to answer the message being replied to.
+ <BR>&nbsp;<BR>
+ <LI> _RESUB_ : This function replaces the subject of the given e-mail by
+ another subject only when replying to a message.
+ <BR>&nbsp;<BR>
+ <LI> _SAVE_ : The save function takes as an argument the name of a
+ possibly non existing folder, whenever you want to save a message, that
+ folder will be offered for you to save.
+ <BR>&nbsp;<BR>
+ <LI> _SIGNATURE_ : This function takes as an argument a signature file and
+ uses that file as the signature for the message you are about to
+ compose/reply/forward.
+ <BR>&nbsp;<BR>
+ <LI> _SMTP_ : This function takes as an argument the definition of a
+ SMTP server.
+ <BR>&nbsp;<BR>
+ <LI> _SORT_ : This function takes as an argument a Sort Style, and sorts a
+ specified folder in that sort order.
+ <BR>&nbsp;<BR>
+ <LI> _TRIM_ : This function takes as an argument a list of strings that
+ you want removed from another string. At this time this only works for
+ _FROM_ and _SUBJECT_.
+ <BR>&nbsp;<BR>
+ <LI> _REXTRIM_ : Same as _TRIM_ but its argument is one and
+ only one extended regular expression.
+ <BR>&nbsp;<BR>
+ <LI> _STARTUP_ : This function takes as an argument an
+ incoming-startup-rule, and open an specified folder using that rule.
+ <BR>&nbsp;<BR>
+ <LI> _THREADSTYLE_ : This function takes as an argument a
+ threading-display-style and uses it to display threads in a folder.
+ <BR>&nbsp;<BR>
+ <LI> _THREADINDEX_ : This function takes as an argument a
+ threading-index-style and uses it to display threads in a folder.
+ </UL>
+ 
+ <P>
+ You must me wondering how to define the person/folder over who to apply
+ the action. This is done in the condition. When you specify a rule, the
+ rule is only executed if the condition is satisfied. In another words for
+ the rule:
+ 
+ <P>
+    _FROM_ == {Fred Flinstone} =&gt; _SAVE_{Fred}
+ 
+ <P> it will only be applied if the from is &quot;Fred Flinstone&quot;. If 
+ the From is &quot;Wilma Flinstone&quot; the rule will be skipped.
+ 
+ <P> In order to test a condition you can use the following tokens (in 
+ alphabetical order): _ADDRESS_, _CC_, _FOLDER_, _FROM_,_NICK_, _ROLE, 
+ _SENDER_, _SUBJECT_ and _TO_. The token will always be tested against what 
+ it is between &quot;{&quot; and &quot;}&quot; in the condition, this part 
+ of the condition is called the &quot;condition set&quot;. The definition 
+ of each token can be found <A HREF="h_index_tokens">here</A>. 
+ 
+ <P> A special testing token called _PROCID_ can be used to differentiate 
+ inside a rule, between two rules that are triggered by the same condition. 
+ A full explanation of the _PROCID_ token can be found in 
+ <A HREF="h_config_procid">this link</A>.
+ 
+ <P> There are two more tokens related to the option
+ <A HREF="h_config_key_macro_rules">key-definition-rules</A>. Those tokens
+ are only specific to that option, and hence are not explained here.
+ 
+ <P> You can also test in different ways, you can use the following 
+ &quot;test operands&quot;: &lt;&lt;, !&lt;, &gt;&gt;, !&gt;, == and !=. 
+ All of them are two characters long. Here is the meaning of them:
+ 
+ <P>
+ <UL> 
+ <LI> &lt;&lt; : It tests if the value of the token is contained in
+ the condition set. Here for example if the condition set were equal to
+ &quot;Freddy&quot;, then the condition: _NICK_ &lt;&lt; {Freddy}, would be true if
+ the value of _NICK_ were &quot;Fred&quot;, &quot;red&quot; or &quot;Freddy&quot;. You are just looking
+ for substrings here.
+ <LI> &gt;&gt; : It tests if the value of the token contains the value of
+ the condition set. Here for example if the condittion set were equal to
+ &quot;Fred&quot;, then the condition: _FROM_ &gt;&gt; {Fred}, would be true if
+ the value of _FROM_ were &quot;Fred Flinstone&quot; or &quot;Fred P. Flinstone&quot; or &quot;Freddy&quot;.
+ <LI> == : It tests if the value of the token is exactly equal to the value
+ of the set condition. For example _NICK_ == {Fred} will be false if the value 
+ of _NICK_ is &quot;Freddy&quot; or &quot;red&quot;. 
+ <LI> !&lt; : This is true only when &lt;&lt; is false and viceversa.
+ <LI> !&gt; : This is true only when &gt;&gt; is false and viceversa.
+ <LI> != : This is true only when == is false and viceversa.
+ </UL>
+ 
+ <P>
+   Now let us say that you want the same action to be applied to more than
+ one person or folder, say you want &quot;folder1&quot; and &quot;folder2&quot; to be sorted by
+ Ordered Subject upon entering. Then you can list them all of them in the
+ condition part separting them by a &quot;;&quot;. Here is the way to do it.
+ 
+ <P>
+  _FOLDER_ &lt;&lt; {folder1; folder2} =&gt; _SORT_{OrderedSubj}
+ 
+ <P>
+   Here is the first subtelty about these definitions. Notice that the
+ following rule:
+ 
+ <P>
+  _FOLDER_ == {folder1; folder2} =&gt; _SORT_{Reverse OrderedSubj}
+ 
+ <P> works only for &quot;folder1&quot; but not for &quot;folder2&quot;. This is because the
+ comparison of the name of the folder is done with whatever is in between
+ &quot;{&quot;, &quot;;&quot; or &quot;}&quot;, so in the above rule you would be testing <BR>
+ &quot;folder2&quot; == &quot; folder2&quot;. The extra space makes the difference. 
+ The reason why the first rule does not fail is because 
+ &quot;folder2&quot; &lt;&lt; &quot; folder2&quot; is actually
+ true. If something ever fails this may be something to look into.
+ 
+ <P>
+  Here are a few examples of what we have talked about before.
+ 
+ <P>
+ _NICK_ == {lisa;kika} =&gt; _SAVE_{_NICK_/_NICK_} <BR>
+ This means that if the nick is lisa, it will 
+ save the message in the folder &quot;lisa/lisa&quot;, and if the nick 
+ is &quot;kika&quot;, it will save the message in the folder &quot;kika/kika&quot;
+ 
+ <P>
+ _FOLDER_ == {Lynx} -&gt; lynx <BR>
+ This, is an abreviation of the following rule:<BR>
+ _FOLDER_ == {Lynx} =&gt; _SAVE_{lynx} <BR>
+ (note the change in separator from &quot;=&gt;&quot; to &quot;-&gt;&quot;). In the future 
+ I will use that abreviation.
+ 
+ <P> _FOLDER_ &lt;&lt; {comp.mail.pine; pine-info; pine-alpha} -&gt; pine <BR>
+ Any message in the folders &quot;comp.mail.pine&quot;, &quot;pine-info&quot; or &quot;pine-alpha&quot;
+ will be saved to the folder &quot;pine&quot;.
+ 
+ <P> _FROM_ &lt;&lt; {Pine Master} -&gt; pine <BR>
+ Any message whose From field contains
+ &quot;Pine Master&quot; will be saved in the folder pine.
+ 
+ <P> _FOLDER_ &lt;&lt; {Lynx; pine-info; comp.mail.pine} =&gt;
+ _INDEX_{IMAPSTATUS MSGNO DATE FROMORTO(33%) SUBJECT(66%)} <BR> Use a
+ different index-format for the folders &quot;Lynx&quot;, &quot;pine-info&quot; and
+ &quot;comp.mail.pine&quot;, where the size is not present.
+ 
+ <P> _FOLDER_ == {Lynx;pine-info} =&gt; _REPLY_{*** _FROM_ (_ADDRESS_)
+ wrote in the _FOLDER_ list _SMARTDATE_(&quot;Today&quot; &quot;today&quot; &quot;on
+ _LONGDATE_&quot;):}<BR> If a message is in one of the incoming folders &quot;Lynx&quot;
+ or &quot;pine-info&quot;, create a reply-leadin-string that acknowledges that. Note
+ the absence of &quot;,&quot; in the function _SMARTDATE_. For example answering to a
+ message in the pine-info list would look like:
+ 
+ <P>
+ *** Steve Hubert (hubert@cac.washington.edu) wrote in the pine-info list today:
+ 
+ <P>
+ However replying for a message in the Lynx list would look:
+ 
+ <P>
+ *** mattack@area.com (mattack@area.com) wrote in the Lynx list today:
+ 
+ <P>
+ If you write in more than one language you can use this feature to create
+ Reply-leadin-strings in different languages.
+ 
+ <P> Note that at least for people you can create particular
+ reply-leadin-string using the role features, but it does not work as this
+ one does. This seems to be the right way to do it.
+ 
+ <P> _FOLDER_ &lt;&lt; {Lynx; comp.mail.pine; pine_info; pine-alpha} =&gt;
+ _SORT_{OrderedSubj}<BR> This means upon opening, sort the folders &quot;Lynx&quot;,
+ &quot;comp.mail.pine&quot;, etc in ordered subject. All the others use the default
+ sort order. You can not sort in reverse in this form. The possible
+ arguments of this function are listed in the definition of the
+ default-sort-rule (Arrival, scorE, siZe, etc).
+ 
+ <P> The last examples use the function _TRIM_ which has a special form.
+ This function can only be used in the index list.
+ 
+ <P> _FOLDER_ &lt;&lt; {Lynx} =&gt; _SUBJECT_ := _TRIM_{lynx-dev }<BR> In
+ the folder &quot;Lynx&quot; eliminate from the subject the string &quot;lynx-dev &quot; (with
+ the space at the end). For example a message whose subject is &quot;Re:
+ lynx-dev unvisited Visited Links&quot;, would be shown in the index with
+ subject: &quot;Re: unvisited Visited Links&quot;, making the subject shorter and
+ giving the same information.
+ 
+ <P> _FROM_ &gt;&gt; {Name (Comment)} =&gt; _FROM_ :=
+ _TRIM_{ (Comment)}<BR> Remove the part &quot; (Comment)&quot;
+ from the _FROM_, so when displaying in the index the real From &quot;Name&quot;
+ will appear.
+ 
+ <P> _SUBJECT_ == {} =&gt; _RESUB_{Re: your mail without subject}
+ If there is no subject in the message, use the subject &quot;Re: your mail
+ wiyhout subject&quot; as a subject for the reply message.
+ 
+ <P> You can add more complexity to your rules by checking more than one
+ conditions before a rule is executed. More than one condition can be
+ checked by separating different conditions by the && (and) separator,
+ or using the || (or) separator. For example we could have a rule that
+ saves all
+ messages in inbox from Rubye, to the Personal folder, as
+ 
+ <P> _FOLDER_ == {INBOX} && _FROM_ >> {Rubye} => _SAVE_{Personal}
+ 
+ <P> We could also have a rule that is triggered by an &quot;or&quot; 
+ condition by, sat for messages from Andres or messages in the index
+ to trigger a specific reply leadin string.
+ 
+ <P> _FOLDER_ == {INBOX} || _FROM_ >> {Andres} =&gt; _REPLY_{You wrote:}
+ 
+ <P>Observe that the construction 
+ 
+ <P> _TOKEN_ == {value1} || _TOKEN_ == {value2}
+ 
+ <P>can be shortened to
+ 
+ <P> _TOKEN_ == {value1;value2}
+ 
+ <P> Round parentheses can be used to group some conditions, for example
+ 
+ <P> (_FROM_ &gt;&gt; {Andres} && _FOLDER_ == {INBOX}) || _FROM_ &gt;&gt; {Rubye}
+ 
+ 
+ <P> You can also list your index by nick, in the following way:<BR>
+ _NICK_ != {} => _FROM_ := _REPLACE_{_NICK_}
+ 
+ <P>
+   If you want to open the folder &quot;pine-info&quot; in the first non-read message
+ use the rule:<BR>
+ _FOLDER_ == {pine-info} => _STARTUP_{first-unseen}
+ 
+ <P>
+  If you want to move your deleted messages to a folder, called &quot;Trash&quot;, use
+ the following rule:<BR>
+ _FLAG_ >> {D} -> Trash
+ 
+ <P>
+ The reason why the above test is not &quot;_FLAG_ == {D}&quot; is because that would mean
+ that this is the only flag set in the message. It's better to test by containment in this case.
+ 
+ <P> If you want to use a specific signature when you are in a specific collection
+ use the following rule:<BR>
+ _COLLECTION_ == {Mail} => _SIGNATURE_{/full/path/to/.signature}
+ 
+ <P> Finally about the question of which rule will be executed. Only the
+ first rule that matches will be executed. It is important to notice though
+ that &quot;saving&quot; rules do not compete with &quot;sorting&quot; rules. So the first
+ &quot;saving&quot; rule that matches will be executed in the case of saving and so
+ on.
+ 
+ <P>
+ <UL>
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_char_set =====
  <HTML>
  <HEAD>
***************
*** 22838,22843 ****
--- 24244,24286 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_special_text_to_color =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: <!--#echo var="VAR_special-text-color"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: <!--#echo var="VAR_special-text-color"--></H1>
+ 
+ Use this option to enter patterns (text or regular expressions) that 
+ Alpine will highlight in the body of the text that is not part of a handle 
+ (an internal or external link that Alpine paints in a different color).
+ 
+ <P> 
+ Enter each pattern in a different line. Pine will internally merge these 
+ patterns (by adding a "|" character), or you can add them all in one line 
+ by separating them by a "|" character. There is only a <A 
+ HREF="h_regex_text">set</A> of regular expressions that are matched.
+ 
+ <P>
+ Pine will use the colors defined in the 
+ <A HREF="h_config_special_text_color">Special Text Color</A> variable. 
+ to paint any match.
+ 
+ <P> 
+ If the Special Text Color is not set, setting this variable will not
+ cause that special text to be indicated in any special way. It will look
+ like any normal text. You must set those colors in order to make Pine
+ paint the screen differently when it finds the patterns specified in this
+ variable.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_display_filters =====
  <HTML>
  <HEAD>
***************
*** 23002,23007 ****
--- 24445,24456 ----
  Command Modifying Tokens:
  
  <DL>
+ <DT>_ADDRESS_</DT>
+ <DD>When the command is executed, this token is replaced 
+ with the address of the person sending the message in the format
+ mailbox@host.
+ </DD>
+ 
  <DT>_RECIPIENTS_</DT>
  <DD>When the command is executed, this token is replaced 
  with the space delimited list of recipients of the 
***************
*** 26114,26119 ****
--- 27563,27638 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_thread_display_style_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Threading-Display-Style-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Threading-Display-Style-Rule</H1>
+ 
+ This option is very similar to <A HREF="h_config_thread_disp_style">
+ <!--#echo var="VAR_threading-display-style"--></A>, but it is a rule which specifies the
+ display styles for a thread that you want displayed in a specific
+ folder or collection.
+ <P>
+ The token to be used in this function is _THREADSTYLE_. Here there is
+ an example of its use
+ <P>
+ _FOLDER_ == {pine-info} => _THREADSTYLE_{mutt-like}
+ <P>
+ The values that can be given for the _THREADSTYLE_ function are the
+ values of the threading-display-style function, which can be found
+ listed in the <A HREF="h_config_thread_disp_style">threading-display-style</A>
+ configuration option.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
+ ====== h_config_thread_index_style_rule =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Threading-Index-Style-Rule</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Threading-Index-Style-Rule</H1>
+ 
+ This option is very similar to <A HREF="h_config_thread_index_style">
+ <!--#echo var="VAR_threading-index-style"--></A>, but it is a rule which specifies the
+ index styles for a thread that you want displayed in a specific
+ folder or collection.
+ <P>
+ The token to be used in this function is _THREADINDEX_. Here there is
+ an example of its use
+ <P>
+ _FOLDER_ == {pine-info} => _THREADINDEX_{regular-index-with-expanded-threads}
+ <P>
+ The values that can be given for the _THREADINDEX_ function are the
+ values of the threading-index-display function, which can be found
+ listed in the <A HREF="h_config_thread_index_style"><!--#echo var="VAR_threading-index-style"--></A>
+ configuration option.
+ 
+ <P> This configuration option is just one of many that allow you to
+ override the value of some global configurations within Alpine. There is a
+ help text explaining how to define all of them, which you can read by
+ following this <A HREF="h_config_new_rules">link</A>.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_pruning_rule =====
  <HTML>
  <HEAD>
***************
*** 28020,28025 ****
--- 29539,29560 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_use_domain =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: <!--#echo var="FEAT_return-path-uses-domain-name"--> </TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: <!--#echo var="FEAT_return-path-uses-domain-name"--></H1>
+ 
+ If you enable this configuration option Pine will use your domain name and your
+ username in that domain name to construct your Return-Path header, if not Pine
+ will use the address that you have set in the From: field to construct it.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_use_sender_not_x =====
  <HTML>
  <HEAD>
***************
*** 28616,28621 ****
--- 30151,30221 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_alt_reply_menu =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: <!--#echo var="FEAT_alternate-reply-menu"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: <!--#echo var="FEAT_alternate-reply-menu"--></H1>
+ 
+ This feature controls the menu that is displayed when Reply is selected.
+ If set, a list of options will be presented, with each option representing
+ the type of composition that could be used. This feature is most useful
+ for users who want to avoid being prompted with each option separately, or
+ would like to override some defaults set in your configuration for the
+ message that you are replying (e.g. you may have set the option to strip
+ signatures, but for the message you are answering you would like not to do
+ that)
+ 
+ <P>
+ The way this feature works is as follows. Initially you get the question 
+ if you want to include the message, and in the menu you will see several 
+ options, each option is accompanied by some text explaining what will 
+ happen if you press the associated command. For example, if you read the 
+ text &quot;S Strip Sig&quot;, it means that if you press the letter 
+ &quot;S&quot; the signature will be stripped off the message you are 
+ replying. Observer that the menu will change to 
+ &quot;S No Strip&quot;, which means that if you press &quot;S&quot;, the 
+ signature will not be stripped off from the message. Your choices are
+ activated when you press RETURN.
+ 
+ <P>
+ Another way to remember what Pine will do, is that what will be done is
+ exactly the opposite of what you read in the menu.
+ 
+ <P>
+ The possible options are:
+ 
+ <OL>
+ <LI> A: This determines if Pine will include or not the attachments sent to
+ you in the message that you are replying. By default Pine will use the value
+ of the configuration option 
+ <A HREF="h_config_attach_in_reply"><!--#echo var="FEAT_include-attachments-in-reply"--></A>, but
+ you can use this option to override such behavior in a per message basis.
+ 
+ <LI> F: To decide if you want to send flowed text or not. This option appears
+ unless you have quelled sending flowed text.
+ 
+ <LI> H: This option determines if the headers of a message are to be 
+ included in the body of the message that is being replied. By default Pine 
+ will use the value of the configuration option 
+ <A HREF="h_config_include_header"><!--#echo var="FEAT_include-header-in-reply"--></A>, but 
+ you can use this option to override such behavior in a per message basis.
+ 
+ <LI> R: To set a role, if you do not want Pine to set one automatically for you
+ or would like to set one when you can not select any.
+ 
+ <LI> S: To strip the signature from a message, only available is the feature
+         <a href="h_config_sigdashes"><!--#echo var="FEAT_enable-sigdashes"--></a> or the
+ <a href="h_config_strip_sigdashes"><!--#echo var="FEAT_strip-from-sigdashes-on-reply"--></a> option are
+ enabled.
+ 
+ </OL>
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_del_from_dot =====
  <HTML>
  <HEAD>
***************
*** 29139,29144 ****
--- 30739,30776 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_enable_long_url =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: <!--#echo var="FEAT_enable-msg-view-long-url"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: <!--#echo var="FEAT_enable-msg-view-long-url"--></H1>
+ 
+ This feature modifies the behavior of Alpine's MESSAGE TEXT screen. When this feature
+ is set alpine will attempt to recognize long urls (those that spread over several
+ lines in the text) for the HTTP protocol, even when they have not been enclosed between
+ delimiters &quot;&lt;&quot; and &quot;&gt;&quot;.
+ 
+ <P>The normal behavior in Alpine is that if a URL is preceeded by the &quot;&lt;&quot;
+ character and this URL was not finished before the end of the line, then a
+ continuation of the URL is searched in the following line(s). Normally, this type of
+ URLs will be ended by the &quot;&gt;&quot; character, and if it is not, there is a
+ possibility of including erroneous text into the URL.
+ 
+ <P>Enabling this feature will make Alpine search for a continuation of certain URLs in
+ lines following its location. This will be of great help most times, but in some cases
+ the algorithm will catch some text into the URL that is not part of the URL.
+ 
+ <P>If you find that Alpine failed to recognize correctly a URL simply edit the URL before
+ passing it to your browser.
+ 
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_enable_view_addresses =====
  <HTML>
  <HEAD>
***************
*** 29173,29178 ****
--- 30805,30831 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_circular_tab =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: <!--#echo var="FEAT_enable-circular-tab"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: <!--#echo var="FEAT_enable-circular-tab"--></H1>
+ 
+ <P> 
+ This Feature is like 
+ <A HREF="h_config_auto_open_unread">&quot;<!--#echo var="FEAT_auto-open-next-unread"-->&quot;</A>, 
+ in the sense that you can use TAB to browse through all of your Incoming
+ Folders checking for new mail. Once it gets to the last folder of the
+ collection it goes back to check again until it returns to the original
+ folder where it started.
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_enable_view_arrows =====
  <HTML>
  <HEAD>
***************
*** 29446,29451 ****
--- 31099,31147 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_courier_list =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: <!--#echo var="FEAT_courier-folder-list"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: <!--#echo var="FEAT_courier-folder-list"--></H1>
+ 
+ In a maildir collection, a folder could be used as a directory to store 
+ folders. In the Courier server if you create a folder, then a directory 
+ with the same name is created. If you use this patch to access a 
+ collection created by the Courier server, then the display of such 
+ collection will look confusing. The best way to access a maildir 
+ collection created by the Courier server is by using the &quot;#mc/&quot; 
+ prefix instead of the &quot;#md/&quot; prefix. If you use this alternate 
+ prefix, then this feature applies to you, otherwise you can safely ignore 
+ the text that follows.
+ <P>
+ Depending on if you have enabled the option 
+ <a href="h_config_separate_fold_dir_view"><!--#echo var="FEAT_separate-folder-and-directory-entries"--></a> 
+ a folder may be listed as &quot;folder[.]&quot;, or as two entries in the 
+ list by &quot;folder&quot; and &quot;folder.&quot;.
+ <P>
+ If this option is disabled, Pine will list local folders that are in Courier
+ style format, as &quot;folder&quot;, and those that are also directories as
+ &quot;folder[.]&quot;. This makes the default display cleaner.
+ <P>
+ If this feature is enabled then creating folders in a maildir collection
+ will create a directory with the same name. If this feature is disabled, then 
+ a folder is considered a directory only if it contains subfolders, so you can
+ not create a directory with the same name as an exisiting folder unless 
+ you create a subfolder of that folder first (e.g. if you have a folder
+ called &quot;foo&quot; simply add &quot;foo.bar&quot; directly. This will
+ create the directory &quot;foo&quot; and the subfolder &quot;bar&quot; of it).
+ <P>
+ Observe that this feature works only for maildir collections that are accessed
+ locally. If a collection is accessed remotely then this feature has no value,
+ as the report is created in a server, and Pine only reports what received
+ from the server in this case.
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_verbose_post =====
  <HTML>
  <HEAD>
***************
*** 29600,29605 ****
--- 31296,31324 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_auto_read_msgs_rules =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: auto-move-read-msgs-using-rules</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: auto-move-read-msgs-using-rules</H1>
+ This feature controls an aspect of Alpine's behavior upon quitting.  If set,
+ and the 
+ <A HREF="h_config_read_message_folder">&quot;<!--#echo var="VAR_read-message-folder"-->&quot;</A>
+ option is also set, then Alpine will automatically transfer all read
+ messages to the designated folder using the rules that you have defined in
+ your
+ <A HREF="h_config_save_rules">&quot;<!--#echo var="VAR_save-rules"-->&quot;</A> and mark
+ them as deleted in the INBOX.  Messages in the INBOX marked with an 
+ &quot;N&quot; (meaning New, or unseen) are not affected.
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_auto_fcc_only =====
  <HTML>
  <HEAD>
***************
*** 30050,30055 ****
--- 31769,31791 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_enhanced_thread =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: <!--#echo var="FEAT_enhanced-fancy-thread-support"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: <!--#echo var="FEAT_enhanced-fancy-thread-support"--></H1>
+ 
+ If this option is set certain commands in Pine will operate in loose
+ threads too. For example, the command ^R marks a thread deleted, but if
+ this feature is set, it will remove all threads that share the same missing
+ parent with this thread.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_news_cross_deletes =====
  <HTML>
  <HEAD>
***************
*** 30528,30533 ****
--- 32264,32303 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_ignore_size =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: <!--#echo var="FEAT_ignore-size-changes"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: <!--#echo var="FEAT_ignore-size-changes"--></H1>
+ 
+ When you have an account residing in an IMAP server, Alpine gets the size of 
+ each message from the server. However, when Alpine saves a message residing 
+ in an IMAP server, Alpine computes the size of the message independently. If 
+ these two numbers do not match for a message, Alpine asks you if you still
+ want to take the risk of saving the message, since data corruption or loss
+ of data could result of this save.
+ 
+ <P>
+ Sometimes the root of this problem is that the server is defective, and 
+ there will not be loss of information when saving such message. Enabling 
+ this feature will make Aline ignore such error and continue saving the 
+ message. If you can determine that this is the case, enable this feature 
+ so that the saving operation will succeed. An example of a defective server
+ is the Gmail IMAP server. Another example is some versions of the Exchange
+ server.
+ 
+ <P>
+ It is recommended that this feature be disabled most of the time and only 
+ enabled when you find a server which you can determine that has the above 
+ mentioned defect, but be disabled again after making this operation 
+ succeed.
+ 
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_force_low_speed =====
  <HTML>
  <HEAD>
***************
*** 31215,31220 ****
--- 32985,33014 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_special_text_color =====
+ <HTML>
+ <HEAD>
+ <TITLE>OPTION: Special Text Color</TITLE>
+ </HEAD>
+ <BODY>
+ <H1>OPTION: Special Text Color</H1>
+ 
+ Sets the color Pine uses for coloring any text in the body of the message
+ that is not part of a handle (and internal or external link that Pine 
+ paints in a different color). By default, this variable is not defined, 
+ which means that text that matches the pattern is not painted in any
+ particular way. This variable must be set in a special form if you
+ want text to be painted.
+ 
+ <P>
+ <A HREF="h_color_setup">Descriptions of the available commands</A>
+ <P>
+ Look <A HREF="h_edit_nav_cmds">here</A>
+ to see the available Editing and Navigation commands.
+ <P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_index_arrow_color =====
  <HTML>
  <HEAD>
***************
*** 33024,33029 ****
--- 34818,34845 ----
  &lt;End of help on this topic&gt;
  </BODY>
  </HTML>
+ ====== h_config_mark_for_group =====
+ <HTML>
+ <HEAD>
+ <TITLE>FEATURE: <!--#echo var="FEAT_mark-for-me-in-group"--></TITLE>
+ </HEAD>
+ <BODY>
+ <H1>FEATURE: <!--#echo var="FEAT_mark-for-me-in-group"--></H1>
+ 
+ This feature affects Alpine's MESSAGE INDEX display.
+ By default, a '+' is displayed in the first column if the
+ message is addressed directly to you.
+ When this feature is set and the message is addressed to you as part of a group message
+ (that is, your address appears in the To: field, but there is more than one recipient), then a
+ '.' character is displayed instead.
+ 
+ <P>
+ <UL>   
+ <LI><A HREF="h_finding_help">Finding more information and requesting help</A>
+ </UL><P>
+ &lt;End of help on this topic&gt;
+ </BODY>
+ </HTML>
  ====== h_config_mark_for_cc =====
  <HTML>
  <HEAD>
***************
*** 33033,33039 ****
  <H1>FEATURE: <!--#echo var="FEAT_mark-for-cc"--></H1>
  
  This feature affects Alpine's MESSAGE INDEX display.
! By default, a '+' is displayed in the first column if the
  message is addressed directly to you.
  When this feature is set and the message is not addressed to you, then a
  '-' character is displayed if the message is instead Cc'd directly
--- 34849,34855 ----
  <H1>FEATURE: <!--#echo var="FEAT_mark-for-cc"--></H1>
  
  This feature affects Alpine's MESSAGE INDEX display.
! By default, a '+' or a '.' is displayed in the first column if the
  message is addressed directly to you.
  When this feature is set and the message is not addressed to you, then a
  '-' character is displayed if the message is instead Cc'd directly
diff -rc alpine-2.11/pith/reply.c alpine-2.11.I.USE/pith/reply.c
*** alpine-2.11/pith/reply.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/reply.c	2013-12-01 16:36:01.000000000 -0700
***************
*** 46,51 ****
--- 46,53 ----
  #include "../pith/ablookup.h"
  #include "../pith/mailcmd.h"
  #include "../pith/margin.h"
+ #include "../pith/copyaddr.h"
+ #include "../pith/rules.h"
  
  
  /*
***************
*** 814,821 ****
  reply_quote_str(ENVELOPE *env)
  {
      char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];
  
!     strncpy(buf, ps_global->VAR_REPLY_STRING, sizeof(buf)-1);
      buf[sizeof(buf)-1] = '\0';
  
      /* set up the prefix to quote included text */
--- 816,842 ----
  reply_quote_str(ENVELOPE *env)
  {
      char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];
+     char reply_string[MAX_PREFIX+1];
  
!     { RULE_RESULT *rule;
!       rule = get_result_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE , env);
!        if (rule){
!            strncpy(reply_string,rule->result,sizeof(reply_string));
! 	   reply_string[sizeof(reply_string)-1] = '\0';
!            if (rule->result)
! 	      fs_give((void **)&rule->result);
! 	   fs_give((void **)&rule);
!        }
!        else
! 	  if ((ps_global->VAR_REPLY_STRING) && (ps_global->VAR_REPLY_STRING[0])){
! 	    strncpy(reply_string,ps_global->VAR_REPLY_STRING, sizeof(reply_string)-1);
! 	    reply_string[sizeof(reply_string)-1] = '\0';
! 	  }
! 	  else
!            strncpy(reply_string,"> ",sizeof("> "));
!     }
! 
!     strncpy(buf, reply_string, sizeof(buf)-1);
      buf[sizeof(buf)-1] = '\0';
  
      /* set up the prefix to quote included text */
***************
*** 867,876 ****
  int
  reply_quote_str_contains_tokens(void)
  {
!     return(ps_global->VAR_REPLY_STRING && ps_global->VAR_REPLY_STRING[0] &&
! 	   (strstr(ps_global->VAR_REPLY_STRING, from_token) ||
! 	    strstr(ps_global->VAR_REPLY_STRING, nick_token) ||
! 	    strstr(ps_global->VAR_REPLY_STRING, init_token)));
  }
  
  
--- 888,916 ----
  int
  reply_quote_str_contains_tokens(void)
  {
!    char *reply_string;
!       
!    reply_string = (char *) malloc( 80*sizeof(char));
!    { RULE_RESULT *rule;
!      rule = get_result_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE, NULL);
!       if (rule){
!           reply_string = cpystr(rule->result);
! 	  if (rule->result)
! 	     fs_give((void **)&rule->result);
! 	  fs_give((void **)&rule);
!       }
!       else
! 	  if ((ps_global->VAR_REPLY_STRING) && (ps_global->VAR_REPLY_STRING[0])){
! 	    strncpy(reply_string,ps_global->VAR_REPLY_STRING, sizeof(reply_string)-1);
! 	    reply_string[sizeof(reply_string)-1] = '\0';
! 	  }
! 	  else
!           reply_string = cpystr("> ");
!    }
!     return(reply_string && reply_string[0] &&
! 	   (strstr(reply_string, from_token) ||
! 	    strstr(reply_string, nick_token) ||
! 	    strstr(reply_string, init_token)));
  }
  
  
***************
*** 972,978 ****
  	if(!orig_body
  	   || orig_body->type == TYPETEXT
  	   || reply_raw_body
! 	   || F_OFF(F_ATTACHMENTS_IN_REPLY, ps_global)){
  	    char *charset = NULL;
  
  	    /*------ Simple text-only message ----*/
--- 1012,1018 ----
  	if(!orig_body
  	   || orig_body->type == TYPETEXT
  	   || reply_raw_body
! 	   || !ps_global->reply.attach){
  	    char *charset = NULL;
  
  	    /*------ Simple text-only message ----*/
***************
*** 980,986 ****
  	    body->type		     = TYPETEXT;
  	    body->contents.text.data = msgtext;
  	    reply_delimiter(env, role, pc);
! 	    if(F_ON(F_INCLUDE_HEADER, ps_global))
  	      reply_forward_header(stream, msgno, sect_prefix,
  				   env, pc, prefix);
  
--- 1020,1026 ----
  	    body->type		     = TYPETEXT;
  	    body->contents.text.data = msgtext;
  	    reply_delimiter(env, role, pc);
! 	    if(ps_global->reply.inchdr)
  	      reply_forward_header(stream, msgno, sect_prefix,
  				   env, pc, prefix);
  
***************
*** 1038,1044 ****
  
  		if(reply_body_text(orig_body, &tmp_body)){
  		    reply_delimiter(env, role, pc);
! 		    if(F_ON(F_INCLUDE_HEADER, ps_global))
  		      reply_forward_header(stream, msgno, sect_prefix,
  					   env, pc, prefix);
  
--- 1078,1084 ----
  
  		if(reply_body_text(orig_body, &tmp_body)){
  		    reply_delimiter(env, role, pc);
! 		    if(ps_global->reply.inchdr)
  		      reply_forward_header(stream, msgno, sect_prefix,
  					   env, pc, prefix);
  
***************
*** 1076,1082 ****
  		        body->nested.part->body.subtype = cpystr("Plain");
  		    }
  		    reply_delimiter(env, role, pc);
! 		    if(F_ON(F_INCLUDE_HEADER, ps_global))
  		      reply_forward_header(stream, msgno, sect_prefix,
  					   env, pc, prefix);
  
--- 1116,1122 ----
  		        body->nested.part->body.subtype = cpystr("Plain");
  		    }
  		    reply_delimiter(env, role, pc);
! 		    if(ps_global->reply.inchdr)
  		      reply_forward_header(stream, msgno, sect_prefix,
  					   env, pc, prefix);
  
***************
*** 1099,1105 ****
  		    int partnum;
  
  		    reply_delimiter(env, role, pc);
! 		    if(F_ON(F_INCLUDE_HEADER, ps_global))
  		      reply_forward_header(stream, msgno, sect_prefix,
  					   env, pc, prefix);
  
--- 1139,1145 ----
  		    int partnum;
  
  		    reply_delimiter(env, role, pc);
! 		    if(ps_global->reply.inchdr)
  		      reply_forward_header(stream, msgno, sect_prefix,
  					   env, pc, prefix);
  
***************
*** 1334,1339 ****
--- 1374,1383 ----
      buf[0] = '\0';
  
      switch(type){
+       case iFfrom:
+ 	addr = env && env->sparep ? env->sparep : NULL;
+ 	break;
+ 
        case iFrom:
  	addr = env ? env->from : NULL;
  	break;
***************
*** 1719,1739 ****
  
  	break;
  
        case iFrom:
        case iTo:
        case iCc:
        case iSender:
        case iRecips:
        case iInit:
  	get_addr_data(env, type, buf, maxlen);
  	break;
  
!       case iRoleNick:
! 	if(role && role->nick){
! 	    strncpy(buf, role->nick, maxlen);
! 	    buf[maxlen] = '\0';
! 	}
! 	break;
  
        case iNewLine:
  	if(maxlen >= strlen(NEWLINE)){
--- 1763,1912 ----
  
  	break;
  
+       case iProcid:
+         if(ps_global->procid){
+ 	   strncpy(buf, ps_global->procid, maxlen);
+ 	   buf[maxlen] = '\0';
+ 	}
+       break;
+ 
+       case iRole:
+         if (ps_global->role){
+ 	   strncpy(buf, ps_global->role, maxlen);
+ 	   buf[maxlen] = '\0';
+ 	}
+       break;
+ 
+       case iRoleNick:
+ 	if(role && role->nick){
+ 	  strncpy(buf, role->nick, maxlen);
+ 	  buf[maxlen] = '\0';
+ 	}
+ 	break;
+ 
+       case iPkey:
+ 	if(ps_global->pressed_key){
+ 	  strcpy(buf, ps_global->pressed_key);
+ 	  buf[maxlen] = '\0';
+ 	}
+ 	break;
+ 
+       case iScreen:
+ 	if(ps_global->screen_name){
+ 	  strncpy(buf, ps_global->screen_name, maxlen);
+ 	  buf[maxlen] = '\0';
+ 	}
+ 	break;
+ 
+       case iFfrom:
        case iFrom:
        case iTo:
        case iCc:
        case iSender:
        case iRecips:
        case iInit:
+       if (env)  
  	get_addr_data(env, type, buf, maxlen);
  	break;
  
!      case iFolder:
! 	if(ps_global->cur_folder){
! 	  strncpy(buf,ps_global->cur_folder, maxlen);
! 	  buf[maxlen] = '\0';
! 	}
!       break;
! 
!      case iCollection:
! 	if(ps_global->context_current->nickname){
! 	  strncpy(buf,ps_global->context_current->nickname, maxlen);
! 	  buf[maxlen] = '\0';
! 	}
!       break;
!       
!      case iFlag:
!         {MAILSTREAM *stream = ps_global->mail_stream;
! 	 MSGNO_S *msgmap = NULL;
!          long msgno;
!          MESSAGECACHE *mc;
! 	 strncpy(buf, "_FLAG_", maxlen);	/* default value */
! 	 if (stream){
! 	     msgmap = sp_msgmap(stream);
! 	     msgno =  mn_m2raw(msgmap, rules_cursor_pos(stream));
! 	     if (msgno > 0L) mc = stream ? mail_elt(stream,  msgno) : NULL;
! 	     if (mc)
! 	        sprintf(buf,"%s%s%s%s",mc->flagged ? "*" : "",
!                 mc->recent   ? (mc->seen ? "R" : "N") : (mc->seen) ? "R" : "U",
!                 mc->answered ? "A" : "",
!                 mc->deleted  ? "D" : "" );
! 	 }
! 	 buf[maxlen] = '\0';
!         }
!         break;
!          
!      case iNick:
!      {
!       ADDRESS *tmp_adr = NULL;
!       if (env){
!          tmp_adr = env->from ? copyaddr(env->from)
!                      : env->sender ? copyaddr(env->sender) : NULL;
!          get_nickname_from_addr(tmp_adr,buf,maxlen);
! 	 mail_free_address(&tmp_adr);
!       }
!      }
!         break;
! 
!      case iAddressCc:
!      case iAddressRecip:
!      case iAddressTo:
!      case iFadd:
!      {
!      int plen = 0; 	/* partial length */
!      ADDRESS *sparep2 = (type == iAddressTo || type == iAddressRecip) 
! 			? ((env && env->to) 
! 			   ? copyaddrlist(env->to)
! 			   : NULL)
! 			: (type == iAddressCc)
! 			    ? ((env && env->cc) 
! 				? copyaddrlist(env->cc)
! 				: NULL)
! 			    : ((env && env->sparep) 
! 				? copyaddr((ADDRESS *)env->sparep)
! 				: NULL);
!       ADDRESS *sparep;
! 
!       if (type == iAddressRecip){
! 	  ADDRESS *last_to = NULL;
! 
! 	for(last_to = sparep2;last_to && last_to->next; last_to= last_to->next);
! 	
! 	/* Make the end of To list point to cc list */
! 	if(last_to)
! 	  last_to->next = (env && env->cc ? copyaddrlist(env->cc) : NULL);
! 
!       }
!       sparep = sparep2;
!       for(; sparep ; sparep = sparep->next)
! 	if(sparep && sparep->mailbox && sparep->mailbox[0] &&
! 	   (plen ? plen + 1 : plen) + strlen(sparep->mailbox) <= maxlen){
! 	   if (plen == 0)
! 	       strcpy(buf, sparep->mailbox);
! 	   else{
! 	       strcat(buf, " ");
! 	       strcat(buf, sparep->mailbox);
! 	   }
! 	   if(sparep->host &&
!         	   sparep->host[0] &&
! 		   sparep->host[0] != '.' &&
! 		   strlen(buf) + strlen(sparep->host) + 1 <= maxlen){
! 	      strcat(buf, "@");
!               strcat(buf, sparep->host);
!            }
! 	   plen = strlen(buf);
! 	}
! 	 mail_free_address(&sparep2);
!      }
!          
!       break;  
  
        case iNewLine:
  	if(maxlen >= strlen(NEWLINE)){
***************
*** 1762,1767 ****
--- 1935,1945 ----
  
  	break;
  
+       case iLcc:	/* fake it, there are not enough spare pointers */
+ 	if (env && env->date)
+ 	  sprintf(buf,"%s",env->date);
+ 	break;
+ 
        case iNews:
        case iCurNews:
  	get_news_data(env, type, buf, maxlen);
***************
*** 1811,1816 ****
--- 1989,2002 ----
  
  	break;
  
+       case iOpeningText:
+       case iOpeningTextNQ:
+ 	if(env && env->sparep){
+ 	   strncpy(buf, ((SPAREP_S *)env->sparep)->value, maxlen);
+ 	   buf[maxlen] = '\0';
+ 	}
+ 	break;
+ 
        case iSubject:
  	if(env && env->subject){
  	    size_t n, len;
***************
*** 1869,1875 ****
      if(!env)
        return;
  
!     strncpy(buf, ps_global->VAR_REPLY_INTRO, MAX_DELIM);
      buf[MAX_DELIM] = '\0';
      /* preserve exact default behavior from before */
      if(!strcmp(buf, DEFAULT_REPLY_INTRO)){
--- 2055,2072 ----
      if(!env)
        return;
  
!     { RULE_RESULT *rule;
! 	rule = get_result_rule(V_REPLY_LEADIN_RULES, FOR_REPLY_INTRO, env);
! 	if(rule){
! 	   strncpy(buf, rule->result, MAX_DELIM);
! 	   if (rule->result)
! 	      fs_give((void **)&rule->result);
! 	   fs_give((void **)&rule);
! 	}
! 	else
! 	  strncpy(buf, ps_global->VAR_REPLY_INTRO, MAX_DELIM);
!     }
! 
      buf[MAX_DELIM] = '\0';
      /* preserve exact default behavior from before */
      if(!strcmp(buf, DEFAULT_REPLY_INTRO)){
***************
*** 2128,2133 ****
--- 2325,2331 ----
  {
      size_t l;
      char  *p, buftmp[MAILTMPLEN];
+     RULE_RESULT *rule;
      
      if(!env)
        return(NULL);
***************
*** 2135,2143 ****
      dprint((9, "checking subject: \"%s\"\n",
  	       env->subject ? env->subject : "NULL"));
  
!     if(env->subject && env->subject[0]){		/* add (fwd)? */
! 	snprintf(buftmp, sizeof(buftmp), "%s", env->subject);
! 	buftmp[sizeof(buftmp)-1] = '\0';
  	/* decode any 8bit (copy to the temp buffer if decoding doesn't) */
  	if(rfc1522_decode_to_utf8((unsigned char *) tmp_20k_buf,
  				  SIZEOF_20KBUF, buftmp) == (unsigned char *) buftmp)
--- 2333,2352 ----
      dprint((9, "checking subject: \"%s\"\n",
  	       env->subject ? env->subject : "NULL"));
  
!     buftmp[0] = '\0';
!     ps_global->procid = cpystr("fwd-subject");
!     if (rule = get_result_rule(V_FORWARD_RULES,FOR_COMPOSE, env)){
!        sprintf(buftmp, "%.200s", rule->result);
!        if(rule->result)
!        fs_give((void **)&rule->result);
!        fs_give((void **)&rule);
!     }
!     else if(env->subject)
!        sprintf(buftmp, "%.200s", env->subject);
!     buftmp[sizeof(buftmp)-1] = '\0';
!     fs_give((void **)&ps_global->procid);
! 
!     if(buftmp[0]){            /* add (fwd)? */
  	/* decode any 8bit (copy to the temp buffer if decoding doesn't) */
  	if(rfc1522_decode_to_utf8((unsigned char *) tmp_20k_buf,
  				  SIZEOF_20KBUF, buftmp) == (unsigned char *) buftmp)
***************
*** 2638,2646 ****
   		 * tied our hands, alter the prefix to continue flowed
   		 * formatting...
   		 */
!  		if(flow_res)
  		  wrapflags |= GFW_FLOW_RESULT;
  
  		filters[filtcnt].filter = gf_wrap;
  		/* 
  		 * The 80 will cause longer lines than what is likely
--- 2847,2858 ----
   		 * tied our hands, alter the prefix to continue flowed
   		 * formatting...
   		 */
!  		if(flow_res && !ps_global->reply.no_send_flowed)
  		  wrapflags |= GFW_FLOW_RESULT;
  
+ 		filters[filtcnt].filter = gf_quote_test;
+ 		filters[filtcnt++].data = gf_line_test_opt(select_quote, NULL);
+ 
  		filters[filtcnt].filter = gf_wrap;
  		/* 
  		 * The 80 will cause longer lines than what is likely
***************
*** 2674,2682 ****
  	 * We also want to fold "> " quotes so we get the
  	 * attributions correct.
   	 */
! 	if(flow_res && prefix && !strucmp(prefix, "> "))
  	  *(prefix_p = prefix + 1) = '\0';
! 
  	if(!(wrapflags & GFW_FLOWED)
  	   && flow_res){
  	    filters[filtcnt].filter = gf_line_test;
--- 2886,2894 ----
  	 * We also want to fold "> " quotes so we get the
  	 * attributions correct.
   	 */
! 	if(flow_res && !ps_global->reply.no_send_flowed && prefix && !strucmp(prefix, "> "))
  	  *(prefix_p = prefix + 1) = '\0';
! 	ps_global->reply.no_send_flowed = 0; /* reset for next call */
  	if(!(wrapflags & GFW_FLOWED)
  	   && flow_res){
  	    filters[filtcnt].filter = gf_line_test;
***************
*** 2709,2717 ****
      }
  
      if(prefix){
! 	if(ps_global->full_header != 2
! 	   && (F_ON(F_ENABLE_SIGDASHES, ps_global)
! 	       || F_ON(F_ENABLE_STRIP_SIGDASHES, ps_global))){
  	    dashdata = 0;
  	    filters[filtcnt].filter = gf_line_test;
  	    filters[filtcnt++].data = gf_line_test_opt(sigdash_strip, &dashdata);
--- 2921,2927 ----
      }
  
      if(prefix){
! 	if(ps_global->reply.strip){
  	    dashdata = 0;
  	    filters[filtcnt].filter = gf_line_test;
  	    filters[filtcnt++].data = gf_line_test_opt(sigdash_strip, &dashdata);
***************
*** 2736,2742 ****
  	dq.do_color   = 0;
  	dq.delete_all = 1;
  
! 	filters[filtcnt].filter = gf_line_test;
  	filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &dq);
      }
  
--- 2946,2952 ----
  	dq.do_color   = 0;
  	dq.delete_all = 1;
  
! 	filters[filtcnt].filter = gf_quote_test;
  	filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &dq);
      }
  
diff -rc alpine-2.11/pith/rules.c alpine-2.11.I.USE/pith/rules.c
*** alpine-2.11/pith/rules.c	2013-12-01 16:41:34.000000000 -0700
--- alpine-2.11.I.USE/pith/rules.c	2013-12-01 16:34:57.000000000 -0700
***************
*** 0 ****
--- 1,1406 ----
+ /* This module was written by
+  *
+  * Eduardo Chappa (chappa@washington.edu)
+  * http://patches.freeiz.com/alpine/
+  *
+  *  Original Version: November 1999
+  *  Last Modified   : September 14, 2013
+  *
+  * Send bug reports about this module to the address above.
+  */
+ 
+ #include "../pith/headers.h"
+ #include "../pith/state.h"
+ #include "../pith/conf.h"
+ #include "../pith/copyaddr.h"
+ #include "../pith/mailindx.h"
+ #include "../pith/rules.h"
+ 
+ #define CSEP_C	('\001')
+ #define CSEP_S	("\001")
+ 
+ /* Internal Prototypes */
+ 
+ int   test_condition  (CONDITION_S *, int, ENVELOPE *);
+ int   test_in         (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
+ int   test_ni         (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
+ int   test_not_in     (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
+ int   test_not_ni     (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
+ int   test_eq         (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
+ int   test_not_eq     (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
+ int   isolate_condition (char *, char **, int *);
+ int   sanity_check_condition (char *);
+ char  *test_rule      (RULELIST *, int, ENVELOPE *, int *);
+ char  *trim           (RULEACTION_S *, int, ENVELOPE *);
+ char  *rextrim        (RULEACTION_S *, int, ENVELOPE *);
+ char  *raw_value      (RULEACTION_S *, int, ENVELOPE *);
+ char  *extended_value (RULEACTION_S *, int, ENVELOPE *);
+ char  *exec_fcn	      (RULEACTION_S *, int, ENVELOPE *);
+ char  *expand         (char *, void *);
+ char  *get_name_token (char *);
+ char  *advance_to_char (char *, char, int, int *);
+ char  **functions_for_token (char *);
+ char  *canonicalize_condition (char *, int *);
+ void  free_token_value (TOKEN_VALUE **);
+ void  free_condition  (CONDITION_S **);
+ void  free_condition_value (CONDVALUE_S **);
+ void  free_ruleaction (RULEACTION_S **);
+ void  free_rule       (RULE_S **);
+ void  free_rule_list  (RULELIST **);
+ void  free_alloc_rule (void **, int);
+ void  *alloc_mem      (size_t);
+ void  add_rule        (int, int);
+ void  set_rule_list    (struct variable *);
+ void  parse_patterns_into_action(TOKEN_VALUE **);
+ void  free_parsed_value(TOKEN_VALUE **value);
+ RULE_S   *parse_rule  (char *, int);
+ RULELIST *get_rule_list (char **, int, int);
+ TOKEN_VALUE *parse_group_data (char *,int *);
+ TOKEN_VALUE *copy_parsed_value (TOKEN_VALUE *, int, ENVELOPE *);
+ CONDVALUE_S *fill_condition_value (char *);
+ CONDITION_S *fill_condition (char *);
+ CONDITION_S *parse_condition (char *, int *);
+ PRULELIST_S *add_prule        (PRULELIST_S *, PRULELIST_S *);
+ RULEACTION_S *parse_action (char *, int);
+ 
+ REL_TOKEN rel_rules_test[] = {
+    {EQ_REL,     Equal,          test_eq},
+    {IN_REL,     Subset,         test_in},
+    {NI_REL,     Includes,       test_ni},
+    {NOT_EQ_REL, NotEqual,       test_not_eq},
+    {NOT_IN_REL, NotSubset,      test_not_in},
+    {NOT_NI_REL, NotIncludes,    test_not_ni},
+    {NULL,       EndTypes,       NULL}
+ };
+ 
+ #define NREL  (sizeof(rel_rules_test)/sizeof(rel_rules_test[0]) - 1)
+ 
+ RULE_FCN rule_fcns[] = {
+ {COPY_FCN,      extended_value, FOR_SAVE|FOR_COMPOSE},
+ {SAVE_FCN,      extended_value, FOR_SAVE},
+ {EXEC_FCN,	exec_fcn,	FOR_REPLACE|FOR_TRIM|FOR_RESUB|FOR_COMPOSE},
+ {REPLY_FCN,     extended_value, FOR_REPLY_INTRO},
+ {TRIM_FCN,      trim,           FOR_TRIM|FOR_RESUB|FOR_COMPOSE},
+ {REPLACE_FCN,   extended_value, FOR_REPLACE},
+ {SORT_FCN,      raw_value,      FOR_SORT},
+ {INDEX_FCN,     raw_value,      FOR_INDEX},
+ {COMMAND_FCN,   raw_value,      FOR_KEY},
+ {REPLYSTR_FCN,  raw_value,      FOR_COMPOSE},
+ {SIGNATURE_FCN, raw_value,      FOR_COMPOSE},
+ {RESUB_FCN,     extended_value, FOR_RESUB},
+ {STARTUP_FCN,   raw_value,      FOR_STARTUP},
+ {REXTRIM_FCN,   rextrim,        FOR_TRIM|FOR_RESUB|FOR_COMPOSE},
+ {THRDSTYLE_FCN, raw_value,      FOR_THREAD},
+ {THRDINDEX_FCN, raw_value,      FOR_THREAD},
+ {SMTP_FCN,      raw_value,      FOR_COMPOSE},
+ {NULL,          0,              FOR_NOTHING}
+ };
+ 
+ char* token_rules[] = {
+    FROM_TOKEN,
+    NICK_TOKEN,
+    OTEXT_TOKEN,
+    OTEXTNQ_TOKEN,
+    ROLE_TOKEN,
+    FOLDER_TOKEN,
+    SUBJ_TOKEN,
+    PROCID_TOKEN,
+    THDDSPSTY_TOKEN,
+    THDNDXSTY_TOKEN,
+    FLAG_TOKEN,
+    COLLECT_TOKEN,
+    THDDSPSTY_TOKEN,
+    ADDR_TOKEN,
+    TO_TOKEN,
+    ADDTO_TOKEN,
+    ADDCC_TOKEN,
+    ADDRECIP_TOKEN,
+    SCREEN_TOKEN,
+    KEY_TOKEN,
+    SEND_TOKEN,
+    CC_TOKEN,
+    LCC_TOKEN,
+    BCC_TOKEN,
+    FFROM_TOKEN,
+    FADDRESS_TOKEN,
+    NULL
+ };
+ 
+ #define NTOKENS  (sizeof(token_rules)/sizeof(token_rules[0]) - 1)
+ #define NFCN    (sizeof(rule_fcns)/sizeof(rule_fcns[0]) - 1)
+ 
+ char *subj_fcn[]    = {SUBJ_TOKEN,    REPLACE_FCN, TRIM_FCN, REXTRIM_FCN, EXEC_FCN};
+ char *from_fcn[]    = {FROM_TOKEN,    REPLACE_FCN, TRIM_FCN, REXTRIM_FCN, EXEC_FCN};
+ char *otext_fcn[]   = {OTEXT_TOKEN,   REPLACE_FCN, TRIM_FCN, REXTRIM_FCN, EXEC_FCN};
+ char *otextnq_fcn[] = {OTEXTNQ_TOKEN, REPLACE_FCN, TRIM_FCN, REXTRIM_FCN, EXEC_FCN};
+ 
+ char *adto_fcn[] = {ADDTO_TOKEN, EXEC_FCN, NULL, NULL, NULL};
+ 
+ char **fcns_for_index[] = {subj_fcn, from_fcn, otext_fcn, otextnq_fcn};
+ 
+ #define NFCNFI    (sizeof(fcns_for_index)/sizeof(fcns_for_index[0])) /*for idx*/
+ #define NFPT      (sizeof(fcns_for_index[0])) /* functions pert token */
+ 
+ SPAREP_S *
+ get_sparep_for_rule(char *value, int flag)
+ {
+   SPAREP_S *rv;
+   rv = (SPAREP_S *) alloc_mem(sizeof(SPAREP_S));
+   rv->flag = flag;
+   rv->value = value ? cpystr(value) : NULL;
+   return rv;
+ }
+ 
+ void free_sparep_for_rule(void **sparep)
+ {
+   SPAREP_S *spare = (SPAREP_S *) *sparep;
+   if(!spare) return;
+   if(spare->value)
+      fs_give((void **)&spare->value);
+   fs_give((void **)sparep);
+ }
+ 
+ 
+ int context_for_function(char *name)
+ {
+   int i, j;
+   for (i = 0; i < NFCN && strcmp(rule_fcns[i].name, name); i++);
+   return i == NFCN ? 0 : rule_fcns[i].what_for;
+ 
+ }
+ 
+ char **functions_for_token(char *name)
+ {
+   int i;
+   for (i = 0; i < NFCNFI && strcmp(fcns_for_index[i][0], name); i++);
+   return i == NFCNFI ? NULL : fcns_for_index[i];
+ }
+ 
+ void
+ free_alloc_rule (void **voidtext, int code)
+ {
+   switch(code){
+      case FREEREGEX : regfree((regex_t *)*voidtext);
+ 			break;
+ 	default: break;
+   }
+ }
+ 
+ 
+ 
+ void free_token_value(TOKEN_VALUE **token)
+ {
+    if(token && *token){
+      if ((*token)->testxt)
+ 	fs_give((void **)&(*token)->testxt);
+      free_alloc_rule (&(*token)->voidtxt, (*token)->codefcn);
+      if((*token)->next)
+ 	free_token_value(&(*token)->next);
+      fs_give((void **)token);
+    }
+ }
+ 
+ void
+ free_condition_value(CONDVALUE_S **cvalue)
+ {
+   if(cvalue && *cvalue){
+     if ((*cvalue)->tname)
+ 	fs_give((void **)&(*cvalue)->tname);
+     if ((*cvalue)->value)
+ 	free_token_value(&(*cvalue)->value);
+     fs_give((void **)cvalue);
+   }
+ }
+ 
+ void free_condition(CONDITION_S **condition)
+ {
+    if(condition && *condition){
+      if((*condition)->cndtype ==  Condition)
+ 	free_condition_value((CONDVALUE_S **)&(*condition)->cndrule);
+      else if((*condition)->cndtype ==  ParOpen || (*condition)->cndtype ==  ParClose)
+ 	fs_give(&(*condition)->cndrule);
+      if((*condition)->next)
+ 	free_condition(&((*condition)->next));
+      fs_give((void **)condition);
+    }
+ }
+ 
+ void free_ruleaction(RULEACTION_S **raction)
+ {
+    if(raction && *raction){
+      if ((*raction)->token)
+ 	fs_give((void **)&((*raction)->token));
+      if ((*raction)->function)
+ 	fs_give((void **)&((*raction)->function));
+      if ((*raction)->value)
+ 	free_token_value(&(*raction)->value);
+      fs_give((void **)raction);
+    }
+ }
+ 
+ void free_rule(RULE_S **rule)
+ {
+    if(rule && *rule){
+      free_condition(&((*rule)->condition));
+      free_ruleaction(&((*rule)->action));
+      fs_give((void **)rule);
+    }
+ }
+ 
+ void free_rule_list(RULELIST **rule)
+ {
+   if(!*rule)
+     return;
+ 
+   if((*rule)->next)
+     free_rule_list(&((*rule)->next));
+ 
+   if((*rule)->prule)
+     free_rule(&((*rule)->prule));
+ 
+   fs_give((void **)rule);
+ }
+ 
+ void
+ free_parsed_rule_list(PRULELIST_S **rule)
+ {
+   if(!*rule)
+     return;
+ 
+   if((*rule)->next)
+     free_parsed_rule_list(&((*rule)->next));
+ 
+   if((*rule)->rlist)
+     free_rule_list(&((*rule)->rlist));
+ 
+   fs_give((void **)rule);
+ }
+ 
+ void *
+ alloc_mem (size_t amount)
+ {
+    void *genmem;
+    memset(genmem = fs_get(amount), 0, amount);
+    return genmem;
+ }
+ 
+ 
+ void
+ parse_patterns_into_action(TOKEN_VALUE **tokenp)
+ {
+   if(!*tokenp)
+     return;
+ 
+   if((*tokenp)->testxt){
+       regex_t preg;
+ 
+       (*tokenp)->voidtxt = NULL;
+       (*tokenp)->voidtxt = fs_get(sizeof(regex_t));
+       if (regcomp((regex_t *)(*tokenp)->voidtxt, 
+ 			(*tokenp)->testxt, REG_EXTENDED) != 0){
+          regfree((regex_t *)(*tokenp)->voidtxt);
+ 	 (*tokenp)->voidtxt = NULL;
+       }
+   }
+   if((*tokenp)->voidtxt)
+      (*tokenp)->codefcn = FREEREGEX;
+   if((*tokenp)->next)
+      parse_patterns_into_action(&(*tokenp)->next);
+ }
+ 
+ 
+ int
+ isolate_condition (char *data, char **cvalue, int  *len)
+ {
+   char *p = data;
+   int done = 0, error = 0, next_condition = 0, l;
+ 
+   if(*p == '"' && p[strlen(p) - 1] == '"'){
+     p[strlen(p) - 1] = '\0';
+     p++;
+   }
+   *cvalue = NULL;
+   while (*p && !done){
+ 	switch (*p){
+ 	   case '_': *cvalue = advance_to_char(p,'}', STRICTLY, NULL);
+ 		     if(*cvalue){
+ 			strcat(*cvalue,"}");
+ 			p += strlen(*cvalue);
+ 		     }
+ 		     else
+ 			error++;
+ 		     done++;
+ 	   case ' ': p++;
+ 		     break;
+ 	   case '&': 
+ 	   case '|': if (*(p+1) == *p){	/* looking for && or ||*/
+ 			p += 2;
+ 			next_condition++;
+ 		     }
+ 		     else{
+ 			error++;
+ 			done++;
+ 		     }
+ 		     break;
+ 	   case '=': /* looking for => or -> */
+ 	   case '-': if (*(p+1) != '>' || next_condition)
+ 			error++;
+ 		     done++;
+ 		     break;
+ 	   default : done++;
+ 		     error++;
+ 		     break;
+ 	}
+   }
+   *len = p - data;
+   return error ? -1 : (*cvalue ? 1 : 0);
+ }
+ 
+ TOKEN_VALUE *
+ parse_group_data (char *data, int *error)
+ {
+   TOKEN_VALUE *rvalue;
+   char *p;
+   int offset, err = 0;
+ 
+   if(error)
+     *error = 0;
+ 
+   if (!data)
+      return (TOKEN_VALUE *) NULL;
+ 
+   rvalue = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
+   if (p = advance_to_char(data,';', STRICTLY, &offset)){
+       rvalue->testxt = p;
+       data += strlen(p) + 1 + offset;
+       rvalue->next   = parse_group_data(data, error);
+   }
+   else if (p = advance_to_char(data,'}', STRICTLY, NULL))
+       rvalue->testxt = p;
+   else if (data && *data == '}')
+       rvalue->testxt = cpystr("");
+   else{
+       err++;
+       free_token_value(&rvalue);
+   }
+   if (error)
+     *error += err;
+   return(rvalue);
+ }
+ 
+ CONDVALUE_S *
+ fill_condition_value(char *data)
+ {
+   CONDVALUE_S *condition;
+   int i, done, error = 0;
+   char *group;
+ 
+   for (i = 0, done = 0; done == 0 && token_rules[i] != NULL; i++)
+       done = strncmp(data,token_rules[i], strlen(token_rules[i])) ? 0 : 1;
+   if (done){
+      condition = alloc_mem(sizeof(CONDVALUE_S));
+      condition->tname = cpystr(token_rules[--i]);
+      data += strlen(token_rules[i]);
+   }
+   else if (*data == '_') {
+       char *itokname;
+       for (i = 0, done = 0; done == 0 && (itokname = itoken(i)->name) != NULL; i++)
+ 	 done = strncmp(data+1, itokname, strlen(itokname))
+ 			? 0 : data[strlen(itokname) + 1] == '_';
+       if (done){
+ 	 condition = (CONDVALUE_S *) alloc_mem(sizeof(CONDVALUE_S));
+ 	 condition->tname = fs_get(strlen(itokname) + 3);
+ 	 sprintf(condition->tname, "_%s_", itokname);
+ 	 data += strlen(itokname) + 2;
+       }
+       else 
+ 	return NULL;
+   } 
+   else
+      return NULL;
+ 
+   for (; *data && *data == ' '; data++);
+   if (*data){
+      for (i = 0, done = 0; done == 0 && rel_rules_test[i].value != NULL; i++)
+        done = strncmp(data, rel_rules_test[i].value, 2) ? 0 : 1;
+      if (done)
+        condition->ttype = rel_rules_test[--i].ttype;
+      else{
+ 	 free_condition_value(&condition);
+ 	 return NULL;
+      }
+   }
+   else{
+     free_condition_value(&condition);
+     return  NULL;
+   }
+ 
+   data += 2;
+   for (; *data && *data == ' '; data++);
+   if (*data++ != '{'){
+      free_condition_value(&condition);
+      return NULL;
+   }
+   group = advance_to_char(data,'}', STRICTLY, &error); 
+   if (group || (!group &&  error < 0)){
+      condition->value = parse_group_data(data, &error);
+      if(group && error)
+ 	free_condition_value(&condition);
+      if(group)
+         fs_give((void **) &group);
+   }
+   else
+      free_condition_value(&condition);
+   return condition;
+ }
+ 
+ char *
+ canonicalize_condition(char *data, int *eoc)
+ {
+   char *p = data, *s, *t, c;
+   char *q = fs_get((5*strlen(data)+1)*sizeof(char));
+   char tmp[10];
+   int level, done, error, i;
+ 
+   if(eoc) *eoc = -1; 	/* assume error */
+   *q = '\0';
+   if(*p == '"'){
+      if(p[strlen(p) - 1] == '"')
+ 	p[strlen(p) - 1] = '\0';
+      p++;
+   }
+   for(level = done = error = 0; *p && !done && !error; ){
+      switch(*p){
+ 	case ' ' : p++; break;
+ 	case '(' : strcat(q, CSEP_S); strcat(q, "(");
+ 		   sprintf(tmp, "%d ", level++);
+ 		   strcat(q, tmp);
+ 		   p++;
+ 		   break;
+ 	case ')' : strcat(q, CSEP_S); strcat(q, ")");
+ 		   sprintf(tmp, "%d ", --level);
+ 		   strcat(q, tmp);
+ 		   p++;
+ 		   if(level < 0) error++;
+ 		   break;
+ 	case '_' : for(s = p+1; *s >= 'A' && *s <= 'Z'; s++);
+ 		   for(i = 0; token_rules[i] != NULL; i++)
+ 		      if(!strncmp(token_rules[i], p, s-p))
+ 			break;
+ 		   if(token_rules[i] == NULL)
+ 		     error++;
+ 		   else if(*s++ == '_'){
+ 		     for(; *s == ' '; s++);
+ 		     if(*s && *(s+1)){
+ 			for(i = 0; rel_rules_test[i].value != NULL; i++)
+ 			   if(!strncmp(rel_rules_test[i].value, s, 2))
+ 			      break;
+ 			if (rel_rules_test[i].value == NULL)
+ 			   error++;
+ 			else{
+ 			   s += 2;
+ 			   for(; *s == ' '; s++);
+ 			   if(*s == '{'){
+ 			     if(*(s+1) != '}')
+ 			       t = advance_to_char(s+1,'}', STRICTLY, NULL);
+ 			     else
+ 			       t = cpystr("");
+ 			     if(t != NULL){
+ 			        for(i = 0; t[i] != '\0' && t[i] != CSEP_C; i++);
+ 				if(t[i] == CSEP_C) error++;
+ 			        if(error == 0){
+ 				   strcat(q, CSEP_S); strcat(q, "C[");
+ 				   s += strlen(t) + 1;	/* get past '{' */
+ 				   *s = '\0';
+ 				   strcat(q, p);
+ 				   strcat(q, "}] ");
+ 				   *s++ = '}';
+ 				   p = s;
+ 			        }
+ 				fs_give((void **) &t);
+ 			     }
+ 			     else error++;
+ 			   }
+ 			   else
+ 			     error++;
+ 			}
+ 		     }
+ 		   }
+ 		   else error++;
+ 		   break;
+ 	case '|':
+ 	case '&': if(*(p+1) = *p){
+ 			strcat(q, CSEP_S); strcat(q, *p == '|' ? "OR " : "AND ");
+ 			p += 2;
+ 		  } else error++;
+ 		  break;
+ 	case '-':
+ 	case '=': if (*(p+1) == '>'){
+ 		    if(eoc) *eoc = p - data;
+ 		    done++;
+ 		  }
+ 		  else
+ 		    error++;
+ 		  break;
+ 	default : error++;
+ 		  break;
+      }
+   }
+   if(error || level > 0)	/*simplistic approach by now */
+     fs_give((void **)&q);
+   else
+     q[strlen(q)-1] = '\0';
+   return q;
+ }
+ 
+ /* for a canonical condition, return if it is constructed according
+  * to logical rules such as AND or OR between conditions, etc. We assume
+  * we already canonicalized data, or else this will not work.
+  */
+ int
+ sanity_check_condition(char *data)
+ {
+   int i, error;
+   char *s, *t, *d;
+ 
+   if(data == NULL || *data == '\0')	/* no data in, no data out */
+     return 0;
+ 
+   d = fs_get((strlen(data)+1)*sizeof(char));
+   for(s = data,i = 0; (t = strchr(s, CSEP_C))!= NULL && (d[i] = *(t+1)); s = t+1, i++);
+   d[i] = '\0';
+   for(i = 0, error = 0; d[i] != '\0' && error == 0; i++){
+      switch(d[i]){
+ 	case 'C': if((d[i+1] != '\0' && (d[i+1] == '(' || d[i+1] == 'C'))
+ 			|| (i == 0 && d[1] != 'A' && d[1] != 'O' && d[1] != '\0'))
+ 		     error++;
+ 		  break;
+ 	case ')': if(i == 0 || d[i+1] != '\0' && (d[i+1] == 'C' || d[i+1] == '('))
+ 		     error++;
+ 		  break;
+ 	case '(': if(d[i+1] == '\0' || d[i+1] == ')' || d[i+1] == 'A' || d[i+1] == 'O')
+ 		     error++;
+ 		  break;
+ 	case 'O':
+ 	case 'A': if(i == 0 || d[i+1] == '\0' || d[i+1] == ')' || d[i+1] == 'A' || d[i+1] == 'O')
+ 		     error++;
+ 		  break;
+ 	default : error++;
+      }
+   }
+   if(d) fs_give((void **)&d);
+   return error ? 0 : 1;
+ }
+ 
+ /* given a parsed data that satisfies sanity checks, parse it
+  * into a condition we can check later on.
+  */
+ CONDITION_S *
+ fill_condition(char *data)
+ {
+   char *s, *t, *u;
+   CONDITION_S *rv = NULL;
+   CONDVALUE_S *cvalue;
+   int *i;
+ 
+   if(data == NULL || *data == '\0' || (s = strchr(data, CSEP_C)) == NULL)
+     return NULL;
+ 
+   rv = (CONDITION_S *) alloc_mem(sizeof(CONDITION_S));
+   switch(*++s){
+      case ')':
+      case '(':	 i = fs_get(sizeof(int));
+ 		*i = atoi(s+1);
+ 		rv->cndrule = (void *) i;
+ 		rv->cndtype = *s == '(' ? ParOpen : ParClose;
+ 		break;
+ 
+      case 'C':	if((u = strchr(s+2, CSEP_C)) != NULL){
+ 		   *u = '\0';
+ 		   t = strrchr(s, ']');
+ 		   t = '\0';
+ 		   *u = CSEP_C;
+ 		} else
+ 		   s[strlen(s) - 1] = '\0';
+ 		rv->cndrule = (void *) fill_condition_value(s+2);
+ 		rv->cndtype = Condition;
+ 		break;
+ 
+      case 'A':
+      case 'O':  rv->cndtype = *s == 'A' ? And : Or;
+ 		break;
+ 
+      default : fs_give((void **)&rv);
+ 	       break;
+   }
+   rv->next = fill_condition(strchr(s, CSEP_C));
+ 
+   return rv;
+ } 
+ 
+ /* eoc = end of condition, equal to -1 on error */
+ CONDITION_S *
+ parse_condition (char *data, int *eoc)
+ {
+   CONDITION_S *condition = NULL;
+   char *pvalue;
+   
+   if((pvalue = canonicalize_condition(data, eoc)) != NULL
+ 	&& sanity_check_condition(pvalue) > 0)
+     condition = fill_condition(pvalue);
+ 
+   if(pvalue)
+     fs_give((void **)&pvalue);
+ 
+   if (condition == NULL && eoc)
+     *eoc = -1;
+ 
+   return condition;
+ }
+ 
+ RULEACTION_S *
+ parse_action (char *data, int context)
+ {
+   int i, done, is_save;
+   RULEACTION_S *raction = NULL;
+   char *function, *p = data;
+ 
+   if (p == NULL || *p == '\0')
+      return NULL;
+ 
+   is_save = *p == '-';
+   p += 2;
+   for (; *p == ' '; p++);
+ 
+   if (is_save){	/* got "->", a save-rule separator */
+      raction = (RULEACTION_S *) alloc_mem(sizeof(RULEACTION_S));
+      raction->function = cpystr("_SAVE_");
+      raction->value    = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
+      raction->context |= FOR_SAVE;
+      raction->exec     = extended_value;
+      raction->value->testxt = cpystr(p);
+      return raction;
+   }
+   for (i = 0, done = 0; !done && (i < NFCN); i++)
+        done = (strstr(p,rule_fcns[i].name) == p);
+   p += done ? strlen(rule_fcns[--i].name) + 1 : 0;
+   if(!*p || (rule_fcns[i].what_for && !(rule_fcns[i].what_for & context)))
+      return NULL;
+   if (done){
+      raction = alloc_mem(sizeof(RULEACTION_S));
+ 	/* We assign raction->token to be subject. This is not necessary for
+ 	   most rules. It is done only for rules that need it and will not
+ 	   make any difference in rules that do not need it. It will hopefully
+ 	   reduce complexity in the language
+ 	 */
+      raction->token    = cpystr(SUBJ_TOKEN);
+      raction->function = cpystr(rule_fcns[i].name);
+      raction->context  = rule_fcns[i].what_for;
+      raction->exec     = rule_fcns[i].execute;
+      raction->value    = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
+      raction->value->testxt = advance_to_char(p,'}', STRICTLY, NULL);
+      if(!raction->value->testxt)
+        free_ruleaction(&raction);
+      return raction;
+   }
+ 
+   done = (((function = strstr(p, "_TRIM_")) != NULL)
+ 	  ? 1 : ((function = strstr(p, "_COPY_")) != NULL)
+ 	  ? 2 : ((function = strstr(p, "_EXEC_")) != NULL)
+ 	  ? 3 : ((function = strstr(p, "_REXTRIM_")) != NULL)
+ 	  ? 4 : ((function = strstr(p, "_REPLACE_")) != NULL)
+ 	  ? 5 : 0);
+ 
+   if(!function)
+      return (RULEACTION_S *) NULL;
+ 
+   *function = '\0';
+    raction = (RULEACTION_S *) alloc_mem(sizeof(RULEACTION_S));
+    raction->token = get_name_token(p);
+   *function = '_';
+    p += strlen(raction->token) + 1;
+    for (; *p && *p == ' '; p++);
+    if (!strncmp(p, ":=", 2))
+       p += 2;
+    else{
+       free_ruleaction(&raction);
+       return NULL;
+    }
+    for (; *p && *p == ' '; p++);
+    if (p != function){
+       free_ruleaction(&raction);
+       return NULL;
+    }
+    p += done <= 3 ? 6 : 9; /* 6 = strlen("_EXEC_"), 9 = strlen("_REPLACE_") */
+    if (*p != '{'){
+       free_ruleaction(&raction);
+       return NULL;
+    }
+    *p = '\0';
+    for(i = 0; i < NFCN && strcmp(function, rule_fcns[i].name);i++);
+    raction->function   = cpystr(function);
+    raction->is_trim    = strcmp(function,"_TRIM_")    ? 0 : 1;
+    raction->is_rextrim = strcmp(function,"_REXTRIM_") ? 0 : 1;
+    raction->is_replace = strcmp(function,"_REPLACE_") ? 0 : 1;
+    raction->context    = rule_fcns[i].what_for;
+    raction->exec       = rule_fcns[i].execute;
+    *p++ = '{';
+    if((raction->value = parse_group_data(p, NULL)) == NULL 
+ 	|| raction->value->testxt == NULL)
+       free_ruleaction(&raction);
+    if(raction && raction->is_rextrim)
+       parse_patterns_into_action(&raction->value);
+    return raction;
+ }
+ 
+ RULE_S *
+ parse_rule (char *data, int context)
+ {
+   RULE_S *prule;	/*parsed rule */
+   int len = 0;
+   
+   if (!(prule = (RULE_S *) alloc_mem(sizeof(RULE_S))) ||
+ 	!(prule->condition = parse_condition(data, &len)) ||
+ 	!(prule->action = parse_action(data+len, context)))
+       free_rule(&prule);
+ 
+   return prule;
+ }
+ 
+ RULELIST *
+ get_rule_list(char **list, int context, int i)
+ {
+   RULE_S *rule;
+   RULELIST *trulelist = NULL;
+ 
+   if (list[i] && *list[i]){
+      if(rule = parse_rule(list[i], context)){
+ 	trulelist  = (RULELIST *)alloc_mem(sizeof(RULELIST));
+ 	trulelist->prule = rule;
+ 	trulelist->next = get_rule_list(list, context, i+1);
+      }
+      else
+ 	trulelist = get_rule_list(list, context, i+1);
+   }
+   return trulelist;
+ }
+ 
+ PRULELIST_S *
+ add_prule(PRULELIST_S *rule_list, PRULELIST_S *rule)
+ {
+    if (!rule_list)
+       rule_list = (PRULELIST_S *) alloc_mem(sizeof(PRULELIST_S));
+ 
+    if(rule_list->next)
+      rule_list->next = add_prule(rule_list->next, rule);
+    else{
+      if (rule_list->rlist)
+ 	rule_list->next = rule;
+      else
+ 	rule_list = rule;
+    }
+    return rule_list;
+ }  
+ 
+ void
+ add_rule(int code, int context)
+ {
+   char **list = ps_global->vars[code].current_val.l;
+   PRULELIST_S *prulelist, *trulelist, *orulelist;
+ 
+   if (list && *list && **list){
+      trulelist = (PRULELIST_S *)alloc_mem(sizeof(PRULELIST_S));
+      trulelist->varnum = code;
+      if (trulelist->rlist = get_rule_list(list, context, 0))
+         ps_global->rule_list = add_prule(ps_global->rule_list, trulelist);
+      else
+ 	free_parsed_rule_list(&trulelist);
+   }
+ }
+ 
+ /* see create_rule_list below */
+ void
+ set_rule_list(struct variable *vars)
+ {
+     set_current_val(&vars[V_THREAD_DISP_STYLE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_THREAD_INDEX_STYLE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_COMPOSE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_FORWARD_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_INDEX_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_KEY_RULES], FALSE, TRUE);
+     set_current_val(&vars[V_REPLACE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_REPLY_INDENT_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_REPLY_LEADIN_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_RESUB_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SAVE_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SMTP_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_SORT_RULES], TRUE, TRUE);
+     set_current_val(&vars[V_STARTUP_RULES], TRUE, TRUE);
+ }
+ 
+ /* see set_rule_list above */
+ void
+ create_rule_list(struct variable *vars)
+ {
+   set_rule_list(vars);
+   add_rule(V_THREAD_DISP_STYLE_RULES, FOR_THREAD);
+   add_rule(V_THREAD_INDEX_STYLE_RULES, FOR_THREAD);
+   add_rule(V_COMPOSE_RULES, FOR_COMPOSE);
+   add_rule(V_FORWARD_RULES, FOR_COMPOSE);
+   add_rule(V_INDEX_RULES, FOR_INDEX);
+   add_rule(V_KEY_RULES, FOR_KEY);
+   add_rule(V_REPLACE_RULES, FOR_REPLACE);
+   add_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE);
+   add_rule(V_REPLY_LEADIN_RULES, FOR_REPLY_INTRO);
+   add_rule(V_RESUB_RULES, FOR_RESUB|FOR_TRIM);
+   add_rule(V_SAVE_RULES, FOR_SAVE);
+   add_rule(V_SMTP_RULES, FOR_COMPOSE);
+   add_rule(V_SORT_RULES, FOR_SORT);
+   add_rule(V_STARTUP_RULES, FOR_STARTUP);
+ }
+ 
+ int
+ condition_contains_token(CONDITION_S *condition, char *token)
+ {
+   while(condition && condition->cndtype != Condition)
+       condition =  condition->next;
+ 
+   return condition 
+ 	  ? (!strcmp(COND(condition)->tname, token) 
+ 		? 1
+ 		: condition_contains_token(condition->next, token)) 
+ 	  : 0;
+ }
+ 
+ RULELIST *
+ get_rulelist_from_code(int code, PRULELIST_S *list)
+ {
+   return list ? (list->varnum == code ? list->rlist 
+ 			      : get_rulelist_from_code(code, list->next))
+ 	      : (RULELIST *) NULL;
+ }   
+ 
+ char *
+ test_rule(RULELIST *rlist, int ctxt, ENVELOPE *env, int *n)
+ {
+   char *result;
+ 
+   if(!rlist)
+      return NULL;
+ 
+   if (result = process_rule(rlist->prule, ctxt, env))
+       return result;
+   else{
+        (*n)++;
+        return test_rule(rlist->next, ctxt, env, n);
+   } 
+ }
+ 
+ RULE_S *
+ get_rule (RULELIST *rule, int n)
+ {
+   return rule ? (n ? get_rule(rule->next, n-1) : rule->prule) 
+ 	      : NULL;
+ }
+ 
+ /* get_result_rule:
+  * Parameters: list: the list of rules to be passed to the function to check
+  *             rule_context: context of the rule
+  *             env : envelope used to check the rule, if needed.
+  *
+  * Returns: The value of the first rule that is satisfied in the list, or
+  *          NULL if not. This function should be called in the following 
+  *          way (notice that memory is freed by caller).
+  *
+  * You should use this function to obtain the result of a rule. You can
+  * also call directly "process_rule", but I advice to use this function if
+  * there's no difference on which function to call.
+ 
+    RULE_RESULT *rule;
+ 
+    rule = (RULE_RESULT *) 
+            get_result_rule(V_SOME_RULE, context, envelope);
+ 
+    if (rule){ 
+        assign the value of rule->result;
+        if (rule->result)
+           fs_give((void **)&rule->result);
+        fs_give((void **)&rule);
+    }
+  */
+ 
+ RULE_RESULT *
+ get_result_rule(int code, int rule_context, ENVELOPE *env)
+ {
+     char  *rule_result;
+     RULE_RESULT *rule = NULL;
+     RULELIST *rlist;
+     int n = 0;
+ 
+     if(!(rule_context & FOR_RULE))
+       rule_context |= FOR_RULE;
+     rlist = get_rulelist_from_code(code, ps_global->rule_list);
+     if (rlist){
+        rule_result = test_rule(rlist, rule_context, env, &n);
+        if (rule_result && *rule_result){
+           rule = (RULE_RESULT *) fs_get (sizeof(RULE_RESULT));
+           rule->result = rule_result;
+           rule->number = n;
+        }
+     }
+     return rule;
+ }
+ 
+ char *get_rule_result(int rule_context, char *newfolder, int code)
+ {   
+     char        *rule_result = NULL;
+     ENVELOPE    *news_envelope;
+     RULE_RESULT *rule;
+ 
+     if (IS_NEWS(ps_global->mail_stream)){
+        news_envelope = mail_newenvelope();
+        news_envelope->newsgroups = cpystr(newfolder);
+     }
+     else
+        news_envelope = NULL;
+ 
+     rule = get_result_rule(code, rule_context, news_envelope);
+ 
+     if (news_envelope)
+         mail_free_envelope (&news_envelope);
+ 
+     if (rule){
+         rule_result = cpystr(rule->result);
+         if (rule->result)
+           fs_give((void **)&rule->result);
+         fs_give((void **)&rule);
+     }
+     return rule_result;
+ }
+ 
+ /* process_rule:
+    Parameters:  prule, a processed rule, ready to be tested
+ 		rule_context: context of the rule, and
+ 		env: An envelope if needed.
+ 
+    Returns   :  The value of the processed rule_data if the processing was 
+ 		successful and matches context and possibly the envelope, or
+ 		NULL if there's no match
+  */
+ 
+ char *
+ process_rule (RULE_S *prule, int rule_context, ENVELOPE *env)
+ {
+    if(!prule)
+      return NULL;
+ 
+    if(!(rule_context & FOR_RULE))
+       rule_context |= FOR_RULE;
+ 
+    return test_condition(prule->condition, rule_context, env)
+ 	    ? (prule->action->exec)(prule->action, rule_context, env)
+ 	    : NULL;
+ }
+ 
+ TOKEN_VALUE *
+ copy_parsed_value(TOKEN_VALUE *value, int ctxt, ENVELOPE *env)
+ {
+    TOKEN_VALUE *tval = NULL;
+ 
+    if(!value)
+       return NULL;
+ 
+    if(value->testxt){
+      tval = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
+      tval->testxt = detoken_src(value->testxt, ctxt, env, NULL, NULL, NULL);
+      tval->voidtxt = value->voidtxt;
+      tval->codefcn = value->codefcn;     
+    }
+    if(value->next)
+      tval->next = copy_parsed_value(value->next, ctxt, env);
+ 
+    return tval;
+ }
+ 
+ void
+ free_parsed_value(TOKEN_VALUE **value)
+ {
+    TOKEN_VALUE *tval = NULL;
+ 
+    if(!*value)
+       return;
+ 
+    if((*value)->testxt)
+      fs_give((void **)&(*value)->testxt);
+ 
+    if((*value)->next)
+      free_parsed_value(&(*value)->next);
+ 
+     fs_give((void **)value);
+ }
+ 
+ int
+ test_condition_work(CONDITION_S *bc, CONDITION_S *ec, int rcntxt, ENVELOPE *env)
+ {
+    int rv,level;
+    TOKEN_VALUE *group;
+    CONDITION_S *cend;
+ 
+    switch(bc->cndtype){
+ 	case Condition:	group = copy_parsed_value(COND(bc)->value, rcntxt, env);
+ 			rv = (*rel_rules_test[COND(bc)->ttype].execute)(bc, group, env, rcntxt);
+ 			free_parsed_value(&group);
+ 			if(bc == ec)
+ 			  return rv;
+ 			if(bc->next == NULL)
+ 			  return rv;
+ 			else
+ 			  switch(bc->next->cndtype){
+ 			    case And: return rv ? test_condition_work(bc->next->next, ec, rcntxt, env) : 0;
+ 				  break;
+ 			    case Or : return rv ? 1 : test_condition_work(bc->next->next, ec, rcntxt, env);
+ 				  break;
+ 			    case ')': return rv;
+ 			    default : rv = 0; break;  /* fail, we should not be here */
+ 			  }
+ 			break;
+ 
+ 	case ParOpen:	level = ((int *)bc->cndrule)[0];
+ 			for(cend = bc; cend->next && (cend->next->cndtype != ParClose
+ 				  	|| ((int *)cend->next->cndrule)[0] != level); 
+ 					cend = cend->next);
+ 			rv = test_condition_work(bc->next, cend, rcntxt, env);
+ 			cend = cend->next;	/* here we are at ')' */
+ 			if(cend->next == NULL)
+ 			  return rv;
+ 			else{
+ 			  switch(cend->next->cndtype){
+ 			    case And: return rv ? test_condition_work(cend->next->next, ec, rcntxt, env) : 0;
+ 				  break;
+ 			    case Or : return rv ? 1 : test_condition_work(cend->next->next, ec, rcntxt, env);
+ 				  break;
+ 			    default : rv = 0; break;	/* fail, we should not be here */
+ 			  }
+ 			}
+ 			break;
+ 	     default:	rv = 0; break; 	/* fail, we should not be here */
+    }
+    return rv;  /* we never ever get here */
+ }
+ 
+ 
+ int
+ test_condition(CONDITION_S *condition, int rcntxt, ENVELOPE *env)
+ {
+    return test_condition_work(condition, NULL, rcntxt, env);
+ }
+ 
+ /* returns the name of the token it found or NULL if there is no token, the
+  * real value of the token is obtained by calling the detoken_src function.
+  */ 
+ 
+ char *
+ get_name_token (char *condition)
+ {
+   char *p = NULL, *q, *s;
+ 
+     if ((q = strchr(condition,'_')) && (s = strchr(q+1,'_'))){
+ 	char c = *++s;
+ 	*s = '\0';
+ 	 p = cpystr(q);
+ 	*s = c;
+     }
+     return p;
+ }
+ 
+ /* This function tests if a string contained in the variable "group" is
+  * in the "condition"
+  */
+ int test_in (CONDITION_S *condition, TOKEN_VALUE *group, ENVELOPE *env, 
+ 		int context)
+ {
+  int rv = 0;
+  char *test;
+  TOKEN_VALUE *test_group = group;
+ 
+  test = env && env->sparep && ((SPAREP_S *)env->sparep)->flag & USE_RAW_SP
+ 	? cpystr(((SPAREP_S *)env->sparep)->value)
+ 	: detoken_src(COND(condition)->tname, context, env, NULL, NULL, NULL);
+  if (test){
+     while (rv == 0 && test_group){
+        if(!*test || strstr(test_group->testxt, test))
+ 	  rv++;
+        else
+ 	  test_group = test_group->next;
+     }
+     fs_give((void **)&test);
+  }
+  return rv;
+ }
+ 
+ int test_ni (CONDITION_S *condition, TOKEN_VALUE *group, 
+ 		ENVELOPE *env, int context)
+ {
+  int rv = 0;
+  char *test;
+  TOKEN_VALUE *test_group = group;
+ 
+  test = env && env->sparep && ((SPAREP_S *)env->sparep)->flag & USE_RAW_SP
+ 	? cpystr(((SPAREP_S *)env->sparep)->value)
+ 	: detoken_src(COND(condition)->tname, context, env, NULL, NULL, NULL);
+  if (test){
+     if(!test_group)
+       rv++;
+     while (rv == 0 && test_group){
+        if(!*test_group->testxt || strstr(test, test_group->testxt))
+ 	  rv++;
+        else
+ 	  test_group = test_group->next;
+     }
+     fs_give((void **)&test);
+  }
+  return rv;
+ }
+ 
+ int test_not_in (CONDITION_S *condition, TOKEN_VALUE *group, 
+ 		ENVELOPE *env, int context)
+ {
+  return !test_in(condition, group, env, context);
+ }
+ 
+ int test_not_ni (CONDITION_S *condition, TOKEN_VALUE *group, 
+ 		ENVELOPE *env, int context)
+ {
+  return !test_ni(condition, group, env, context);
+ }
+ 
+ int test_eq (CONDITION_S *condition, TOKEN_VALUE *group, 
+ 		ENVELOPE *env, int context)
+ {
+  int rv = 0;
+  char *test;
+  TOKEN_VALUE *test_group = group;
+ 
+  test = env && env->sparep && ((SPAREP_S *)env->sparep)->flag & USE_RAW_SP
+ 	? cpystr(((SPAREP_S *)env->sparep)->value)
+ 	: detoken_src(COND(condition)->tname, context, env, NULL, NULL, NULL);
+  if (test){
+     while (rv == 0 && test_group){
+        if((!*test && !*test_group->testxt) || !strcmp(test_group->testxt, test))
+ 	  rv++;
+        else
+ 	  test_group = test_group->next;
+     }
+     fs_give((void **)&test);
+  }
+  return rv;
+ }
+ 
+ int test_not_eq (CONDITION_S *condition, TOKEN_VALUE *group, 
+ 		ENVELOPE *env, int context)
+ {
+  return !test_eq(condition, group, env, context);
+ }
+ 
+ char *
+ do_trim (char *test, TOKEN_VALUE *tval)
+ {
+    char *begin_text;
+    int offset = 0;
+ 
+    if (!tval)
+       return test;
+ 
+    while(begin_text = strstr(test+offset,tval->testxt)){
+       strcpy(begin_text, begin_text+strlen(tval->testxt));
+       offset = begin_text - test;
+    }
+ 
+    return do_trim(test, tval->next);
+ }
+ 
+ char *
+ trim (RULEACTION_S *action, int context, ENVELOPE *env)
+ {
+  char *begin_text, *test;
+  RULEACTION_S *taction = action;
+  int offset;
+ 
+  if (taction->context & context){
+     if (test = detoken_src(taction->token, context, env, NULL, NULL, NULL))
+        test = do_trim(test, taction->value);
+     return test;
+  }
+  return NULL;
+ }
+ 
+ 
+ char *
+ do_rextrim (char *test, TOKEN_VALUE *tval)
+ {
+    char *begin_text, *trim_text;
+    int offset = 0;
+ 
+    if (!tval)
+       return test;
+ 
+    trim_text = expand(test, tval->voidtxt);
+    while(trim_text && (begin_text = strstr(test+offset,trim_text))){
+       strcpy(begin_text, begin_text+strlen(trim_text));
+       offset = begin_text - test;
+    }
+ 
+    return do_rextrim(test, tval->next);
+ }
+ 
+ char *
+ rextrim (RULEACTION_S *action, int context, ENVELOPE *env)
+ {
+  char *test = NULL;
+  RULEACTION_S *taction = action;
+ 
+  if (taction->context & context &&
+     (test = detoken_src(taction->token, context, env, NULL, NULL, NULL)))
+ 	test = do_rextrim(test, taction->value);
+  return test;
+ }
+ 
+ char *
+ raw_value (RULEACTION_S *action, int context, ENVELOPE *env)
+ {
+ return (action->context & context) ? cpystr(action->value->testxt) : NULL;
+ }
+ 
+ char *
+ extended_value (RULEACTION_S *action, int ctxt, ENVELOPE *env)
+ {
+ return (action->context & ctxt) 
+ 	? detoken_src(action->value->testxt, ctxt, env, NULL, NULL, NULL)
+ 	: NULL;
+ }
+ 
+ /* advances given_string until it finds given_char, memory freed by caller  */
+ char *
+ advance_to_char(char *given_string, char given_char, int flag, int *error) 
+ {
+    char *b, *s, c;
+    int i, err  = 0, quoted ;
+ 
+    if (error)
+       *error = 0;
+ 
+    if (!given_string || !*given_string)
+        return NULL;
+ 
+    b = s = cpystr(given_string);
+    for(i = 0, quoted = 0, c = *s; c ; c = *++s){
+       if(c == '\\'){
+ 	 quoted++;
+ 	 continue;
+       }
+       if(quoted){
+ 	quoted = 0;
+ 	if (c == given_char){
+ 	  err += flag & STRICTLY ? 0 : 1;
+ 	  err++;
+ 	  break;
+ 	}
+ 	b[i++] = '\\';
+       }
+       if(c == given_char){
+ 	 err += flag & STRICTLY ? 0 : 1;
+ 	 break;
+       }
+       b[i++] = c;
+    }
+    b[i] = '\0';
+    if (b && (strlen(b) == strlen(given_string)) && (flag & STRICTLY)){
+       fs_give((void **)&b);
+       return NULL;   /* character not found */
+    }
+ 
+    if(b && !*b){
+      fs_give((void **)&b);
+      err = -1;
+    }
+ 
+    if (error)
+       *error = err;
+ 
+    return b;
+ }
+ 
+ /* Regular Expressions Support */
+ char *
+ expand (char *string, void *pattern)
+ {
+  char c, *ret_string = NULL;
+  regmatch_t pmatch;
+  
+   if((regex_t *)pattern == NULL)
+      return NULL;
+ 
+   if(regexec((regex_t *)pattern, string , 1, &pmatch, 0) == 0 
+ 	&& pmatch.rm_so < pmatch.rm_eo){
+       c = string[pmatch.rm_eo];
+       string[pmatch.rm_eo] = '\0';
+       ret_string = cpystr(string+pmatch.rm_so);
+       string[pmatch.rm_eo] = c;
+   }
+   return ret_string;
+ }
+ 
+ 
+ char *
+ exec_fcn (RULEACTION_S *action, int ctxt, ENVELOPE *env)
+ {
+   STORE_S *output_so;
+   gf_io_t	gc, pc;
+   char *status, *rv, *cmd, *test;
+ 
+   if(!(action->context & ctxt))
+     return NULL;
+ 
+   if((test = detoken_src(action->token, ctxt, env, NULL, NULL, NULL)) != NULL)
+     gf_set_readc(&gc, test, (unsigned long)strlen(test), CharStar, 0);
+ 
+   if((output_so = so_get(CharStar, NULL, EDIT_ACCESS)) != NULL)
+      gf_set_so_writec(&pc, output_so);
+ 
+   cmd = (char *)fs_get((strlen(action->value->testxt) + strlen("_TMPFILE_") + 2)*sizeof(char));
+   sprintf(cmd,"%s _TMPFILE_", action->value->testxt);
+   status = (*ps_global->tools.exec_rule)(cmd, gc, pc);
+ 
+   so_seek(output_so, 0L, 0);
+   rv = cpystr(output_so->dp);
+   gf_clear_so_writec(output_so);
+   so_give(&output_so);
+   if(test)
+     fs_give((void **)&test);
+ 
+   return status ? NULL : rv;
+ }
+ 
+ ENVELOPE *
+ rules_fetchenvelope(INDEXDATA_S *idata, int *we_clear)
+ {
+   ENVELOPE *env;
+ 
+   if (idata->no_fetch){
+      if(we_clear)
+         *we_clear = 1;
+     env = mail_newenvelope();
+     env->from     = copyaddrlist(idata->from);
+     env->to       = copyaddrlist(idata->to);
+     env->cc       = copyaddrlist(idata->cc);
+     env->sender   = copyaddrlist(idata->sender);
+     env->subject  = cpystr(idata->subject);
+     env->date     = cpystr((unsigned char *) idata->date);
+     env->newsgroups = cpystr(idata->newsgroups);
+     return env;
+   }
+   if(we_clear)
+      *we_clear = 0;
+   env = pine_mail_fetchenvelope(idata->stream, idata->rawno);
+   return env;
+ }
diff -rc alpine-2.11/pith/rules.h alpine-2.11.I.USE/pith/rules.h
*** alpine-2.11/pith/rules.h	2013-12-01 16:41:34.000000000 -0700
--- alpine-2.11.I.USE/pith/rules.h	2013-12-01 16:34:57.000000000 -0700
***************
*** 0 ****
--- 1,149 ----
+ /* Included file rules.h */
+ 
+ #ifndef PITH_RULES_INCLUDED
+ #define PITH_RULES_INCLUDED
+ 
+ #include "../pith/conftype.h"
+ #include "../pith/detoken.h"
+ #include "../pith/indxtype.h"
+ #include "../pith/rulestype.h"
+ 
+ /* Exported prototypes */
+ 
+ void  create_rule_list (struct variable *);
+ SPAREP_S *get_sparep_for_rule(char *, int);
+ void  free_sparep_for_rule(void **);
+ void  free_parsed_rule_list (PRULELIST_S **);
+ RULE_RESULT *get_result_rule (int, int, ENVELOPE *);
+ char  *get_rule_result (int , char *, int);
+ char  *process_rule   (RULE_S *, int, ENVELOPE *);
+ char  **functions_for_token (char *);
+ RULELIST *get_rulelist_from_code (int, PRULELIST_S *);
+ RULE_S   *get_rule  (RULELIST *, int);
+ int   condition_contains_token (CONDITION_S *, char *);
+ int   context_for_function (char *);
+ ENVELOPE *rules_fetchenvelope(INDEXDATA_S *idata, int *we_clear);
+ 
+ /* Separators:
+  *
+  * A separator is a string that separates the rule condition with the rule
+  * action. Below is the list of separators
+  *
+  */
+ 
+ #define  SAVE_TO_SEP  "->"
+ #define  APPLY_SEP    "=>"
+ 
+ /*------- Definitions of tokens -------*/
+ /*------ Keep the list alphabetically sorted, thanks -------*/
+ 
+ #define ADDR_TOKEN	"_ADDRESS_"
+ #define ADDCC_TOKEN	"_ADDRESSCC_"
+ #define ADDRECIP_TOKEN	"_ADDRESSRECIPS_"
+ #define ADDTO_TOKEN	"_ADDRESSTO_"
+ #define BCC_TOKEN	"_BCC_"
+ #define CC_TOKEN	"_CC_"
+ #define COLLECT_TOKEN	"_COLLECTION_"
+ #define FLAG_TOKEN	"_FLAG_"
+ #define FOLDER_TOKEN	"_FOLDER_"
+ #define FADDRESS_TOKEN	"_FORWARDADDRESS_"
+ #define FFROM_TOKEN	"_FORWARDFROM_"
+ #define FROM_TOKEN	"_FROM_"
+ #define KEY_TOKEN	"_PKEY_"
+ #define LCC_TOKEN	"_LCC_"
+ #define NICK_TOKEN	"_NICK_"
+ #define OTEXT_TOKEN	"_OPENINGTEXT_"
+ #define OTEXTNQ_TOKEN	"_OPENINGTEXTNQ_"
+ #define PROCID_TOKEN	"_PROCID_"
+ #define ROLE_TOKEN	"_ROLE_"
+ #define SCREEN_TOKEN	"_SCREEN_"
+ #define SEND_TOKEN	"_SENDER_"
+ #define SUBJ_TOKEN	"_SUBJECT_"
+ #define THDDSPSTY_TOKEN	"_THREADSTYLE_"
+ #define THDNDXSTY_TOKEN	"_THREADINDEX_"
+ #define TO_TOKEN	"_TO_"
+ 
+ /*------ Definitions of relational operands -------------*/
+ 
+ typedef struct {
+         char       *value;
+ 	TestType    ttype;
+         int        (*execute)();
+ } REL_TOKEN;
+ 
+ /* Relational Operands */
+ #define AND_REL     "&&"        /* For putting more than one condition  */
+ #define IN_REL      "<<"        /* For belonging relation */
+ #define NI_REL      ">>"        /* For contain relation   */
+ #define NOT_IN_REL  "!<"        /* Negation of IN_REL   */
+ #define NOT_NI_REL  "!>"        /* Negation of NI_REL   */
+ #define EQ_REL      "=="        /* Test of equality     */
+ #define NOT_EQ_REL  "!="        /* Test of inequality   */
+ #define OPEN_SET    "{"         /* Braces to open a set */
+ #define CLOSE_SET   "}"         /* Braces to close a set*/
+ 
+ /*--- Context in which these variables can be used ---*/
+ 
+ typedef struct use_context {
+     char        *name;
+     int          what_for;
+ } USE_IN_CONTEXT;
+ 
+ 
+ static USE_IN_CONTEXT tokens_use[] = {
+     {NICK_TOKEN,	FOR_SAVE},
+     {FROM_TOKEN,	FOR_SAVE},
+     {OTEXT_TOKEN,	FOR_SAVE|FOR_FOLDER},
+     {OTEXTNQ_TOKEN,	FOR_SAVE|FOR_FOLDER},
+     {ROLE_TOKEN,	FOR_COMPOSE},
+     {FOLDER_TOKEN,	FOR_SAVE|FOR_FOLDER|FOR_THREAD|FOR_COMPOSE},
+     {SUBJ_TOKEN,	FOR_SAVE|FOR_FOLDER|FOR_COMPOSE},
+     {FLAG_TOKEN,	FOR_SAVE|FOR_FLAG},
+     {COLLECT_TOKEN,	FOR_SAVE|FOR_COMPOSE|FOR_FOLDER|FOR_THREAD},
+     {THDDSPSTY_TOKEN,	FOR_THREAD},
+     {THDNDXSTY_TOKEN,	FOR_THREAD},
+     {ADDR_TOKEN,	FOR_SAVE|FOR_FOLDER},
+     {TO_TOKEN,		FOR_SAVE},
+     {ADDTO_TOKEN,	FOR_SAVE|FOR_COMPOSE},
+     {ADDCC_TOKEN,	FOR_SAVE|FOR_COMPOSE},
+     {ADDRECIP_TOKEN,	FOR_SAVE|FOR_COMPOSE},
+     {SCREEN_TOKEN,	FOR_KEY},
+     {KEY_TOKEN,		FOR_KEY},
+     {SEND_TOKEN,	FOR_SAVE},
+     {CC_TOKEN,		FOR_SAVE},
+     {BCC_TOKEN,		FOR_COMPOSE},
+     {LCC_TOKEN,		FOR_COMPOSE},
+     {FFROM_TOKEN,	FOR_COMPOSE},
+     {FADDRESS_TOKEN,	FOR_COMPOSE},
+     {NULL,		FOR_NOTHING}
+ };
+ 
+ 
+ typedef struct {
+         char         *name;
+         char*        (*execute)();
+         int          what_for;
+ } RULE_FCN;
+ 
+ #define COMMAND_FCN	"_COMMAND_"
+ #define COPY_FCN	"_COPY_"
+ #define EXEC_FCN	"_EXEC_"
+ #define INDEX_FCN       "_INDEX_"
+ #define REPLACE_FCN     "_REPLACE_"
+ #define REPLYSTR_FCN    "_RESTR_"
+ #define REPLY_FCN       "_REPLY_"
+ #define RESUB_FCN       "_RESUB_"
+ #define REXTRIM_FCN	"_REXTRIM_"
+ #define SAVE_FCN        "_SAVE_"
+ #define SIGNATURE_FCN   "_SIGNATURE_"
+ #define SMTP_FCN        "_SMTP_"
+ #define SORT_FCN        "_SORT_"
+ #define STARTUP_FCN     "_STARTUP_"
+ #define THRDSTYLE_FCN   "_THREADSTYLE_"
+ #define THRDINDEX_FCN   "_THREADINDEX_"
+ #define TRIM_FCN        "_TRIM_"
+ 
+ #define STRICTLY  0x1
+ #define RELAXED 0x2
+ 
+ #endif 	/* PITH_RULES_INCLUDED */
diff -rc alpine-2.11/pith/rulestype.h alpine-2.11.I.USE/pith/rulestype.h
*** alpine-2.11/pith/rulestype.h	2013-12-01 16:41:34.000000000 -0700
--- alpine-2.11.I.USE/pith/rulestype.h	2013-12-01 16:34:57.000000000 -0700
***************
*** 0 ****
--- 1,85 ----
+ #ifndef PITH_RULESTYPE_INCLUDED
+ #define PITH_RULESTYPE_INCLUDED
+ 
+ typedef struct rule {
+ 	char *result;	/* The result of the rule */
+ 	int number;	/* The number of the rule that succeded, -1 if not */
+ } RULE_RESULT;
+ 
+ typedef struct {
+         char    *value;
+         int     type;
+ } RULE_ACTION;
+ 
+ 
+ #define TOKEN_VALUE	struct tokenvalue_s
+ #define CONDITION_S	struct condition_s
+ #define RULEACTION_S	struct ruleaction_s
+ #define RULE_S		struct rule_s
+ #define RULELIST	struct rulelist_s
+ #define PRULELIST_S	struct parsedrulelist_s
+ 
+ #define FREEREGEX	1
+ 
+ TOKEN_VALUE {
+ 	char	*testxt;
+ 	void	*voidtxt;
+ 	int	codefcn;
+ 	TOKEN_VALUE *next;
+ };
+ 
+ typedef enum {Equal, Subset, Includes, NotEqual, NotSubset, NotIncludes, EndTypes} TestType;
+ 
+ typedef enum {And, Or, ParOpen, ParClose, Condition} CondType;
+ 
+ typedef struct condvalue_s {
+     char	*tname;		/* tname ttype {value} */
+     TestType	ttype;		/* type of rule */
+     TOKEN_VALUE	*value;		/* value to check against */
+ } CONDVALUE_S;
+ 
+ CONDITION_S {
+     void     *cndrule;		/* text in condition */
+     CondType  cndtype;		/* type of object    */
+     CONDITION_S	*next;		/* next condition to test */
+ };
+ 
+ #define COND(C)  ((CONDVALUE_S *)((C)->cndrule))
+ 
+ RULEACTION_S {
+    char *token;		/* token := function{value} or token = null  */
+    char *function;	/* token := function{value} or simply function{value}*/
+    TOKEN_VALUE  *value; /* token := function{value} or simply function{value}*/
+    int   context;	/* context in which this rule can be used */
+    char* (*exec)();
+    unsigned int is_trim:1;
+    unsigned int is_rextrim:1;
+    unsigned int is_replace:1;
+ };
+ 
+ RULE_S {
+   CONDITION_S  *condition;
+   RULEACTION_S *action;
+ };
+ 
+ RULELIST {
+    RULE_S *prule;
+    RULELIST *next;
+ };
+ 
+ PRULELIST_S {
+    int varnum;		/* number associated to the variable */
+    RULELIST *rlist;
+    PRULELIST_S *next;
+ };
+ 
+ #define USE_RAW_SP      0x001
+ #define PROCESS_SP      0x010
+ 
+ typedef struct sparep {
+    int flag;
+    char *value;
+ } SPAREP_S;
+ 
+ 
+ #endif	/* PITH_RULESTYPE_INCLUDED */
diff -rc alpine-2.11/pith/save.c alpine-2.11.I.USE/pith/save.c
*** alpine-2.11/pith/save.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/save.c	2013-12-01 16:39:07.000000000 -0700
***************
*** 954,960 ****
  	      *date = '\0';
  
  	    rv = save_fetch_append(stream, mn_m2raw(msgmap, i),
! 				   NULL, save_stream, save_folder, context,
  				   mc ? mc->rfc822_size : 0L, flags, date, so);
  
  	    if(flags)
--- 954,960 ----
  	      *date = '\0';
  
  	    rv = save_fetch_append(stream, mn_m2raw(msgmap, i),
! 				   NULL, save_stream, folder, context,
  				   mc ? mc->rfc822_size : 0L, flags, date, so);
  
  	    if(flags)
***************
*** 1157,1162 ****
--- 1157,1163 ----
  		    snprintf(buf, sizeof(buf),
  	 "Message to save shrank: source msg # %ld may be saved incorrectly",
  			     mn_raw2m(pkg->msgmap, raw));
+ 		    if(F_OFF(F_IGNORE_SIZE, ps_global))
  		    q_status_message(SM_ORDER, 0, 3, buf);
  		}
  		else{
diff -rc alpine-2.11/pith/send.c alpine-2.11.I.USE/pith/send.c
*** alpine-2.11/pith/send.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/send.c	2013-12-01 16:37:46.000000000 -0700
***************
*** 44,49 ****
--- 44,50 ----
  #include "../pith/ablookup.h"
  #include "../pith/sort.h"
  #include "../pith/smime.h"
+ #include "../pith/rules.h"
  
  #include "../c-client/smtp.h"
  #include "../c-client/nntp.h"
***************
*** 53,59 ****
  /* name::type::canedit::writehdr::localcopy::rcptto */
  PINEFIELD pf_template[] = {
    {"X-Auth-Received",    FreeText,	0, 1, 1, 0},	/* N_AUTHRCVD */
!   {"From",        Address,	0, 1, 1, 0},
    {"Reply-To",    Address,	0, 1, 1, 0},
    {TONAME,        Address,	1, 1, 1, 1},
    {CCNAME,        Address,	1, 1, 1, 1},
--- 54,60 ----
  /* name::type::canedit::writehdr::localcopy::rcptto */
  PINEFIELD pf_template[] = {
    {"X-Auth-Received",    FreeText,	0, 1, 1, 0},	/* N_AUTHRCVD */
!   {"From",        Address,	1, 1, 1, 0},
    {"Reply-To",    Address,	0, 1, 1, 0},
    {TONAME,        Address,	1, 1, 1, 1},
    {CCNAME,        Address,	1, 1, 1, 1},
***************
*** 257,262 ****
--- 258,270 ----
  
      if(exists & FEX_ISFILE){
  	context_apply(tmp, p_cntxt, mbox, sizeof(tmp));
+ #ifndef _WINDOWS
+         if (!struncmp(tmp, "#md/",4) || !struncmp(tmp, "#mc/", 4)){
+ 	    char tmp2[MAILTMPLEN];
+ 	    maildir_file_path(tmp, tmp2, sizeof(tmp2));
+ 	    strcpy(tmp, tmp2);
+ 	}
+ #endif
  	if(!(IS_REMOTE(tmp) || is_absolute_path(tmp))){
  	    /*
  	     * The mbox is relative to the home directory.
***************
*** 1229,1235 ****
  	    *p = *(p+4);
  
          pf->type        = pf_template[i].type;
! 	pf->canedit     = pf_template[i].canedit;
  	pf->rcptto      = pf_template[i].rcptto;
  	pf->writehdr    = pf_template[i].writehdr;
  	pf->localcopy   = pf_template[i].localcopy;
--- 1237,1243 ----
  	    *p = *(p+4);
  
          pf->type        = pf_template[i].type;
! 	pf->canedit     = (i == N_FROM) ? CAN_EDIT(ps_global) : pf_template[i].canedit;
  	pf->rcptto      = pf_template[i].rcptto;
  	pf->writehdr    = pf_template[i].writehdr;
  	pf->localcopy   = pf_template[i].localcopy;
***************
*** 1738,1746 ****
      char         error_buf[200], *error_mess = NULL, *postcmd;
      ADDRESS     *a;
      ENVELOPE	*fake_env = NULL;
!     int          addr_error_count, we_cancel = 0;
      long	 smtp_opts = 0L;
!     char	*verbose_file = NULL;
      BODY	*bp = NULL;
      PINEFIELD	*pf;
      BODY	*origBody = body;
--- 1746,1754 ----
      char         error_buf[200], *error_mess = NULL, *postcmd;
      ADDRESS     *a;
      ENVELOPE	*fake_env = NULL;
!     int          addr_error_count, we_cancel = 0, choice, num_rules = 0, added_rules = -1;
      long	 smtp_opts = 0L;
!     char	*verbose_file = NULL, **smtp_list;
      BODY	*bp = NULL;
      PINEFIELD	*pf;
      BODY	*origBody = body;
***************
*** 1893,1912 ****
       * OK, who posts what?  We tried an mta_handoff above, but there
       * was either none specified or we decided not to use it.  So,
       * if there's an smtp-server defined anywhere, 
       */
!     if(alt_smtp_servers && alt_smtp_servers[0] && alt_smtp_servers[0][0]){
! 	/*---------- SMTP ----------*/
! 	dprint((4, "call_mailer: via TCP (%s)\n",
! 		alt_smtp_servers[0]));
! 	TIME_STAMP("smtp-open start (tcp)", 1);
! 	sending_stream = smtp_open(alt_smtp_servers, smtp_opts);
!     }
!     else if(ps_global->VAR_SMTP_SERVER && ps_global->VAR_SMTP_SERVER[0]
! 	    && ps_global->VAR_SMTP_SERVER[0][0]){
! 	/*---------- SMTP ----------*/
! 	dprint((4, "call_mailer: via TCP\n"));
! 	TIME_STAMP("smtp-open start (tcp)", 1);
! 	sending_stream = smtp_open(ps_global->VAR_SMTP_SERVER, smtp_opts);
      }
      else if((postcmd = smtp_command(ps_global->c_client_error, sizeof(ps_global->c_client_error))) != NULL){
  	char *cmdlist[2];
--- 1901,1949 ----
       * OK, who posts what?  We tried an mta_handoff above, but there
       * was either none specified or we decided not to use it.  So,
       * if there's an smtp-server defined anywhere, 
+      * First we check for rules and make a list using the rules.
       */
!     if(ps_global->VAR_SMTP_RULES && ps_global->VAR_SMTP_RULES[0]
!         && ps_global->VAR_SMTP_RULES[0][0])
!         while (ps_global->VAR_SMTP_RULES[num_rules]) num_rules++;
! 
!     if(num_rules){
! 	int i, j;
! 
!         added_rules = 0;
!         smtp_list = (char **) fs_get ((num_rules + 1)*sizeof(char*));
!         for (i = 0, j = 0; i < num_rules; i++){
! 	   RULELIST *rule = get_rulelist_from_code(V_SMTP_RULES,
!                                                       ps_global->rule_list);
! 	   RULE_S *prule = get_rule(rule, i);
!            if(prule){
! 	     char *rule_result = process_rule(prule, FOR_COMPOSE, header->env);
! 	     if(rule_result && *rule_result){
! 		smtp_list[j++] = cpystr(rule_result);
! 		added_rules++;
! 	     }
! 	   }
! 	}
!     }
! 
!     if (added_rules < 0){
! 	smtp_list = (char **) fs_get (sizeof(char*));
! 	added_rules = 0;
!     }
!     smtp_list[added_rules] = NULL;
! 
!     choice = smtp_list && smtp_list[0] && smtp_list[0][0] ? 3 :
! 	(alt_smtp_servers && alt_smtp_servers[0] && alt_smtp_servers[0][0] ? 2 :
! 	(ps_global->VAR_SMTP_SERVER && ps_global->VAR_SMTP_SERVER[0] 
! 		&& ps_global->VAR_SMTP_SERVER[0][0] ? 1 : -1));
! 
!     if(choice > 0){
!         /*---------- SMTP ----------*/
!        dprint((4, "call_mailer: via TCP (%s)\n",smtp_list[0]));
!         TIME_STAMP("smtp-open start (tcp)", 1);
!         sending_stream = smtp_open(choice == 3 ? smtp_list
! 				: (choice == 2 ? alt_smtp_servers
! 				: ps_global->VAR_SMTP_SERVER), smtp_opts);
      }
      else if((postcmd = smtp_command(ps_global->c_client_error, sizeof(ps_global->c_client_error))) != NULL){
  	char *cmdlist[2];
***************
*** 2142,2147 ****
--- 2179,2186 ----
  	if(error_mess){
  	    q_status_message(SM_ORDER | SM_DING, 4, 7, error_mess);
  	    dprint((1, "call_mailer ERROR: %s\n", error_mess));
+ 	    if (ps_global->send_immediately)
+ 	      printf("%s\n",error_mess);
  	}
  
  	return(-1);
diff -rc alpine-2.11/pith/send.h alpine-2.11.I.USE/pith/send.h
*** alpine-2.11/pith/send.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/send.h	2013-12-01 16:37:46.000000000 -0700
***************
*** 159,164 ****
--- 159,166 ----
      unsigned  text_written:1;
  };
  
+ #define CAN_EDIT(x)	(!((x)->never_allow_changing_from) && \
+ 			F_ON(F_ALLOW_CHANGING_FROM, (x)))
  
  #define TONAME "To"
  #define CCNAME "cc"
diff -rc alpine-2.11/pith/sort.c alpine-2.11.I.USE/pith/sort.c
*** alpine-2.11/pith/sort.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/sort.c	2013-12-01 16:41:34.000000000 -0700
***************
*** 30,36 ****
  #include "../pith/signal.h"
  #include "../pith/busy.h"
  #include "../pith/icache.h"
! 
  
  /*
   * global place to store mail_sort and mail_thread results
--- 30,36 ----
  #include "../pith/signal.h"
  #include "../pith/busy.h"
  #include "../pith/icache.h"
! #include "../pith/rules.h"
  
  /*
   * global place to store mail_sort and mail_thread results
***************
*** 91,97 ****
    ----*/
  void
  sort_folder(MAILSTREAM *stream, MSGNO_S *msgmap, SortOrder new_sort,
! 	    int new_rev, unsigned int flags)
  {
      long	   raw_current, i, j;
      unsigned long *sort = NULL;
--- 91,97 ----
    ----*/
  void
  sort_folder(MAILSTREAM *stream, MSGNO_S *msgmap, SortOrder new_sort,
! 	    int new_rev, unsigned int flags, int first)
  {
      long	   raw_current, i, j;
      unsigned long *sort = NULL;
***************
*** 101,106 ****
--- 101,115 ----
      int	           current_rev;
      MESSAGECACHE  *mc;
  
+     if (first){
+        if (new_sort == SortThread)
+         find_msgmap(stream, msgmap, flags,
+                  ps_global->thread_cur_sort, new_rev);
+        else
+         sort_folder(stream, msgmap, new_sort, new_rev, flags, 0);
+        return;
+     }
+ 
      dprint((2, "Sorting by %s%s\n",
  	       sort_name(new_sort), new_rev ? "/reverse" : ""));
  
***************
*** 530,549 ****
   * argument also means arrival/reverse.
   */
  int
! decode_sort(char *sort_spec, SortOrder *def_sort, int *def_sort_rev)
  {
      char *sep;
      char *fix_this = NULL;
!     int   x, reverse;
  
      if(!sort_spec || !*sort_spec){
! 	*def_sort = SortArrival;
  	*def_sort_rev = 0;
          return(0);
      }
  
      if(struncmp(sort_spec, "reverse", strlen(sort_spec)) == 0){
! 	*def_sort = SortArrival;
  	*def_sort_rev = 1;
          return(0);
      }
--- 539,558 ----
   * argument also means arrival/reverse.
   */
  int
! decode_sort(char *sort_spec, SortOrder *def_sort, int *def_sort_rev, int thread)
  {
      char *sep;
      char *fix_this = NULL;
!     int   x = 0, reverse;
  
      if(!sort_spec || !*sort_spec){
! 	*def_sort = thread ? SortThread : SortArrival;
  	*def_sort_rev = 0;
          return(0);
      }
  
      if(struncmp(sort_spec, "reverse", strlen(sort_spec)) == 0){
! 	*def_sort = thread ? SortThread : SortArrival;
  	*def_sort_rev = 1;
          return(0);
      }
***************
*** 572,578 ****
      if(ps_global->sort_types[x] == EndofList)
        return(-1);
  
!     *def_sort     = ps_global->sort_types[x];
      *def_sort_rev = reverse;
      return(0);
  }
--- 581,587 ----
      if(ps_global->sort_types[x] == EndofList)
        return(-1);
  
!     *def_sort	  = ps_global->sort_types[x];
      *def_sort_rev = reverse;
      return(0);
  }
***************
*** 686,695 ****
      PAT_S        *pat;
      SortOrder	  the_sort_order;
      int           sort_is_rev;
! 
      /* set default order */
      the_sort_order = ps_global->def_sort;
!     sort_is_rev    = ps_global->def_sort_rev;
  
      if(ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
--- 695,720 ----
      PAT_S        *pat;
      SortOrder	  the_sort_order;
      int           sort_is_rev;
!     char       *rule_result;
!     SortOrder   new_sort = EndofList;
!     int               is_rev;
! 
!    rule_result = get_rule_result(FOR_SORT, ps_global->cur_folder, V_SORT_RULES);
!    if (rule_result && *rule_result){
!       new_sort  = (SortOrder) translate(rule_result, 1);
!       is_rev    = (SortOrder) translate(rule_result, 0) == EndofList ? 0 : 1;
!       fs_give((void **)&rule_result);
!    }
!    if (new_sort != EndofList){
!        the_sort_order = new_sort;
!        sort_is_rev    = is_rev;
!    }
!    else{
      /* set default order */
      the_sort_order = ps_global->def_sort;
!     sort_is_rev    = the_sort_order == SortThread
! 			? (ps_global->thread_def_sort_rev + ps_global->def_sort_rev) % 2
! 			: ps_global->def_sort_rev;
  
      if(ps_global->mail_stream && nonempty_patterns(rflags, &pstate)){
  	for(pat = first_pattern(&pstate); pat; pat = next_pattern(&pstate)){
***************
*** 702,710 ****
  	   && pat->action->sort_is_set){
  	    the_sort_order = pat->action->sortorder;
  	    sort_is_rev    = pat->action->revsort;
  	}
      }
  
      sort_folder(ps_global->mail_stream, ps_global->msgmap,
! 		the_sort_order, sort_is_rev, flags);
  }
--- 727,778 ----
  	   && pat->action->sort_is_set){
  	    the_sort_order = pat->action->sortorder;
  	    sort_is_rev    = pat->action->revsort;
+ 	    sort_is_rev    = the_sort_order == SortThread
+ 				? (ps_global->thread_def_sort_rev + pat->action->revsort) % 2
+ 				: pat->action->revsort;
  	}
      }
+    }
+     if(the_sort_order == SortThread && !(flags & SRT_MAN))
+       ps_global->thread_cur_sort = ps_global->thread_def_sort;
  
      sort_folder(ps_global->mail_stream, ps_global->msgmap,
! 		the_sort_order, sort_is_rev, flags, 1);
  }
+ 
+ SortOrder translate(char *order, int is_rev)
+ {
+    int rev = 0;
+      if (!strncmp(order,"tHread", 6)
+                 || (rev = !strncmp(order,"Reverse tHread", 14)))
+         return is_rev || rev ? SortThread : EndofList;
+      if (!strncmp(order,"OrderedSubj", 11)
+                 || (rev = !strncmp(order,"Reverse OrderedSubj", 19)))
+         return is_rev || rev  ? SortSubject2 : EndofList;
+      if (!strncmp(order,"Subject", 7)
+                 || (rev = !strncmp(order,"Reverse SortSubject", 15)))
+         return is_rev || rev  ?  SortSubject : EndofList;
+      if (!strncmp(order,"Arrival", 7)
+                 || (rev = !strncmp(order,"Reverse Arrival", 15)))
+         return is_rev || rev  ?  SortArrival : EndofList;
+      if (!strncmp(order,"From", 4)
+                 || (rev = !strncmp(order,"Reverse From", 12)))
+         return is_rev || rev  ?  SortFrom : EndofList;
+      if (!strncmp(order,"To", 2)
+                 || (rev = !strncmp(order,"Reverse To", 10)))
+         return is_rev || rev  ?  SortTo : EndofList;
+      if (!strncmp(order,"Cc", 2)
+                 || (rev = !strncmp(order,"Reverse Cc", 10)))
+         return is_rev || rev  ?  SortCc : EndofList;
+      if (!strncmp(order,"Date", 4)
+                 || (rev = !strncmp(order,"Reverse Date", 12)))
+         return is_rev || rev  ?  SortDate : EndofList;
+      if (!strncmp(order,"siZe", 4)
+                 || (rev = !strncmp(order,"Reverse siZe", 12)))
+         return is_rev || rev  ?  SortSize : EndofList;
+      if (!strncmp(order,"scorE", 5)
+                 || (rev = !strncmp(order,"Reverse scorE", 13)))
+         return is_rev || rev  ?  SortScore : EndofList;
+    return EndofList;
+ }
+ 
diff -rc alpine-2.11/pith/sort.h alpine-2.11.I.USE/pith/sort.h
*** alpine-2.11/pith/sort.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/sort.h	2013-12-01 16:34:57.000000000 -0700
***************
*** 22,28 ****
  
  
  #define	refresh_sort(S,M,F)	sort_folder((S), (M), mn_get_sort(M), \
! 					    mn_get_revsort(M), (F))
  
  struct global_sort_data {
      MSGNO_S *msgmap;
--- 22,28 ----
  
  
  #define	refresh_sort(S,M,F)	sort_folder((S), (M), mn_get_sort(M), \
! 					    mn_get_revsort(M), (F), 1)
  
  struct global_sort_data {
      MSGNO_S *msgmap;
***************
*** 41,49 ****
  
  /* exported protoypes */
  char	*sort_name(SortOrder);
! void	 sort_folder(MAILSTREAM *, MSGNO_S *, SortOrder, int, unsigned);
! int	 decode_sort(char *, SortOrder *, int *);
  void	 reset_sort_order(unsigned);
! 
  
  #endif /* PITH_SORT_INCLUDED */
--- 41,49 ----
  
  /* exported protoypes */
  char	*sort_name(SortOrder);
! void	 sort_folder(MAILSTREAM *, MSGNO_S *, SortOrder, int, unsigned, int);
! int	 decode_sort(char *, SortOrder *, int *, int);
  void	 reset_sort_order(unsigned);
! SortOrder translate(char *, int);
  
  #endif /* PITH_SORT_INCLUDED */
diff -rc alpine-2.11/pith/state.c alpine-2.11.I.USE/pith/state.c
*** alpine-2.11/pith/state.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/state.c	2013-12-01 16:38:26.000000000 -0700
***************
*** 33,39 ****
  #include "../pith/remote.h"
  #include "../pith/list.h"
  #include "../pith/smime.h"
! 
  
  /*
   * Globals referenced throughout pine...
--- 33,39 ----
  #include "../pith/remote.h"
  #include "../pith/list.h"
  #include "../pith/smime.h"
! #include "../pith/rules.h"
  
  /*
   * Globals referenced throughout pine...
***************
*** 74,79 ****
--- 74,80 ----
  
      p		       = (struct pine *)fs_get(sizeof (struct pine));
      memset((void *) p, 0, sizeof(struct pine));
+     p->thread_def_sort = SortDate;
      p->def_sort        = SortArrival;
      p->sort_types[0]   = SortSubject;
      p->sort_types[1]   = SortArrival;
***************
*** 116,121 ****
--- 117,125 ----
      if(!(pps && (*pps)))
        return;
  
+     if((*pps)->subject != NULL)
+       fs_give((void **)&(*pps)->subject);
+ 
      if((*pps)->hostname != NULL)
        fs_give((void **)&(*pps)->hostname);
  
***************
*** 131,136 ****
--- 135,143 ----
      if((*pps)->folders_dir != NULL)
        fs_give((void **)&(*pps)->folders_dir);
  
+     if((*pps)->paterror == 0)
+       regfree(&(*pps)->colorpat);
+ 
      if((*pps)->ui.homedir)
        fs_give((void **)&(*pps)->ui.homedir);
  
***************
*** 192,197 ****
--- 199,206 ----
      if((*pps)->kw_colors)
        free_spec_colors(&(*pps)->kw_colors);
  
+     free_allowed_qstr();
+ 
      if((*pps)->atmts){
  	int i;
  
***************
*** 206,211 ****
--- 215,223 ----
      if((*pps)->msgmap)
        msgno_give(&(*pps)->msgmap);
      
+     if((*pps)->rule_list)
+ 	free_parsed_rule_list(&(*pps)->rule_list);
+ 
      free_vars(*pps);
  
      fs_give((void **) pps);
diff -rc alpine-2.11/pith/state.h alpine-2.11.I.USE/pith/state.h
*** alpine-2.11/pith/state.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/state.h	2013-12-01 16:40:52.000000000 -0700
***************
*** 33,39 ****
  #include "../pith/stream.h"
  #include "../pith/color.h"
  #include "../pith/user.h"
! 
  
  /*
   * Printing control structure
--- 33,39 ----
  #include "../pith/stream.h"
  #include "../pith/color.h"
  #include "../pith/user.h"
! #include "../pith/rulestype.h"
  
  /*
   * Printing control structure
***************
*** 105,110 ****
--- 105,115 ----
      MAILSTREAM  *mail_stream;		/* ptr to current folder stream */
      MSGNO_S	*msgmap;		/* ptr to current message map   */
  
+     char	screen_name[10];	/* name of current screen */
+     char	*role;			/* role used when composing */
+     char	*procid;		/* procedure id when needed */
+     int		exiting;
+ 
      unsigned     read_predicted:1;
  
      char         cur_folder[MAXPATH+1];
***************
*** 137,142 ****
--- 142,149 ----
      unsigned     unseen_in_view:1;
      unsigned     start_in_context:1;	/* start fldr_scrn in current cntxt */
      unsigned     def_sort_rev:1;	/* true if reverse sort is default  */ 
+     unsigned	 thread_def_sort_rev:1; /* true if reverse sort is default in thread screen  */
+     unsigned	 msgmap_thread_def_sort_rev:1; /* true if reverse sort is being used in thread screen  */
      unsigned     restricted:1;
  
      unsigned     tcptimeout:1;		/* a tcp timeout is in progress  */
***************
*** 247,256 ****
--- 254,276 ----
      SPEC_COLOR_S *hdr_colors;		/* list of configed colors for view */
      SPEC_COLOR_S *index_token_colors;	/* list of configed colors for index */
  
+     char	*prefix;		/* prefix for fillpara */
+     char	**list_qstr;		/* list of known quote strings */
      short	 init_context;
  
+     struct { 
+ 	ACTION_S *role_chosen;
+ 	int attach;
+  	int strip;
+ 	int no_send_flowed;
+ 	int inchdr;
+     } reply;
+ 
      int         *initial_cmds;         /* cmds to execute on startup */
      int         *free_initial_cmds;    /* used to free when done */
+     int         *initial_cmds_backup;  /* keep a copy in case they are freed */
+     int         *free_initial_cmds_backup;  /* free the copy */
+     int		 initial_cmds_offset;	/* how many commands we have executed */
  
      char         c_client_error[300];  /* when nowhow_error is set and PARSE */
  
***************
*** 288,293 ****
--- 308,316 ----
      EditWhich	 ew_for_srch_take;
  
      SortOrder    def_sort,	/* Default sort type */
+ 		 thread_def_sort, /* Default Sort Type in Thread Screen */
+ 		 thread_cur_sort, /* current sort style for threads */
+ 		 msgmap_thread_sort,
  		 sort_types[22];
  
      int		 preserve;
***************
*** 304,313 ****
--- 327,342 ----
  
      int		 nmw_width;
  
+     char	*subject;
+     int		 send_immediately;
+     int		 failed_read;
+ 
      int          hours_to_timeout;
  
      int          tcp_query_timeout;
  
+     int		 sleep;	/* time in seconds to sleep before removing temp file */
+ 
      int          inc_check_timeout;
      int          inc_check_interval;		/* for local and IMAP */
      int          inc_second_check_interval;	/* for other */
***************
*** 326,331 ****
--- 355,362 ----
      char        *display_charmap;	/* needs to be freed */
      char        *keyboard_charmap;	/* needs to be freed */
      void        *input_cs;
+     regex_t	 colorpat;
+     int		 paterror;
  
      char        *posting_charmap;	/* needs to be freed */
  
***************
*** 337,342 ****
--- 368,374 ----
      struct {
          char	*(*display_filter)(char *, STORE_S *, gf_io_t, FILTLIST_S *);
          char	*(*display_filter_trigger)(BODY *, char *, size_t);
+ 	char	*(*exec_rule)(char *, gf_io_t, gf_io_t);
      } tools;
  
      KEYWORD_S   *keywords;
***************
*** 347,352 ****
--- 379,387 ----
      char	 last_error[500];
      INIT_ERR_S  *init_errs;
  
+     PRULELIST_S *rule_list;
+     char	*pressed_key;
+ 
      PRINT_S	*print;
  
  #ifdef SMIME
diff -rc alpine-2.11/pith/store.c alpine-2.11.I.USE/pith/store.c
*** alpine-2.11/pith/store.c	2013-08-14 22:36:22.000000000 -0600
--- alpine-2.11.I.USE/pith/store.c	2013-12-01 16:35:31.000000000 -0700
***************
*** 171,176 ****
--- 171,184 ----
  		if(source == TmpFileStar)
  		  our_unlink(so->name);
  
+ 		if (ps_global->send_immediately){
+ 		   ps_global->failed_read++;
+ 		   if(ps_global->failed_read == 5){
+ 		     printf("No configurationf file found. Where is your .pinerc file?\n");
+ 		     exit(1);
+ 		   }
+ 		}
+ 
  		fs_give((void **)&so->name);
  		fs_give((void **)&so); 		/* so freed & set to NULL */
  	    }
diff -rc alpine-2.11/pith/string.c alpine-2.11.I.USE/pith/string.c
*** alpine-2.11/pith/string.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/string.c	2013-12-01 16:34:57.000000000 -0700
***************
*** 20,25 ****
--- 20,26 ----
      string.c
      Misc extra and useful string functions
        - rplstr         replace a substring with another string
+       - collspaces     consecutive spaces are reduced to one space.
        - sqzspaces      Squeeze out the extra blanks in a string
        - sqznewlines    Squeeze out \n and \r.
        - removing_trailing_white_space 
***************
*** 132,137 ****
--- 133,163 ----
      return(x3);
  }
  
+ /*----------------------------------------------------------------------
+      collapse blank space
+   ----------------------------------------------------------------------*/
+ void
+ collspaces(char *string)
+ {
+     char *p = string;
+     int only_one_space = 0;
+ 
+     if(!string)
+       return;
+ 
+     for(;isspace(*p); p++);
+ 
+     while(*string = *p++)
+       if(!isspace((unsigned char)*string)){
+ 	only_one_space = 0;
+ 	string++;
+       }
+       else if(!only_one_space){
+ 		string++;
+ 		only_one_space++;
+ 	   }
+     *string = '\0';
+ }
  
  
  /*----------------------------------------------------------------------
***************
*** 2860,2862 ****
--- 2886,2920 ----
  	fs_give((void **) strp);
      }
  }
+ 
+ 
+ void
+ removing_extra_stuff(string)
+     char *string;
+ {
+     char *p = NULL;
+     int change = 0, length = 0;
+ 
+ 
+     if(!string)
+       return;
+ 
+     for(; *string; string++, length++)
+       p = ((unsigned char)*string != ',') ? NULL : (!p) ? string : p;
+ 
+     if(p)
+       *p = '\0';
+ 
+     string -= length;
+         for (; *string; string++){
+            if (change){
+               *string = ' ';
+               change = 0;
+            }
+            if ((((unsigned char)*string == ' ') ||
+                 ((unsigned char)*string == ',')) &&
+                 ((unsigned char)*(string + 1) == ','))
+             change++;
+         }
+ }
+ 
diff -rc alpine-2.11/pith/string.h alpine-2.11.I.USE/pith/string.h
*** alpine-2.11/pith/string.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/string.h	2013-12-01 16:34:57.000000000 -0700
***************
*** 86,97 ****
--- 86,99 ----
  
  /* exported protoypes */
  char	   *rplstr(char *, size_t, int, char *);
+ void	    collspaces(char *);
  void	    sqzspaces(char *);
  void	    sqznewlines(char *);
  void	    removing_leading_white_space(char *);
  void	    removing_trailing_white_space(char *);
  void	    removing_leading_and_trailing_white_space(char *);
  int 	    removing_double_quotes(char *);
+ void	    removing_extra_stuff (char *);
  char	   *skip_white_space(char *);
  char	   *skip_to_white_space(char *);
  char	   *removing_quotes(char *);
diff -rc alpine-2.11/pith/text.c alpine-2.11.I.USE/pith/text.c
*** alpine-2.11/pith/text.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/text.c	2013-12-01 16:38:26.000000000 -0700
***************
*** 92,98 ****
      char       *err, *charset;
      int		filtcnt = 0, error_found = 0, column, wrapit;
      int         is_in_sig = OUT_SIG_BLOCK;
!     int         is_flowed_msg = 0;
      int         is_delsp_yes = 0;
      int         filt_only_c0 = 0;
      char       *parmval;
--- 92,98 ----
      char       *err, *charset;
      int		filtcnt = 0, error_found = 0, column, wrapit;
      int         is_in_sig = OUT_SIG_BLOCK;
!     int         is_flowed_msg = 0, add_me = 1, doraw = RAWSTRING;
      int         is_delsp_yes = 0;
      int         filt_only_c0 = 0;
      char       *parmval;
***************
*** 171,176 ****
--- 171,185 ----
  						       gf_url_hilite_opt(&uh,handlesp,0));
  	}
  
+ 	if((flags & FM_DISPLAY)
+            && !(flags & FM_NOCOLOR)
+            && pico_usingcolor()
+            && VAR_SPECIAL_TEXT_FORE_COLOR 
+            && VAR_SPECIAL_TEXT_BACK_COLOR){
+             filters[filtcnt].filter = gf_line_test;
+             filters[filtcnt++].data = gf_line_test_opt(color_this_text, NULL);
+         }
+ 
  	/*
  	 * First, paint the signature.
  	 * Disclaimers noted below for coloring quotes apply here as well.
***************
*** 180,186 ****
  	   && pico_usingcolor()
  	   && VAR_SIGNATURE_FORE_COLOR
  	   && VAR_SIGNATURE_BACK_COLOR){
! 	    filters[filtcnt].filter = gf_line_test;
  	    filters[filtcnt++].data = gf_line_test_opt(color_signature,
  						       &is_in_sig);
  	}
--- 189,195 ----
  	   && pico_usingcolor()
  	   && VAR_SIGNATURE_FORE_COLOR
  	   && VAR_SIGNATURE_BACK_COLOR){
! 	    filters[filtcnt].filter = gf_quote_test;
  	    filters[filtcnt++].data = gf_line_test_opt(color_signature,
  						       &is_in_sig);
  	}
***************
*** 198,206 ****
  	   && pico_usingcolor()
  	   && VAR_QUOTE1_FORE_COLOR
  	   && VAR_QUOTE1_BACK_COLOR){
! 	    filters[filtcnt].filter = gf_line_test;
! 	    filters[filtcnt++].data = gf_line_test_opt(color_a_quote,
! 						       &is_flowed_msg);
  	}
      }
      else if(!strucmp(att->body->subtype, "richtext")){
--- 207,215 ----
  	   && pico_usingcolor()
  	   && VAR_QUOTE1_FORE_COLOR
  	   && VAR_QUOTE1_BACK_COLOR){
! 	    add_me = 0;
! 	    filters[filtcnt].filter = gf_quote_test;
! 	    filters[filtcnt++].data = gf_line_test_opt(color_a_quote, &is_flowed_msg);
  	}
      }
      else if(!strucmp(att->body->subtype, "richtext")){
***************
*** 281,286 ****
--- 290,300 ----
  	}
      }
  
+     if (add_me){
+       filters[filtcnt].filter = gf_quote_test;
+       filters[filtcnt++].data = gf_line_test_opt(select_quote, &doraw);
+     }
+ 
      /*
       * If the message is not flowed, we do the quote suppression before
       * the wrapping, because the wrapping does not preserve the quote
***************
*** 305,311 ****
  	    dq.handlesp   = handlesp;
  	    dq.do_color   = (!(flags & FM_NOCOLOR) && pico_usingcolor());
  
! 	    filters[filtcnt].filter = gf_line_test;
  	    filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &dq);
  	}
  	if(ps_global->VAR_QUOTE_REPLACE_STRING
--- 319,325 ----
  	    dq.handlesp   = handlesp;
  	    dq.do_color   = (!(flags & FM_NOCOLOR) && pico_usingcolor());
  
! 	    filters[filtcnt].filter = gf_quote_test;
  	    filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &dq);
  	}
  	if(ps_global->VAR_QUOTE_REPLACE_STRING
***************
*** 364,370 ****
  	dq.handlesp   = handlesp;
  	dq.do_color   = (!(flags & FM_NOCOLOR) && pico_usingcolor());
  
! 	filters[filtcnt].filter = gf_line_test;
  	filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &dq);
      }
  
--- 378,384 ----
  	dq.handlesp   = handlesp;
  	dq.do_color   = (!(flags & FM_NOCOLOR) && pico_usingcolor());
  
! 	filters[filtcnt].filter = gf_quote_test;
  	filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &dq);
      }
  
***************
*** 569,575 ****
  {
      DELQ_S *dq;
      char   *lp;
!     int     i, lines, not_a_quote = 0;
      size_t  len;
  
      dq = (DELQ_S *) local;
--- 583,589 ----
  {
      DELQ_S *dq;
      char   *lp;
!     int     i, lines, not_a_quote = 0, code;
      size_t  len;
  
      dq = (DELQ_S *) local;
***************
*** 589,594 ****
--- 603,610 ----
  	for(i = dq->indent_length; i > 0 && !not_a_quote && *lp; i--)
  	  if(*lp++ != SPACE)
  	    not_a_quote++;
+ 	while(isspace((unsigned char) *lp))
+ 	   lp++;
  	
  	/* skip over leading tags */
  	while(!not_a_quote
***************
*** 628,640 ****
  	    }
  	}
  
! 	/* skip over whitespace */
! 	if(!dq->is_flowed)
! 	  while(isspace((unsigned char) *lp))
! 	    lp++;
! 
! 	/* check first character to see if it is a quote */
! 	if(!not_a_quote && *lp != '>')
  	  not_a_quote++;
  
  	if(not_a_quote){
--- 644,655 ----
  	    }
  	}
  
! 	len = lp - line;
! 	if(strlen(tmp_20k_buf) > len)
! 	  strcpy(tmp_20k_buf, tmp_20k_buf+len);
!         code =  (dq->is_flowed ? IS_FLOWED : NO_FLOWED) | DELETEQUO;
! 	select_quote(linenum, lp, ins,  &code);
! 	if (!not_a_quote && !tmp_20k_buf[0])
  	  not_a_quote++;
  
  	if(not_a_quote){
diff -rc alpine-2.11/pith/thread.c alpine-2.11.I.USE/pith/thread.c
*** alpine-2.11/pith/thread.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/thread.c	2013-12-01 16:40:27.000000000 -0700
***************
*** 30,41 ****
  #include "../pith/mailcmd.h"
  #include "../pith/ablookup.h"
  
  
  /*
   * Internal prototypes
   */
  long *sort_thread_flatten(THREADNODE *, MAILSTREAM *, long *,
! 			  char *, long, PINETHRD_S *, unsigned);
  void		   make_thrdflags_consistent(MAILSTREAM *, MSGNO_S *, PINETHRD_S *, int);
  THREADNODE	  *collapse_threadnode_tree(THREADNODE *);
  THREADNODE	  *collapse_threadnode_tree_sorted(THREADNODE *);
--- 30,47 ----
  #include "../pith/mailcmd.h"
  #include "../pith/ablookup.h"
  
+ static int erase_thread_info = 1;
+ 
+ typedef struct sizethread_t {
+    int   count;
+    long  pos;
+ } SIZETHREAD_T;
  
  /*
   * Internal prototypes
   */
  long *sort_thread_flatten(THREADNODE *, MAILSTREAM *, long *,
! 			  char *, long, PINETHRD_S *, unsigned, int, long, long);
  void		   make_thrdflags_consistent(MAILSTREAM *, MSGNO_S *, PINETHRD_S *, int);
  THREADNODE	  *collapse_threadnode_tree(THREADNODE *);
  THREADNODE	  *collapse_threadnode_tree_sorted(THREADNODE *);
***************
*** 43,48 ****
--- 49,55 ----
  THREADNODE        *insert_tree_in_place(THREADNODE *, THREADNODE *);
  unsigned long      branch_greatest_num(THREADNODE *, int);
  long		   calculate_visible_threads(MAILSTREAM *);
+ int		   pine_compare_size_thread(const qsort_t *, const qsort_t *);
  
  
  PINETHRD_S *
***************
*** 95,114 ****
  set_flags_for_thread(MAILSTREAM *stream, MSGNO_S *msgmap, int f, PINETHRD_S *thrd, int v)
  {
      PINETHRD_S *nthrd, *bthrd;
  
      if(!(stream && thrd && msgmap))
        return;
  
      set_lflag(stream, msgmap, mn_raw2m(msgmap, thrd->rawno), f, v);
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_flags_for_thread(stream, msgmap, f, nthrd, v);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  set_flags_for_thread(stream, msgmap, f, bthrd, v);
      }
--- 102,123 ----
  set_flags_for_thread(MAILSTREAM *stream, MSGNO_S *msgmap, int f, PINETHRD_S *thrd, int v)
  {
      PINETHRD_S *nthrd, *bthrd;
+     unsigned long next = 0L, branch = 0L;
  
      if(!(stream && thrd && msgmap))
        return;
  
      set_lflag(stream, msgmap, mn_raw2m(msgmap, thrd->rawno), f, v);
  
!     if(next = get_next(stream,thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  set_flags_for_thread(stream, msgmap, f, nthrd, v);
      }
  
! 
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  set_flags_for_thread(stream, msgmap, f, bthrd, v);
      }
***************
*** 122,128 ****
      MESSAGECACHE *mc;
      PINELT_S     *peltp;
  
!     if(!(stream && stream->spare))
        return;
      
      ps_global->view_skipped_index = 0;
--- 131,137 ----
      MESSAGECACHE *mc;
      PINELT_S     *peltp;
  
!     if(!(stream && stream->spare) || !erase_thread_info)
        return;
      
      ps_global->view_skipped_index = 0;
***************
*** 155,161 ****
      PINETHRD_S   *thrd = NULL;
      unsigned long msgno, rawno;
      int           un_view_thread = 0;
!     long          raw_current;
      char         *dup_chk = NULL;
  
  
--- 164,170 ----
      PINETHRD_S   *thrd = NULL;
      unsigned long msgno, rawno;
      int           un_view_thread = 0;
!     long          raw_current, branch;
      char         *dup_chk = NULL;
  
  
***************
*** 168,177 ****
       * way. If the dummy node is at the top-level, then its children are
       * promoted to the top-level as separate threads.
       */
!     if(F_ON(F_THREAD_SORTS_BY_ARRIVAL, ps_global))
!       collapsed_tree = collapse_threadnode_tree_sorted(tree);
!     else
!       collapsed_tree = collapse_threadnode_tree(tree);
  
      /* dup_chk is like sort with an origin of 1 */
      dup_chk = (char *) fs_get((mn_get_nmsgs(g_sort.msgmap)+1) * sizeof(char));
--- 177,187 ----
       * way. If the dummy node is at the top-level, then its children are
       * promoted to the top-level as separate threads.
       */
!      collapsed_tree = F_ON(F_ENHANCED_THREAD, ps_global)
! 			? copy_tree(tree)
! 			: (F_ON(F_THREAD_SORTS_BY_ARRIVAL, ps_global)
! 			  ? collapse_threadnode_tree_sorted(tree)
! 			  : collapse_threadnode_tree(tree));
  
      /* dup_chk is like sort with an origin of 1 */
      dup_chk = (char *) fs_get((mn_get_nmsgs(g_sort.msgmap)+1) * sizeof(char));
***************
*** 182,188 ****
      (void) sort_thread_flatten(collapsed_tree, stream,
  			       &g_sort.msgmap->sort[1],
  			       dup_chk, mn_get_nmsgs(g_sort.msgmap),
! 			       NULL, THD_TOP);
  
      /* reset the inverse array */
      msgno_reset_isort(g_sort.msgmap);
--- 192,198 ----
      (void) sort_thread_flatten(collapsed_tree, stream,
  			       &g_sort.msgmap->sort[1],
  			       dup_chk, mn_get_nmsgs(g_sort.msgmap),
! 			       NULL, THD_TOP, 0, 1L, 0L);
  
      /* reset the inverse array */
      msgno_reset_isort(g_sort.msgmap);
***************
*** 340,351 ****
  	else{
  	    thrd = fetch_head_thread(stream);
  	    while(thrd){
  		/*
  		 * The top-level threads aren't hidden by collapse.
  		 */
  		msgno = mn_raw2m(g_sort.msgmap, thrd->rawno);
! 		if(msgno)
! 		  set_lflag(stream, g_sort.msgmap, msgno, MN_CHID, 0);
  
  		if(thrd->next){
  		    PINETHRD_S *nthrd;
--- 350,363 ----
  	else{
  	    thrd = fetch_head_thread(stream);
  	    while(thrd){
+ 		unsigned long raw = thrd->rawno;
+ 		unsigned long top = top_thread(stream, raw);
  		/*
  		 * The top-level threads aren't hidden by collapse.
  		 */
  		msgno = mn_raw2m(g_sort.msgmap, thrd->rawno);
! 		if(msgno && !get_lflag(stream, NULL,thrd->rawno, MN_COLL))
! 		   set_lflag(stream, g_sort.msgmap, msgno, MN_CHID, 0);
  
  		if(thrd->next){
  		    PINETHRD_S *nthrd;
***************
*** 359,367 ****
  							  MN_COLL));
  		}
  
! 		if(thrd->nextthd)
! 		  thrd = fetch_thread(stream, thrd->nextthd);
! 		else
  		  thrd = NULL;
  	    }
  	}
--- 371,380 ----
  							  MN_COLL));
  		}
  
! 		while (thrd && top_thread(stream, thrd->rawno) == top
! 				&& thrd->nextthd)
! 		thrd = fetch_thread(stream, thrd->nextthd);
! 		if (!(thrd && thrd->nextthd))
  		  thrd = NULL;
  	    }
  	}
***************
*** 412,418 ****
  			  int a_parent_is_collapsed)
  {
      PINETHRD_S *nthrd, *bthrd;
!     unsigned long msgno;
  
      if(!thrd)
        return;
--- 425,431 ----
  			  int a_parent_is_collapsed)
  {
      PINETHRD_S *nthrd, *bthrd;
!     unsigned long msgno, next, branch;
  
      if(!thrd)
        return;
***************
*** 430,437 ****
  	  set_lflag(stream, msgmap, msgno, MN_CHID, 0);
      }
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  make_thrdflags_consistent(stream, msgmap, nthrd,
  				    a_parent_is_collapsed
--- 443,450 ----
  	  set_lflag(stream, msgmap, msgno, MN_CHID, 0);
      }
  
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  make_thrdflags_consistent(stream, msgmap, nthrd,
  				    a_parent_is_collapsed
***************
*** 440,447 ****
  						  MN_COLL));
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  make_thrdflags_consistent(stream, msgmap, bthrd,
  				    a_parent_is_collapsed);
--- 453,460 ----
  						  MN_COLL));
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  make_thrdflags_consistent(stream, msgmap, bthrd,
  				    a_parent_is_collapsed);
***************
*** 488,496 ****
  long *
  sort_thread_flatten(THREADNODE *node, MAILSTREAM *stream,
  		    long *entry, char *dup_chk, long maxno,
! 		    PINETHRD_S *thrd, unsigned int flags)
  {
!     PINETHRD_S *newthrd = NULL;
  
      if(node){
  	if(node->num > 0L && node->num <= maxno){		/* holes happen */
--- 501,510 ----
  long *
  sort_thread_flatten(THREADNODE *node, MAILSTREAM *stream,
  		    long *entry, char *dup_chk, long maxno,
! 		    PINETHRD_S *thrd, unsigned int flags,
! 		    int adopted, long top, long threadno)
  {
!     PINETHRD_S *newthrd = NULL, *save_thread = NULL;
  
      if(node){
  	if(node->num > 0L && node->num <= maxno){		/* holes happen */
***************
*** 498,503 ****
--- 512,520 ----
  		*entry = node->num;
  		dup_chk[node->num] = 1;
  
+ 		if(adopted == 2)
+ 		  top = node->num;
+ 
  		/*
  		 * Build a richer threading structure that will help us paint
  		 * and operate on threads and subthreads.
***************
*** 506,525 ****
  		if(newthrd){
  		  entry++;
  
  		  if(node->next)
  		    entry = sort_thread_flatten(node->next, stream,
  						entry, dup_chk, maxno,
! 						newthrd, THD_NEXT);
  
  		  if(node->branch)
  		    entry = sort_thread_flatten(node->branch, stream,
  						entry, dup_chk, maxno,
  						newthrd,
! 						(flags == THD_TOP) ? THD_TOP
! 								   : THD_BRANCH);
  		}
  	    }
  	}
      }
  
      return(entry);
--- 523,573 ----
  		if(newthrd){
  		  entry++;
  
+ 		  if(adopted == 2)
+ 		    threadno = newthrd->thrdno;
+ 		  if(adopted){
+ 		    newthrd->toploose = top;
+ 		    newthrd->thrdno = threadno;
+ 		  }
+ 		  adopted = adopted ? 1 : 0;
  		  if(node->next)
  		    entry = sort_thread_flatten(node->next, stream,
  						entry, dup_chk, maxno,
! 						newthrd, THD_NEXT, adopted, top, threadno);
  
  		  if(node->branch)
  		    entry = sort_thread_flatten(node->branch, stream,
  						entry, dup_chk, maxno,
  						newthrd,
! 						((flags == THD_TOP) ? THD_TOP
! 								   : THD_BRANCH),
! 						adopted, top, threadno);
  		}
  	    }
  	}
+ 	else{
+ 	   adopted = 2;
+ 	   if(node->next)
+ 	     entry = sort_thread_flatten(node->next, stream, entry, dup_chk,
+ 					  maxno, thrd, THD_TOP, adopted, top, threadno);
+ 	   adopted = 0;
+ 	   if(node->branch){
+ 	     if(entry){
+ 		long *last_entry = entry;
+ 
+ 		do{ 
+ 		  last_entry--;
+ 		  save_thread = ((PINELT_S *)mail_elt(stream, *last_entry)->sparep)->pthrd;
+ 		} while (save_thread->parent != 0L);
+ 		entry = sort_thread_flatten(node->branch, stream, entry, dup_chk,
+ 						maxno, save_thread, (flags == THD_TOP ? THD_TOP : THD_BRANCH),
+ 						adopted, top, threadno);
+ 	     }
+ 	     else
+ 		entry = sort_thread_flatten(node->branch, stream, entry, dup_chk,
+ 					    maxno, NULL, THD_TOP, adopted, top, threadno);
+ 	   }
+ 	}
      }
  
      return(entry);
***************
*** 788,794 ****
   */
  void
  collapse_or_expand(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap,
! 		   long unsigned int msgno)
  {
      int           collapsed, adjust_current = 0;
      PINETHRD_S   *thrd = NULL, *nthrd;
--- 836,842 ----
   */
  void
  collapse_or_expand(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap,
! 		   long unsigned int msgno, int display)
  {
      int           collapsed, adjust_current = 0;
      PINETHRD_S   *thrd = NULL, *nthrd;
***************
*** 841,847 ****
      if(!thrd)
        return;
  
!     collapsed = get_lflag(stream, NULL, thrd->rawno, MN_COLL) && thrd->next;
  
      if(collapsed){
  	msgno = mn_raw2m(msgmap, thrd->rawno);
--- 889,895 ----
      if(!thrd)
        return;
  
!     collapsed = this_thread_is_kolapsed(ps_global, stream, msgmap, thrd->rawno);
  
      if(collapsed){
  	msgno = mn_raw2m(msgmap, thrd->rawno);
***************
*** 859,871 ****
  	msgno = mn_raw2m(msgmap, thrd->rawno);
  	if(msgno > 0L && msgno <= mn_get_total(msgmap)){
  	    set_lflag(stream, msgmap, msgno, MN_COLL, 1);
! 	    if((nthrd = fetch_thread(stream, thrd->next)) != NULL)
  	      set_thread_subtree(stream, nthrd, msgmap, 1, MN_CHID);
  
  	    clear_index_cache_ent(stream, msgno, 0);
  	}
      }
!     else
        q_status_message(SM_ORDER, 0, 1,
  		       _("No thread to collapse or expand on this line"));
      
--- 907,919 ----
  	msgno = mn_raw2m(msgmap, thrd->rawno);
  	if(msgno > 0L && msgno <= mn_get_total(msgmap)){
  	    set_lflag(stream, msgmap, msgno, MN_COLL, 1);
! 	    if((thrd->next) && ((nthrd = fetch_thread(stream, thrd->next)) != NULL))
  	      set_thread_subtree(stream, nthrd, msgmap, 1, MN_CHID);
  
  	    clear_index_cache_ent(stream, msgno, 0);
  	}
      }
!     else if(display)
        q_status_message(SM_ORDER, 0, 1,
  		       _("No thread to collapse or expand on this line"));
      
***************
*** 952,969 ****
      unsigned long count = 0;
      PINETHRD_S *nthrd, *bthrd;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
      
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  count += count_flags_in_thread(stream, nthrd, flags);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  count += count_flags_in_thread(stream, bthrd, flags);
      }
--- 1000,1018 ----
      unsigned long count = 0;
      PINETHRD_S *nthrd, *bthrd;
      MESSAGECACHE *mc;
+     unsigned long next = 0L, branch = 0L;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
      
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  count += count_flags_in_thread(stream, nthrd, flags);
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  count += count_flags_in_thread(stream, bthrd, flags);
      }
***************
*** 1051,1070 ****
  mark_msgs_in_thread(MAILSTREAM *stream, PINETHRD_S *thrd, MSGNO_S *msgmap)
  {
      int           count = 0;
      PINETHRD_S   *nthrd, *bthrd;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  count += mark_msgs_in_thread(stream, nthrd, msgmap);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  count += mark_msgs_in_thread(stream, bthrd, msgmap);
      }
--- 1100,1120 ----
  mark_msgs_in_thread(MAILSTREAM *stream, PINETHRD_S *thrd, MSGNO_S *msgmap)
  {
      int           count = 0;
+     long          next, branch;
      PINETHRD_S   *nthrd, *bthrd;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return count;
  
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  count += mark_msgs_in_thread(stream, nthrd, msgmap);
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  count += mark_msgs_in_thread(stream, bthrd, msgmap);
      }
***************
*** 1098,1104 ****
                        		/* flags to set or clear */
                    		/* set or clear? */
  {
!     unsigned long msgno;
      PINETHRD_S *nthrd, *bthrd;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
--- 1148,1154 ----
                        		/* flags to set or clear */
                    		/* set or clear? */
  {
!     unsigned long msgno, next, branch;
      PINETHRD_S *nthrd, *bthrd;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
***************
*** 1122,1135 ****
      if(msgno > 0L && flags == MN_CHID2 && v == 1)
        clear_index_cache_ent(stream, msgno, 0);
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_thread_lflags(stream, nthrd, msgmap, flags, v);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  set_thread_lflags(stream, bthrd, msgmap, flags, v);
      }
--- 1172,1185 ----
      if(msgno > 0L && flags == MN_CHID2 && v == 1)
        clear_index_cache_ent(stream, msgno, 0);
  
!     if(next = get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  set_thread_lflags(stream, nthrd, msgmap, flags, v);
      }
  
!     if(branch = get_branch(stream,thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  set_thread_lflags(stream, bthrd, msgmap, flags, v);
      }
***************
*** 1210,1216 ****
  /*
   * Symbol is * if some message in thread is important,
   * + if some message is to us,
!  * - if mark-for-cc and some message is cc to us, else blank.
   */
  char
  to_us_symbol_for_thread(MAILSTREAM *stream, PINETHRD_S *thrd, int consider_flagged)
--- 1260,1267 ----
  /*
   * Symbol is * if some message in thread is important,
   * + if some message is to us,
!  * - if mark-for-cc and some message is cc to us, 
!  * . if mark-for-group and some message is to us in a group, else blank.
   */
  char
  to_us_symbol_for_thread(MAILSTREAM *stream, PINETHRD_S *thrd, int consider_flagged)
***************
*** 1218,1262 ****
      char        to_us = ' ';
      char        branch_to_us = ' ';
      PINETHRD_S *nthrd, *bthrd;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return to_us;
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  to_us = to_us_symbol_for_thread(stream, nthrd, consider_flagged);
      }
  
      if(((consider_flagged && to_us != '*') || (!consider_flagged && to_us != '+'))
!        && thrd->branch){
  	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  branch_to_us = to_us_symbol_for_thread(stream, bthrd, consider_flagged);
  
  	/* use branch to_us symbol if it has higher priority than what we have so far */
  	if(to_us == ' '){
! 	    if(branch_to_us == '-' || branch_to_us == '+' || branch_to_us == '*')
  	      to_us = branch_to_us;
  	}
  	else if(to_us == '-'){
! 	    if(branch_to_us == '+' || branch_to_us == '*')
  	      to_us = branch_to_us;
  	}
! 	else if(to_us == '+'){
  	    if(branch_to_us == '*')
  	      to_us = branch_to_us;
  	}
      }
  
!     if((consider_flagged && to_us != '*') || (!consider_flagged && to_us != '+')){
  	if(consider_flagged && thrd && thrd->rawno > 0L
  	   && stream && thrd->rawno <= stream->nmsgs
  	   && (mc = mail_elt(stream, thrd->rawno))
  	   && FLAG_MATCH(F_FLAG, mc, stream))
  	  to_us = '*';
! 	else if(to_us != '+' && !IS_NEWS(stream)){
  	    INDEXDATA_S   idata;
  	    MESSAGECACHE *mc;
  	    ADDRESS      *addr;
--- 1269,1316 ----
      char        to_us = ' ';
      char        branch_to_us = ' ';
      PINETHRD_S *nthrd, *bthrd;
+     unsigned long next = 0L, branch = 0L;
      MESSAGECACHE *mc;
  
      if(!thrd || !stream || thrd->rawno < 1L || thrd->rawno > stream->nmsgs)
        return to_us;
  
!     if(next = get_next(stream,thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  to_us = to_us_symbol_for_thread(stream, nthrd, consider_flagged);
      }
  
      if(((consider_flagged && to_us != '*') || (!consider_flagged && to_us != '+'))
!        && (branch = get_branch(stream, thrd))){
  	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  branch_to_us = to_us_symbol_for_thread(stream, bthrd, consider_flagged);
  
  	/* use branch to_us symbol if it has higher priority than what we have so far */
  	if(to_us == ' '){
! 	    if(branch_to_us == '-' || branch_to_us == '+' 
! 		|| branch_to_us == '.' || branch_to_us == '*')
  	      to_us = branch_to_us;
  	}
  	else if(to_us == '-'){
! 	    if(branch_to_us == '+' || branch_to_us == '.' || branch_to_us == '*')
  	      to_us = branch_to_us;
  	}
! 	else if(to_us == '+' || to_us == '.'){
  	    if(branch_to_us == '*')
  	      to_us = branch_to_us;
  	}
      }
  
!     if((consider_flagged && to_us != '*') 
! 		|| (!consider_flagged && to_us != '+' && to_us != '.')){
  	if(consider_flagged && thrd && thrd->rawno > 0L
  	   && stream && thrd->rawno <= stream->nmsgs
  	   && (mc = mail_elt(stream, thrd->rawno))
  	   && FLAG_MATCH(F_FLAG, mc, stream))
  	  to_us = '*';
! 	else if(to_us != '+' && to_us != '.' && !IS_NEWS(stream)){
  	    INDEXDATA_S   idata;
  	    MESSAGECACHE *mc;
  	    ADDRESS      *addr;
***************
*** 1280,1286 ****
  		  break;
  	      }
  	    
! 	    if(to_us != '+' && resent_to_us(&idata))
  	      to_us = '+';
  
  	    if(to_us == ' ' && F_ON(F_MARK_FOR_CC,ps_global))
--- 1334,1340 ----
  		  break;
  	      }
  	    
! 	    if(to_us != '+' && !idata.bogus && resent_to_us(&idata))
  	      to_us = '+';
  
  	    if(to_us == ' ' && F_ON(F_MARK_FOR_CC,ps_global))
***************
*** 1328,1334 ****
  
      set_lflag(stream, msgmap, msgno, flags, v);
  
!     if(thrd->next && (hiding || !get_lflag(stream,NULL,thrd->rawno,MN_COLL))){
  	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_thread_subtree(stream, nthrd, msgmap, v, flags);
--- 1382,1389 ----
  
      set_lflag(stream, msgmap, msgno, flags, v);
  
!     if(thrd->next
! 	 && (hiding || !get_lflag(stream,NULL,thrd->rawno,MN_COLL))){
  	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_thread_subtree(stream, nthrd, msgmap, v, flags);
***************
*** 1368,1375 ****
      if(rawno)
        thrd = fetch_thread(stream, rawno);
  
!     if(thrd && thrd->top && thrd->top != thrd->rawno)
!       thrd = fetch_thread(stream, thrd->top);
      
      if(!thrd)
        return 0;
--- 1423,1430 ----
      if(rawno)
        thrd = fetch_thread(stream, rawno);
  
!     if(thrd && thrd->top && top_thread(stream,thrd->top) != thrd->rawno)
!       thrd = fetch_thread(stream, top_thread(stream,thrd->top));
      
      if(!thrd)
        return 0;
***************
*** 1433,1439 ****
        thrd = fetch_thread(stream, rawno);
      
      if(thrd && thrd->top)
!       topthrd = fetch_thread(stream, thrd->top);
      
      if(!topthrd)
        return 0;
--- 1488,1494 ----
        thrd = fetch_thread(stream, rawno);
      
      if(thrd && thrd->top)
!       topthrd = fetch_thread(stream, top_thread(stream,thrd->top));
      
      if(!topthrd)
        return 0;
***************
*** 1539,1544 ****
--- 1594,1600 ----
  set_search_bit_for_thread(MAILSTREAM *stream, PINETHRD_S *thrd, SEARCHSET **msgset)
  {
      PINETHRD_S *nthrd, *bthrd;
+     unsigned long next, branch;
  
      if(!(stream && thrd))
        return;
***************
*** 1547,1561 ****
         && (!(msgset && *msgset) || in_searchset(*msgset, thrd->rawno)))
        mm_searched(stream, thrd->rawno);
  
!     if(thrd->next){
! 	nthrd = fetch_thread(stream, thrd->next);
  	if(nthrd)
  	  set_search_bit_for_thread(stream, nthrd, msgset);
      }
  
!     if(thrd->branch){
! 	bthrd = fetch_thread(stream, thrd->branch);
  	if(bthrd)
  	  set_search_bit_for_thread(stream, bthrd, msgset);
      }
  }
--- 1603,2224 ----
         && (!(msgset && *msgset) || in_searchset(*msgset, thrd->rawno)))
        mm_searched(stream, thrd->rawno);
  
!     if(next= get_next(stream, thrd)){
! 	nthrd = fetch_thread(stream, next);
  	if(nthrd)
  	  set_search_bit_for_thread(stream, nthrd, msgset);
      }
  
!     if(branch = get_branch(stream, thrd)){
! 	bthrd = fetch_thread(stream, branch);
  	if(bthrd)
  	  set_search_bit_for_thread(stream, bthrd, msgset);
      }
  }
+ 
+ /*
+  * Make a copy of c-client's THREAD tree
+  */
+ THREADNODE *
+ copy_tree(THREADNODE *tree)
+ {
+     THREADNODE *newtree = NULL;
+ 
+     if(tree){
+         newtree = mail_newthreadnode(NULL);
+         newtree->num  = tree->num;
+         if(tree->next)
+            newtree->next = copy_tree(tree->next);
+ 
+         if(tree->branch)
+            newtree->branch = copy_tree(tree->branch);
+     }
+     return(newtree);
+ }
+ 
+ long
+ top_thread(MAILSTREAM *stream, long rawmsgno)
+ {
+      PINETHRD_S   *thrd = NULL;
+      unsigned long rawno;
+ 
+      if(!stream)
+        return -1L;
+ 
+      if(rawmsgno)
+        thrd = fetch_thread(stream, rawmsgno);
+ 
+      if(!thrd)
+        return -1L;
+ 
+      return F_ON(F_ENHANCED_THREAD, ps_global) 
+ 		? (thrd->toploose ? thrd->toploose : thrd->top)
+ 		: thrd->top;
+ }
+ 
+ void
+ move_top_thread(MAILSTREAM *stream, MSGNO_S *msgmap, long rawmsgno)
+ {
+     mn_set_cur(msgmap,mn_raw2m(msgmap, top_thread(stream, rawmsgno)));
+ }
+ 
+ long
+ top_this_thread(MAILSTREAM *stream, long rawmsgno)
+ {
+      PINETHRD_S   *thrd = NULL;
+      unsigned long rawno;
+ 
+      if(!stream)
+        return -1L;
+ 
+      if(rawmsgno)
+        thrd = fetch_thread(stream, rawmsgno);
+ 
+      if(!thrd)
+        return -1L;
+ 
+      return thrd->top;
+ }
+ 
+ void
+ move_top_this_thread(MAILSTREAM *stream, MSGNO_S *msgmap, long rawmsgno)
+ {
+     mn_set_cur(msgmap,mn_raw2m(msgmap, top_this_thread(stream, rawmsgno)));
+ }
+ 
+ int
+ thread_is_kolapsed(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap, long rawmsgno)
+ {
+     int          collapsed;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno, orig, orig_rawno;
+ 
+     if(!stream)
+       return -1;
+ 
+     orig = mn_get_cur(msgmap);
+     move_top_thread(stream, msgmap, rawmsgno);
+     rawno = orig_rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return -1;
+     
+     while(collapsed = this_thread_is_kolapsed(state, stream, msgmap, rawno))
+        if (F_OFF(F_ENHANCED_THREAD, state)
+           || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	  || !(rawno = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	  || (orig_rawno != top_thread(stream, rawno)))
+ 	break;
+ 
+     mn_set_cur(msgmap,orig); /* return home */
+ 
+     return collapsed;
+ }
+ 
+ /* this function tells us if the thread (or branch in the case of loose threads)
+  * is collapsed
+  */
+ 
+ int
+ this_thread_is_kolapsed(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap, long rawmsgno)
+ {
+     int          collapsed;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno, orig;
+ 
+     if(!stream)
+       return -1;
+ 
+     rawno = rawmsgno;
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return -1;
+ 
+     collapsed = get_lflag(stream, NULL, rawno, MN_COLL | MN_CHID);
+ 
+     if (!thrd->next){
+       if (thrd->rawno != top_thread(stream, thrd->rawno))
+ 	collapsed = get_lflag(stream, NULL, rawno,  MN_CHID);
+       else
+ 	collapsed = get_lflag(stream, NULL, rawno,  MN_COLL);
+     }
+ 
+     return collapsed;
+ }
+ 
+ /* 
+  * This function assumes that it is called at a top of a thread in its 
+  * first call
+  */
+ 
+ int
+ count_this_thread(MAILSTREAM *stream, unsigned long rawno)
+ {
+     unsigned long top, orig_top, topnxt;
+     PINETHRD_S   *thrd = NULL;
+     int count = 1;
+ 
+     if(!stream)
+       return 0;
+ 
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return 0;
+ 
+     if (thrd->next)
+        count += count_this_thread(stream, thrd->next);
+ 
+     if (thrd->branch)
+        count += count_this_thread(stream, thrd->branch);
+ 
+     return count;
+ }
+ 
+ int
+ count_thread(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap, long rawno)
+ {
+     unsigned long top, orig, orig_top;
+     PINETHRD_S   *thrd = NULL;
+     int done = 0, count = 0;
+ 
+     if(!stream)
+       return 0;
+ 
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap,rawno);
+     top =  orig_top = top_thread(stream, rawno);
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return 0;
+ 
+     while (!done){
+       count += count_this_thread(stream, top);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || (move_next_this_thread(state, stream, msgmap, 0) <= 0)
+ 	 || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+ 	 || (orig_top != top_thread(stream, top)))
+ 	 done++;
+     }
+     mn_set_cur(msgmap,mn_raw2m(msgmap, orig));
+     return count;
+ }
+ 
+ unsigned long
+ get_branch(MAILSTREAM *stream, PINETHRD_S *thrd)
+ {
+   PINETHRD_S *nthrd = NULL;
+   unsigned long top;
+  
+   if (thrd->toploose && thrd->nextthd)
+     nthrd = fetch_thread(stream, thrd->nextthd);
+   if (!nthrd)
+     return thrd->branch;
+   top = top_thread(stream, thrd->rawno);
+   return thrd->branch 
+ 	   ? thrd->branch 
+ 	   : (F_ON(F_ENHANCED_THREAD, ps_global) 
+ 		? (top == top_thread(stream, nthrd->rawno) ? thrd->nextthd : 0L)
+ 		: 0L);
+ }
+ 
+ unsigned long
+ get_next(MAILSTREAM *stream, PINETHRD_S *thrd)
+ {
+   return thrd->next;
+ }
+ 
+ long
+ get_length_branch(MAILSTREAM *stream, long rawno)
+ {
+   int branchp = 0, done = 0;
+   long top, count = 1L, raw;
+   PINETHRD_S *thrd, *pthrd = NULL, *nthrd;
+ 
+   thrd = fetch_thread(stream, rawno);
+ 
+   if (!thrd)
+     return -1L;
+ 
+   top = thrd->top;
+ 
+   if (thrd->parent)
+     pthrd = fetch_thread(stream, thrd->parent);
+ 
+   if (thrd->rawno == top)
+      branchp++;
+ 
+   if (!branchp && !pthrd){	/* what!!?? */
+      raw = top;
+      while (!done){
+         pthrd = fetch_thread(stream, raw);
+         if ((pthrd->next == rawno) || (pthrd->branch == rawno))
+            done++;
+         else{
+ 	   if (pthrd->next)
+ 	      raw = pthrd->next;
+ 	   else if (pthrd->branch)
+ 	      raw = pthrd->branch;
+ 	}
+      }
+   }
+ 
+   if (pthrd && pthrd->next == thrd->rawno && thrd->branch)
+      branchp++;
+ 
+   if (pthrd && pthrd->next && pthrd->next != thrd->rawno){
+      nthrd = fetch_thread(stream, pthrd->next);
+      while (nthrd && nthrd->branch && nthrd->branch != thrd->rawno)
+ 	nthrd = fetch_thread(stream, nthrd->branch);
+      if(nthrd && nthrd->branch && nthrd->branch == thrd->rawno)
+ 	branchp++;
+   }
+ 
+   if(branchp){
+     int entry = 0;
+     while(thrd && thrd->next){
+ 	entry = 1;
+ 	count++;
+ 	thrd = fetch_thread(stream, thrd->next);
+ 	if (thrd->branch)
+ 	   break;
+     }
+     if (entry && thrd->branch)
+ 	count--;
+   }
+   return branchp ? (count ? count : 1L) : 0L;
+ }
+ 
+ int pine_compare_size_thread(const qsort_t *a, const qsort_t *b)
+ {
+   SIZETHREAD_T *s = (SIZETHREAD_T *) a, *t = (SIZETHREAD_T *) b;
+ 
+   return s->count == t->count ? s->pos - t->pos : s->count - t->count;
+ }
+ 
+ 
+ 
+ void
+ find_msgmap(MAILSTREAM *stream, MSGNO_S *msgmap, int flags, SortOrder ordersort, unsigned is_rev)
+ {
+    long *old_arrival,*new_arrival;
+    long init_thread, end_thread, current;
+    long i, j, k;
+    long tmsg, ntmsg, nthreads;
+    SIZETHREAD_T *l;
+    PINETHRD_S *thrd;
+  
+    erase_thread_info = 0;
+    current = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+    switch(ordersort){
+ 	case SortSize:
+ 	     sort_folder(stream, msgmap, SortThread, 0, SRT_VRB, 0);
+ 	     tmsg = mn_get_total(msgmap) + 1;
+ 
+ 	     if(tmsg <= 1)
+ 		return;
+ 
+ 	     for (i= 1L, k = 0L; i <= mn_get_total(msgmap); i += count_thread(ps_global, stream, msgmap, msgmap->sort[i]), k++);
+ 	     l = (SIZETHREAD_T *) fs_get(k*sizeof(SIZETHREAD_T));
+ 	     for (j = 0L, i=1L; j < k && i<= mn_get_total(msgmap); ){
+ 		l[j].count = count_thread(ps_global, stream, msgmap, msgmap->sort[i]);
+ 		l[j].pos   = i;
+ 		i += l[j].count;
+ 		j++;
+ 	     }
+ 	     qsort((void *)l, (size_t) k, sizeof(SIZETHREAD_T), pine_compare_size_thread);
+ 	     old_arrival = (long *) fs_get(tmsg * sizeof(long));
+ 	     for(i = 1L, j = 0; j < k; j++){	/* copy thread of length .count */
+ 		int p;
+ 		for(p = 0; p < l[j].count; p++)
+ 		  old_arrival[i++] = msgmap->sort[l[j].pos + p]; 
+ 	     }
+ 	     fs_give((void **)&l);
+ 	     break;
+ 	default:
+ 	     sort_folder(stream, msgmap, ordersort, 0, SRT_VRB, 0);
+ 	     tmsg = mn_get_total(msgmap) + 1;
+ 
+ 	     if (tmsg <= 1)
+ 	       return;
+ 
+ 	     old_arrival = (long *) fs_get(tmsg * sizeof(long));
+ 	     for (i= 1L;(i <= mn_get_total(msgmap)) && (old_arrival[i] = msgmap->sort[i]); i++);
+ 		   /* sort by thread */
+ 	     sort_folder(stream, msgmap, SortThread, 0, SRT_VRB, 0);
+ 	     break;
+ 
+    }
+ 
+    ntmsg = mn_get_total(msgmap) + 1;
+    if (tmsg != ntmsg){	/* oh oh, something happened, we better try again */
+ 	fs_give((void **)&old_arrival);
+ 	find_msgmap(stream, msgmap, flags, ordersort, is_rev);
+ 	return;
+    }
+ 
+    /* reconstruct the msgmap */
+ 
+    new_arrival = (long *) fs_get(tmsg * sizeof(long));
+    memset(new_arrival, 0, tmsg*sizeof(long));
+    i = mn_get_total(msgmap);
+    /* we copy from the bottom, the last one to be filled is new_arrival[1] */
+    while (new_arrival[1] == 0){
+         int done = 0;
+ 	long n;
+ 
+         init_thread = top_thread(stream, old_arrival[i]);
+ 	thrd = fetch_thread(stream, init_thread);
+         for (n = mn_get_total(msgmap); new_arrival[n] != 0 && !done; n--)
+           done = (new_arrival[n] == init_thread);
+         if (!done){
+ 	   mn_set_cur(msgmap, mn_raw2m(msgmap, init_thread));
+ 	   if(move_next_thread(ps_global, stream, msgmap, 0) <= 0)
+ 	 	j = mn_get_total(msgmap) - mn_raw2m(msgmap, init_thread) + 1;
+ 	   else
+ 		j = mn_get_cur(msgmap) - mn_raw2m(msgmap, init_thread);
+            end_thread = mn_raw2m(msgmap, init_thread) + j;
+            for(k = 1L; k <= j; k++)
+               new_arrival[tmsg - k] = msgmap->sort[end_thread - k];
+            tmsg -= j;
+        }
+        i--;
+    }
+    relink_threads(stream, msgmap, new_arrival);
+    for (i = 1; (i <= mn_get_total(msgmap)) 
+ 		&&  (msgmap->sort[i] = new_arrival[i]); i++);
+    msgno_reset_isort(msgmap);
+ 
+    fs_give((void **)&new_arrival);
+    fs_give((void **)&old_arrival);
+ 
+ 
+    if(is_rev && (mn_get_total(msgmap) > 1L)){
+       long *rev_sort;
+       long i = 1L, l = mn_get_total(msgmap);
+ 
+       rev_sort = (long *) fs_get((mn_get_total(msgmap)+1L) * sizeof(long));
+       memset(rev_sort, 0, (mn_get_total(msgmap)+1L)*sizeof(long));
+       while (l > 0L){
+ 	 if (top_thread(stream, msgmap->sort[l]) == msgmap->sort[l]){
+ 	    long init_thread = msgmap->sort[l];
+ 	    long j, k;
+ 
+ 	    mn_set_cur(msgmap, mn_raw2m(msgmap, init_thread));
+ 	    if (move_next_thread(ps_global, stream, msgmap, 0) <= 0)
+ 	 	j = mn_get_total(msgmap) - mn_raw2m(msgmap, init_thread) + 1;
+ 	    else
+ 		j = mn_get_cur(msgmap) - mn_raw2m(msgmap, init_thread);
+ 	    for (k = 0L; (k < j) && (rev_sort[i+k] = msgmap->sort[l+k]); k++);
+ 	    i += j;
+ 	 }
+ 	 l--;
+       }
+       relink_threads(stream, msgmap, rev_sort);
+       for (i = 1L; i <=  mn_get_total(msgmap); i++)
+         msgmap->sort[i] = rev_sort[i];
+       msgno_reset_isort(msgmap);
+       fs_give((void **)&rev_sort);
+    }
+    mn_reset_cur(msgmap, first_sorted_flagged(is_rev ? F_NONE : F_SRCHBACK,
+ 			stream, mn_raw2m(msgmap, current), FSF_SKIP_CHID));
+    msgmap->top = -1L;
+ 
+    sp_set_unsorted_newmail(ps_global->mail_stream, 0);
+ 
+    for(i = 1L; i <= ps_global->mail_stream->nmsgs; i++)
+       mail_elt(ps_global->mail_stream, i)->spare7 = 0;
+ 
+    mn_set_sort(msgmap, SortThread);
+    mn_set_revsort(msgmap, is_rev);
+    erase_thread_info = 1;
+    clear_index_cache(stream, 0);
+ }
+ 
+ void
+ move_thread(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap, int direction)
+ {
+   long new_cursor, old_cursor = mn_get_cur(msgmap);
+   int rv;
+   PINETHRD_S *thrd;
+ 
+    rv = direction > 0 ? move_next_thread(state, stream, msgmap, 1):
+ 			move_prev_thread(state, stream, msgmap, 1);
+    if (rv > 0 && THRD_INDX_ENABLED()){
+        new_cursor = mn_get_cur(msgmap);
+        mn_set_cur(msgmap, old_cursor);
+        unview_thread(state, stream, msgmap);
+        thrd = fetch_thread(stream,mn_m2raw(msgmap, new_cursor));
+        mn_set_cur(msgmap, new_cursor);
+        view_thread(state, stream, msgmap, 1);
+        state->next_screen = SCREEN_FUN_NULL;
+    }
+ }
+ 
+ void
+ relink_threads(MAILSTREAM *stream, MSGNO_S *msgmap, long *new_arrival)
+ {
+    long last_thread = 0L;
+    long i = 0L, j = 1L, k;
+    PINETHRD_S *thrd, *nthrd;
+ 
+    while (j <= mn_get_total(msgmap)){ 
+ 	i++;
+ 	thrd = fetch_thread(stream, new_arrival[j]);
+ 	if (!thrd)  /* sort failed!, better leave from here now!!! */
+ 	   break;
+ 	thrd->prevthd = last_thread;
+ 	thrd->thrdno  = i;
+ 	thrd->head    = new_arrival[1];
+ 	last_thread = thrd->rawno;
+ 	mn_set_cur(msgmap, mn_raw2m(msgmap,thrd->top));
+ 	k = mn_get_cur(msgmap);
+ 	if  (move_next_thread(ps_global, stream, msgmap, 0) <= 0)
+ 	    j += mn_get_total(msgmap) + 1 - k;
+ 	else
+ 	    j += mn_get_cur(msgmap) - k;
+ 	if (!thrd->toploose)
+ 	   thrd->nextthd = (j <= mn_get_total(msgmap)) ? new_arrival[j] : 0L;
+ 	else{
+ 	  int done = 0;
+ 	  while(thrd->nextthd && !done){
+ 	      thrd->thrdno = i;
+ 	      thrd->head    = new_arrival[1];
+ 	      if (thrd->nextthd)
+ 		 nthrd = fetch_thread(stream, thrd->nextthd);
+ 	      else
+ 		done++;
+ 	      if(top_thread(stream, thrd->rawno) == top_thread(stream, nthrd->rawno))
+ 		thrd = nthrd;
+ 	      else
+ 		done++;
+ 	  }
+ 	  thrd->nextthd = (j <= mn_get_total(msgmap)) ? new_arrival[j] : 0L;
+ 	  last_thread = thrd->rawno;
+ 	}
+    }
+ }
+ 
+ int
+ move_next_this_thread(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap, int display)
+ {
+     PINETHRD_S   *thrd = NULL, *thrdnxt;
+     unsigned long rawno, top;
+     int       rv = 1;
+ 
+     if(!stream)
+        return -1;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+       return -1;
+ 
+    top = top_thread(stream, rawno);
+ 
+    thrdnxt = (top == rawno) ? fetch_thread(stream, top) : thrd;
+    if (thrdnxt->nextthd)
+        mn_set_cur(msgmap,mn_raw2m(msgmap, thrdnxt->nextthd));
+    else{
+        rv = 0;
+        if (display)
+          q_status_message(SM_ORDER, 0, 1, "No more Threads to advance");
+    }
+    return rv;
+ }
+ 
+ int
+ move_next_thread(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap, int display)
+ {
+     int collapsed, rv = 1, done = 0;
+     PINETHRD_S   *thrd = NULL;
+     unsigned long orig, orig_top, top;
+ 
+     if(!stream)
+       return 0;
+ 
+     orig = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     move_top_thread(stream, msgmap,orig);
+     top = orig_top = mn_m2raw(msgmap, mn_get_cur(msgmap));
+ 
+     if(top)
+       thrd = fetch_thread(stream, top);
+ 
+     if(!thrd)
+       return 0;
+ 
+     while (rv > 0 && !done){
+       rv = move_next_this_thread(state, stream, msgmap, display);
+       if (F_OFF(F_ENHANCED_THREAD, state)
+          || !(top = mn_m2raw(msgmap, mn_get_cur(msgmap)))
+          || (orig_top != top_thread(stream, top)))
+          done++;
+     }
+     if (display){
+         if (rv > 0 && SEP_THRDINDX())
+            q_status_message(SM_ORDER, 0, 2, "Viewing next thread");
+         if (!rv)
+            q_status_message(SM_ORDER, 0, 2, "No more threads to advance");
+     }
+     if(rv <= 0){
+        rv = 0;
+        mn_set_cur(msgmap, mn_raw2m(msgmap, orig));
+     }
+ 
+    return rv;
+ }
+ 
+ int
+ move_prev_thread(struct pine *state, MAILSTREAM *stream, MSGNO_S *msgmap, int display)
+ {
+     PINETHRD_S   *thrd = NULL;
+     unsigned long rawno, top;
+     int rv = 1;
+ 
+     if(!stream)
+       return -1;
+ 
+     rawno = mn_m2raw(msgmap, mn_get_cur(msgmap));
+     if(rawno)
+       thrd = fetch_thread(stream, rawno);
+ 
+     if(!thrd)
+        return -1;
+ 
+     top = top_thread(stream, rawno);
+ 
+     if (top != rawno)
+        mn_set_cur(msgmap,mn_raw2m(msgmap, top));
+     else if (thrd->prevthd)
+        mn_set_cur(msgmap,mn_raw2m(msgmap, top_thread(stream,thrd->prevthd)));
+     else
+       rv = 0;
+     if (display){
+         if (rv && SEP_THRDINDX())
+            q_status_message(SM_ORDER, 0, 2, "Viewing previous thread");
+         if (!rv)
+            q_status_message(SM_ORDER, 0, 2, "No more threads to go back");
+     }
+ 
+     return rv;
+ }
+ 
+ /* add more keys to this list */
+ int
+ allowed_thread_key(SortOrder sort)
+ {
+   return sort == SortArrival || sort == SortDate
+ 	  || sort == SortScore || sort == SortThread
+ 	  || sort == SortSize;
+ }
+ 
diff -rc alpine-2.11/pith/thread.h alpine-2.11.I.USE/pith/thread.h
*** alpine-2.11/pith/thread.h	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/thread.h	2013-12-01 16:33:57.000000000 -0700
***************
*** 37,42 ****
--- 37,43 ----
      unsigned long nextthd;	/* next thread, only tops have this	*/
      unsigned long prevthd;	/* previous thread, only tops have this	*/
      unsigned long top;		/* top of this thread			*/
+     unsigned long toploose;	/* top of this thread, if is loose	*/
      unsigned long head;		/* head of the whole thread list	*/
  } PINETHRD_S;
  
***************
*** 92,98 ****
  void	      sort_thread_callback(MAILSTREAM *, THREADNODE *);
  void	      collapse_threads(MAILSTREAM *, MSGNO_S *, PINETHRD_S *);
  PINETHRD_S   *msgno_thread_info(MAILSTREAM *, unsigned long, PINETHRD_S *, unsigned);
! void	      collapse_or_expand(struct pine *, MAILSTREAM *, MSGNO_S *, unsigned long);
  void	      select_thread_stmp(struct pine *, MAILSTREAM *, MSGNO_S *);
  unsigned long count_flags_in_thread(MAILSTREAM *, PINETHRD_S *, long);
  unsigned long count_lflags_in_thread(MAILSTREAM *, PINETHRD_S *, MSGNO_S *, int);
--- 93,99 ----
  void	      sort_thread_callback(MAILSTREAM *, THREADNODE *);
  void	      collapse_threads(MAILSTREAM *, MSGNO_S *, PINETHRD_S *);
  PINETHRD_S   *msgno_thread_info(MAILSTREAM *, unsigned long, PINETHRD_S *, unsigned);
! void	      collapse_or_expand(struct pine *, MAILSTREAM *, MSGNO_S *, unsigned long, int);
  void	      select_thread_stmp(struct pine *, MAILSTREAM *, MSGNO_S *);
  unsigned long count_flags_in_thread(MAILSTREAM *, PINETHRD_S *, long);
  unsigned long count_lflags_in_thread(MAILSTREAM *, PINETHRD_S *, MSGNO_S *, int);
***************
*** 106,111 ****
  int	      unview_thread(struct pine *, MAILSTREAM *, MSGNO_S *);
  PINETHRD_S   *find_thread_by_number(MAILSTREAM *, MSGNO_S *, long, PINETHRD_S *);
  void	      set_search_bit_for_thread(MAILSTREAM *, PINETHRD_S *, SEARCHSET **);
! 
  
  #endif /* PITH_THREAD_INCLUDED */
--- 107,130 ----
  int	      unview_thread(struct pine *, MAILSTREAM *, MSGNO_S *);
  PINETHRD_S   *find_thread_by_number(MAILSTREAM *, MSGNO_S *, long, PINETHRD_S *);
  void	      set_search_bit_for_thread(MAILSTREAM *, PINETHRD_S *, SEARCHSET **);
! void	      find_msgmap(MAILSTREAM *, MSGNO_S *, int, SortOrder, unsigned);
! void	      move_thread(struct pine *, MAILSTREAM *, MSGNO_S *, int);
! void	      relink_threads(MAILSTREAM *, MSGNO_S *, long *);
! long	      top_thread(MAILSTREAM *, long);
! long	      top_this_thread(MAILSTREAM *, long);
! long	      get_length_branch(MAILSTREAM *, long);
! unsigned long get_next(MAILSTREAM *,PINETHRD_S *);
! unsigned long get_branch(MAILSTREAM *,PINETHRD_S *);
! int	      count_thread(struct pine *, MAILSTREAM *, MSGNO_S *, long);
! int	      count_this_thread(MAILSTREAM *, unsigned long);
! int	      this_thread_is_kolapsed(struct pine *, MAILSTREAM *, MSGNO_S *, long);
! int	      thread_is_kolapsed(struct pine *, MAILSTREAM *, MSGNO_S *, long);
! int	      move_prev_thread(struct pine *, MAILSTREAM  *, MSGNO_S *, int);
! int	      move_next_thread(struct pine *, MAILSTREAM  *, MSGNO_S *, int);
! int	      move_next_this_thread(struct pine *, MAILSTREAM  *, MSGNO_S *, int);
! void	      move_top_thread(MAILSTREAM *, MSGNO_S *, long);
! void	      move_top_this_thread(MAILSTREAM *, MSGNO_S *, long);
! THREADNODE   *copy_tree(THREADNODE *);
! int	      allowed_thread_key(SortOrder sort);
  
  #endif /* PITH_THREAD_INCLUDED */
diff -rc alpine-2.11/pith/url.c alpine-2.11.I.USE/pith/url.c
*** alpine-2.11/pith/url.c	2013-08-14 22:36:50.000000000 -0600
--- alpine-2.11.I.USE/pith/url.c	2013-12-01 16:39:57.000000000 -0700
***************
*** 53,59 ****
  rfc1738_scan(char *line, int *len)
  {
      char *colon, *start, *end;
!     int   n;
  
      /* process each : in the line */
      for(; (colon = strindex(line, ':')) != NULL; line = end){
--- 53,59 ----
  rfc1738_scan(char *line, int *len)
  {
      char *colon, *start, *end;
!     int   n, delim;
  
      /* process each : in the line */
      for(; (colon = strindex(line, ':')) != NULL; line = end){
***************
*** 143,148 ****
--- 143,149 ----
  
  		if(i != j){
  		    *len = end - start;
+ 		    delim = start > line && *(start - 1) == '<';
  
  		    /*
  		     * Special case handling for comma.
***************
*** 152,159 ****
  		     * In most cases any way, that's why we have the
  		     * exception.
  		     */
! 		    if(*(end - 1) == ','
! 		       || (*(end - 1) == '.' && (!*end  || *end == ' ')))
  		      (*len)--;
  
  		    if(*len - (colon - start) > 0)
--- 153,160 ----
  		     * In most cases any way, that's why we have the
  		     * exception.
  		     */
! 		    if(delim == 0 && (*(end - 1) == ','
! 		       || (*(end - 1) == '.' && (!*end  || *end == ' '))))
  		      (*len)--;
  
  		    if(*len - (colon - start) > 0)
diff -rc alpine-2.11/README.maildir alpine-2.11.I.USE/README.maildir
*** alpine-2.11/README.maildir	2013-12-01 16:41:34.000000000 -0700
--- alpine-2.11.I.USE/README.maildir	2013-12-01 16:34:08.000000000 -0700
***************
*** 0 ****
--- 1,149 ----
+ ---------------------------------------
+ 
+ Maildir Driver for Alpine 2.0
+ By Eduardo Chappa 
+ <chappa@gmx.com>
+ 
+ ---------------------------------------
+ 1. General Information About This Patch
+ ---------------------------------------
+ 
+ This patch adds support for the maildir format to Alpine. We take the 
+ approach that this patch is one more driver among the number of formats 
+ supported by Alpine (more generally c-client). This approach differs from 
+ older versions of similar patches, in that once a maildir patch was 
+ applied, it was assumed that all your folders would be created in the 
+ maildir format. 
+ 
+ This patch does not assume that maildir is a preferred format, instead 
+ puts maildir in equal footing with other formats (mbox, mbx, mix, etc), 
+ and so a maildir folder in the mail/ collection is treated in the same way 
+ as any other folder in any other format. In other words, just by reading 
+ the name of a folder, or opening it, or doing any operation with it, you 
+ can not know in which format the folder is.
+ 
+ This implies that if you want to add a folder in the maildir format to the 
+ mail/ collection, then you must add by pressing "A" in the folder list 
+ collection and enter "#driver.md/mail/name_maildir_folder".
+ 
+ If you only want to use maildir, however, you can do so too. In this case, 
+ you must create a maildir collection. In that collection, only maildir 
+ folders will be listed. If there is any folder in any other format, that 
+ folder will be ignored. In another words, any folder listed there is in 
+ maildir format and can be accessed through that collection, conversely, 
+ any folder not listed there is not in maildir format and there is no way 
+ to access it using this collection.
+ 
+ In order to create a maildir collection, you could press M S L, and "A" to 
+ add a collection. Fill in the required fields as follows:
+ 
+ Nickname  : Anything
+ Server    :
+ Path      : #md/relative/path/to/maildir/collection/
+ View      :
+ 
+ For example, if "path" is set to "#md/mail/", then Alpine will look for your 
+ maildir folders that are in ~/mail/.
+ 
+ The code in this patch is mostly based in code for the unix driver plus 
+ some combinations of the mh, mbx and nntp drivers for the c-client 
+ library. Those drivers were designed by Mark Crispin, and bugs in this 
+ code are not his bugs, but my own.
+ 
+   I got all the specification for this patch from 
+ http://cr.yp.to/proto/maildir.html. If you know of a place with a better 
+ specification for maildir format please let me know. The method this patch 
+ uses to create a unique filename for a message is one of the "old 
+ fashioned" methods. I realize that this is old fashioned, but it is 
+ portable, and portability is the main reason why I decided to use an old 
+ fashioned method (most methods are not portable. See the word 
+ "Unfortunately" in that document).
+ 
+ --------------
+ 2. Other Goals
+ --------------
+ 
+   It is intended that this code will work well with any application 
+ written using the c-client library. Of paramount importance is to make the 
+ associated imap server work well when the server accesses a folder in 
+ Maildir format. The program mailutil should also work flawlessly with this 
+ implemetation of the driver.
+ 
+   It is intended that this driver be fast and stable. We intend not to 
+ patch Alpine to make this driver do its work, unless such patching is for 
+ fixing bugs in Alpine or to pass parameters to the driver.
+ 
+ ------------------------------------------------------------------------ 
+ 3. What are the known bugs of this implementation of the Maildir driver? 
+ ------------------------------------------------------------------------
+ 
+   I don't know any at this time. There have been bugs before, though, but 
+ I try to fix bugs as soon as they are reported. 
+ 
+ ----------
+ 4. On UIDs
+ ----------
+ 
+  This patch keeps uids in the name of the file that contains the message, 
+ by adding a ",u=" string to the file name to save the uid of a message. A 
+ file is kept between sessions to save information on the last uid assigned 
+ and its time of validity. Only one session with writing access can write 
+ uids, all others must wait for the other session to assign them. The 
+ session assigning uids creates a ".uidtemp" file which other sessions must 
+ not disturb.
+ 
+   Uid support appeared in Alpine 1.00 (snapshot 925), and is experimental,
+ please report any problems.
+ 
+ ----------------------------------------------
+ 5. Configuring Alpine and Setting up a Maildir 
+ ----------------------------------------------
+ 
+ Once this approach was chosen, it implied the following:
+ 
+     * This patch assumes that your INBOX is located at "$HOME/Maildir".  
+       This is a directory which should have three subdirectories "cur", 
+       "tmp" and "new". Mail is delivered to 'new' and read from 'cur'. I 
+       have added a configuration option "maildir-location" which can be 
+       used to tell Alpine where your Maildir inbox is, in case your system 
+       does not use the above directory (e.g. your system may use 
+       "~/.maildir"). In this case define that variable to be the name of 
+       the directory where your e-mail is being delivered (e.g.  
+       ".maildir").
+ 
+     * If you want to use the above configuration as your inbox, you must 
+       define your inbox-path as "#md/inbox" (no quotes).  You can define 
+       the inbox-path like above even if you have changed the 
+       maildir-location variable. That's the whole point of that variable.
+ 
+ -------------------------------------------
+ 6. What about Courier/Dovecot file systems?
+ -------------------------------------------
+ 
+ In a courier file system all folders are subfolders of a root folder 
+ called INBOX. Normally INBOX is located at ~/Maildir and subfolders are 
+ "dot" directories in ~/Maildir. For example ~/Maildir/.Trash is a 
+ subfolder of INBOX and is accessed with the nickname "INBOX.Trash".
+ 
+ You can not access folders in this way unless you preceed them with the 
+ string "#mc/". The purpose of the string "#mc/" is to warn Alpine that a 
+ collection in the Courier format is going to be accessed. Therefore, you 
+ can SELECT a folder like "#mc/INBOX.Trash", but not "INBOX.Trash"
+ 
+ You can access a collection through a server, but if you want to access a 
+ collection of folders created using the Courier server, you MUST edit your
+ ".pinerc" file and enter the definition of the collection as follows:
+ 
+ folder-collections="Anything you want" #mc/INBOX.[]
+ 
+ You can replace the string "#mc/INBOX." by something different, for example
+ "#mc/Courier/." will make Alpine search for your collection in ~/Courier.
+ 
+ You can not add this setting directly into Alpine because Alpine fails to 
+ accept this value from its input, but it takes it correctly when it is 
+ added through the ".pinerc" file.
+ 
+ You can access your inbox as "#mc/INBOX" or "#md/INBOX". Both definitions 
+ point to the same place.
+ 
+ Last Updated May 28, 2011
diff -rc alpine-2.11/web/src/alpined.d/alpined.c alpine-2.11.I.USE/web/src/alpined.d/alpined.c
*** alpine-2.11/web/src/alpined.d/alpined.c	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/web/src/alpined.d/alpined.c	2013-12-01 16:41:14.000000000 -0700
***************
*** 334,340 ****
  
  
  /* Internal prototypes */
! void	     peReturn(int, char *, char *);
  int	     peWrite(int, char *);
  char	    *peCreateUserContext(Tcl_Interp *, char *, char *, char *);
  void	     peDestroyUserContext(struct pine **);
--- 334,340 ----
  
  
  /* Internal prototypes */
! void	     peReturn(int, char *, const char *);
  int	     peWrite(int, char *);
  char	    *peCreateUserContext(Tcl_Interp *, char *, char *, char *);
  void	     peDestroyUserContext(struct pine **);
***************
*** 760,769 ****
  				}
  
  				switch(Tcl_Eval(interp, &buf[co])){
! 				  case TCL_OK	  : peReturn(cs, "OK", interp->result); break;
! 				  case TCL_ERROR  : peReturn(cs, "ERROR", interp->result); break;
! 				  case TCL_BREAK  : peReturn(cs, "BREAK", interp->result); break;
! 				  case TCL_RETURN : peReturn(cs, "RETURN", interp->result); break;
  				  default	  : peReturn(cs, "BOGUS", "eval returned unexpected value"); break;
  				}
  			    }
--- 760,769 ----
  				}
  
  				switch(Tcl_Eval(interp, &buf[co])){
! 				  case TCL_OK	  : peReturn(cs, "OK", Tcl_GetStringResult(interp)); break;
! 				  case TCL_ERROR  : peReturn(cs, "ERROR", Tcl_GetStringResult(interp)); break;
! 				  case TCL_BREAK  : peReturn(cs, "BREAK", Tcl_GetStringResult(interp)); break;
! 				  case TCL_RETURN : peReturn(cs, "RETURN", Tcl_GetStringResult(interp)); break;
  				  default	  : peReturn(cs, "BOGUS", "eval returned unexpected value"); break;
  				}
  			    }
***************
*** 808,818 ****
   * peReturn - common routine to return TCL result
   */
  void
! peReturn(int sock, char *status, char *result)
  {
      if(peWrite(sock, status))
        if(peWrite(sock, "\n"))
! 	peWrite(sock, result);
  }
  
  /*
--- 808,818 ----
   * peReturn - common routine to return TCL result
   */
  void
! peReturn(int sock, char *status, const char *result)
  {
      if(peWrite(sock, status))
        if(peWrite(sock, "\n"))
! 	peWrite(sock, (char *) result);
  }
  
  /*
***************
*** 2755,2761 ****
  			      init_save_defaults();
  			      break;
  			    case V_SORT_KEY:
! 			      decode_sort(ps_global->VAR_SORT_KEY, &ps_global->def_sort, &def_sort_rev);
  			      break;
  			    case V_VIEW_HDR_COLORS :
  			      set_custom_spec_colors(ps_global);
--- 2755,2761 ----
  			      init_save_defaults();
  			      break;
  			    case V_SORT_KEY:
! 			      decode_sort(ps_global->VAR_SORT_KEY, &ps_global->def_sort, &def_sort_rev, 0);
  			      break;
  			    case V_VIEW_HDR_COLORS :
  			      set_custom_spec_colors(ps_global);
***************
*** 6331,6337 ****
  				      && mn_get_revsort(sp_msgmap(ps_global->mail_stream)) == reversed))
  				sort_folder(ps_global->mail_stream, sp_msgmap(ps_global->mail_stream),
  					    ps_global->sort_types[i], 
! 					    reversed, 0);
  
  			      break;
  			  }
--- 6331,6337 ----
  				      && mn_get_revsort(sp_msgmap(ps_global->mail_stream)) == reversed))
  				sort_folder(ps_global->mail_stream, sp_msgmap(ps_global->mail_stream),
  					    ps_global->sort_types[i], 
! 					    reversed, 0, 1);
  
  			      break;
  			  }
diff -rc alpine-2.11/web/src/alpined.d/Makefile.am alpine-2.11.I.USE/web/src/alpined.d/Makefile.am
*** alpine-2.11/web/src/alpined.d/Makefile.am	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/web/src/alpined.d/Makefile.am	2013-12-01 16:41:04.000000000 -0700
***************
*** 50,52 ****
--- 50,53 ----
  	 debug.c status.c stubs.c alpined.h color.h ldap.h
  	echo "char datestamp[]="\"`date`\"";" > local.c
  	echo "char hoststamp[]="\"`hostname`\"";" >> local.c
+ 	cat ../../../patchlevel >> local.c
diff -rc alpine-2.11/web/src/alpined.d/Makefile.in alpine-2.11.I.USE/web/src/alpined.d/Makefile.in
*** alpine-2.11/web/src/alpined.d/Makefile.in	2013-08-14 22:36:01.000000000 -0600
--- alpine-2.11.I.USE/web/src/alpined.d/Makefile.in	2013-12-01 16:41:04.000000000 -0700
***************
*** 694,700 ****
  	 debug.c status.c stubs.c alpined.h color.h ldap.h
  	echo "char datestamp[]="\"`date`\"";" > local.c
  	echo "char hoststamp[]="\"`hostname`\"";" >> local.c
! 
  # Tell versions [3.59,3.63) of GNU make to not export all variables.
  # Otherwise a system limit (for SysV at least) may be exceeded.
  .NOEXPORT:
--- 694,700 ----
  	 debug.c status.c stubs.c alpined.h color.h ldap.h
  	echo "char datestamp[]="\"`date`\"";" > local.c
  	echo "char hoststamp[]="\"`hostname`\"";" >> local.c
! 	cat ../../../patchlevel >> local.c
  # Tell versions [3.59,3.63) of GNU make to not export all variables.
  # Otherwise a system limit (for SysV at least) may be exceeded.
  .NOEXPORT:
